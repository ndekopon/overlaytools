// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: events.proto
// Protobuf C++ Version: 4.25.2

#ifndef GOOGLE_PROTOBUF_INCLUDED_events_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_events_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4025000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4025002 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_bases.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
#include "google/protobuf/any.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_events_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_events_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_events_2eproto;
namespace rtech {
namespace liveapi {
class AmmoUsed;
struct AmmoUsedDefaultTypeInternal;
extern AmmoUsedDefaultTypeInternal _AmmoUsed_default_instance_;
class ArenasItemDeselected;
struct ArenasItemDeselectedDefaultTypeInternal;
extern ArenasItemDeselectedDefaultTypeInternal _ArenasItemDeselected_default_instance_;
class ArenasItemSelected;
struct ArenasItemSelectedDefaultTypeInternal;
extern ArenasItemSelectedDefaultTypeInternal _ArenasItemSelected_default_instance_;
class BannerCollected;
struct BannerCollectedDefaultTypeInternal;
extern BannerCollectedDefaultTypeInternal _BannerCollected_default_instance_;
class BlackMarketAction;
struct BlackMarketActionDefaultTypeInternal;
extern BlackMarketActionDefaultTypeInternal _BlackMarketAction_default_instance_;
class ChangeCamera;
struct ChangeCameraDefaultTypeInternal;
extern ChangeCameraDefaultTypeInternal _ChangeCamera_default_instance_;
class CharacterSelected;
struct CharacterSelectedDefaultTypeInternal;
extern CharacterSelectedDefaultTypeInternal _CharacterSelected_default_instance_;
class CustomMatch_CreateLobby;
struct CustomMatch_CreateLobbyDefaultTypeInternal;
extern CustomMatch_CreateLobbyDefaultTypeInternal _CustomMatch_CreateLobby_default_instance_;
class CustomMatch_GetLobbyPlayers;
struct CustomMatch_GetLobbyPlayersDefaultTypeInternal;
extern CustomMatch_GetLobbyPlayersDefaultTypeInternal _CustomMatch_GetLobbyPlayers_default_instance_;
class CustomMatch_GetSettings;
struct CustomMatch_GetSettingsDefaultTypeInternal;
extern CustomMatch_GetSettingsDefaultTypeInternal _CustomMatch_GetSettings_default_instance_;
class CustomMatch_JoinLobby;
struct CustomMatch_JoinLobbyDefaultTypeInternal;
extern CustomMatch_JoinLobbyDefaultTypeInternal _CustomMatch_JoinLobby_default_instance_;
class CustomMatch_KickPlayer;
struct CustomMatch_KickPlayerDefaultTypeInternal;
extern CustomMatch_KickPlayerDefaultTypeInternal _CustomMatch_KickPlayer_default_instance_;
class CustomMatch_LeaveLobby;
struct CustomMatch_LeaveLobbyDefaultTypeInternal;
extern CustomMatch_LeaveLobbyDefaultTypeInternal _CustomMatch_LeaveLobby_default_instance_;
class CustomMatch_LobbyPlayer;
struct CustomMatch_LobbyPlayerDefaultTypeInternal;
extern CustomMatch_LobbyPlayerDefaultTypeInternal _CustomMatch_LobbyPlayer_default_instance_;
class CustomMatch_LobbyPlayers;
struct CustomMatch_LobbyPlayersDefaultTypeInternal;
extern CustomMatch_LobbyPlayersDefaultTypeInternal _CustomMatch_LobbyPlayers_default_instance_;
class CustomMatch_SendChat;
struct CustomMatch_SendChatDefaultTypeInternal;
extern CustomMatch_SendChatDefaultTypeInternal _CustomMatch_SendChat_default_instance_;
class CustomMatch_SetMatchmaking;
struct CustomMatch_SetMatchmakingDefaultTypeInternal;
extern CustomMatch_SetMatchmakingDefaultTypeInternal _CustomMatch_SetMatchmaking_default_instance_;
class CustomMatch_SetReady;
struct CustomMatch_SetReadyDefaultTypeInternal;
extern CustomMatch_SetReadyDefaultTypeInternal _CustomMatch_SetReady_default_instance_;
class CustomMatch_SetSettings;
struct CustomMatch_SetSettingsDefaultTypeInternal;
extern CustomMatch_SetSettingsDefaultTypeInternal _CustomMatch_SetSettings_default_instance_;
class CustomMatch_SetTeam;
struct CustomMatch_SetTeamDefaultTypeInternal;
extern CustomMatch_SetTeamDefaultTypeInternal _CustomMatch_SetTeam_default_instance_;
class CustomMatch_SetTeamName;
struct CustomMatch_SetTeamNameDefaultTypeInternal;
extern CustomMatch_SetTeamNameDefaultTypeInternal _CustomMatch_SetTeamName_default_instance_;
class Datacenter;
struct DatacenterDefaultTypeInternal;
extern DatacenterDefaultTypeInternal _Datacenter_default_instance_;
class GameStateChanged;
struct GameStateChangedDefaultTypeInternal;
extern GameStateChangedDefaultTypeInternal _GameStateChanged_default_instance_;
class GibraltarShieldAbsorbed;
struct GibraltarShieldAbsorbedDefaultTypeInternal;
extern GibraltarShieldAbsorbedDefaultTypeInternal _GibraltarShieldAbsorbed_default_instance_;
class GrenadeThrown;
struct GrenadeThrownDefaultTypeInternal;
extern GrenadeThrownDefaultTypeInternal _GrenadeThrown_default_instance_;
class Init;
struct InitDefaultTypeInternal;
extern InitDefaultTypeInternal _Init_default_instance_;
class InventoryDrop;
struct InventoryDropDefaultTypeInternal;
extern InventoryDropDefaultTypeInternal _InventoryDrop_default_instance_;
class InventoryItem;
struct InventoryItemDefaultTypeInternal;
extern InventoryItemDefaultTypeInternal _InventoryItem_default_instance_;
class InventoryPickUp;
struct InventoryPickUpDefaultTypeInternal;
extern InventoryPickUpDefaultTypeInternal _InventoryPickUp_default_instance_;
class InventoryUse;
struct InventoryUseDefaultTypeInternal;
extern InventoryUseDefaultTypeInternal _InventoryUse_default_instance_;
class LegendUpgradeSelected;
struct LegendUpgradeSelectedDefaultTypeInternal;
extern LegendUpgradeSelectedDefaultTypeInternal _LegendUpgradeSelected_default_instance_;
class LiveAPIEvent;
struct LiveAPIEventDefaultTypeInternal;
extern LiveAPIEventDefaultTypeInternal _LiveAPIEvent_default_instance_;
class LoadoutConfiguration;
struct LoadoutConfigurationDefaultTypeInternal;
extern LoadoutConfigurationDefaultTypeInternal _LoadoutConfiguration_default_instance_;
class MatchSetup;
struct MatchSetupDefaultTypeInternal;
extern MatchSetupDefaultTypeInternal _MatchSetup_default_instance_;
class MatchStateEnd;
struct MatchStateEndDefaultTypeInternal;
extern MatchStateEndDefaultTypeInternal _MatchStateEnd_default_instance_;
class ObserverAnnotation;
struct ObserverAnnotationDefaultTypeInternal;
extern ObserverAnnotationDefaultTypeInternal _ObserverAnnotation_default_instance_;
class ObserverSwitched;
struct ObserverSwitchedDefaultTypeInternal;
extern ObserverSwitchedDefaultTypeInternal _ObserverSwitched_default_instance_;
class PauseToggle;
struct PauseToggleDefaultTypeInternal;
extern PauseToggleDefaultTypeInternal _PauseToggle_default_instance_;
class Player;
struct PlayerDefaultTypeInternal;
extern PlayerDefaultTypeInternal _Player_default_instance_;
class PlayerAbilityUsed;
struct PlayerAbilityUsedDefaultTypeInternal;
extern PlayerAbilityUsedDefaultTypeInternal _PlayerAbilityUsed_default_instance_;
class PlayerAssist;
struct PlayerAssistDefaultTypeInternal;
extern PlayerAssistDefaultTypeInternal _PlayerAssist_default_instance_;
class PlayerConnected;
struct PlayerConnectedDefaultTypeInternal;
extern PlayerConnectedDefaultTypeInternal _PlayerConnected_default_instance_;
class PlayerDamaged;
struct PlayerDamagedDefaultTypeInternal;
extern PlayerDamagedDefaultTypeInternal _PlayerDamaged_default_instance_;
class PlayerDisconnected;
struct PlayerDisconnectedDefaultTypeInternal;
extern PlayerDisconnectedDefaultTypeInternal _PlayerDisconnected_default_instance_;
class PlayerDowned;
struct PlayerDownedDefaultTypeInternal;
extern PlayerDownedDefaultTypeInternal _PlayerDowned_default_instance_;
class PlayerKilled;
struct PlayerKilledDefaultTypeInternal;
extern PlayerKilledDefaultTypeInternal _PlayerKilled_default_instance_;
class PlayerRespawnTeam;
struct PlayerRespawnTeamDefaultTypeInternal;
extern PlayerRespawnTeamDefaultTypeInternal _PlayerRespawnTeam_default_instance_;
class PlayerRevive;
struct PlayerReviveDefaultTypeInternal;
extern PlayerReviveDefaultTypeInternal _PlayerRevive_default_instance_;
class PlayerStatChanged;
struct PlayerStatChangedDefaultTypeInternal;
extern PlayerStatChangedDefaultTypeInternal _PlayerStatChanged_default_instance_;
class PlayerUpgradeTierChanged;
struct PlayerUpgradeTierChangedDefaultTypeInternal;
extern PlayerUpgradeTierChangedDefaultTypeInternal _PlayerUpgradeTierChanged_default_instance_;
class Request;
struct RequestDefaultTypeInternal;
extern RequestDefaultTypeInternal _Request_default_instance_;
class RequestStatus;
struct RequestStatusDefaultTypeInternal;
extern RequestStatusDefaultTypeInternal _RequestStatus_default_instance_;
class Response;
struct ResponseDefaultTypeInternal;
extern ResponseDefaultTypeInternal _Response_default_instance_;
class RevenantForgedShadowDamaged;
struct RevenantForgedShadowDamagedDefaultTypeInternal;
extern RevenantForgedShadowDamagedDefaultTypeInternal _RevenantForgedShadowDamaged_default_instance_;
class RingFinishedClosing;
struct RingFinishedClosingDefaultTypeInternal;
extern RingFinishedClosingDefaultTypeInternal _RingFinishedClosing_default_instance_;
class RingStartClosing;
struct RingStartClosingDefaultTypeInternal;
extern RingStartClosingDefaultTypeInternal _RingStartClosing_default_instance_;
class SquadEliminated;
struct SquadEliminatedDefaultTypeInternal;
extern SquadEliminatedDefaultTypeInternal _SquadEliminated_default_instance_;
class Vector3;
struct Vector3DefaultTypeInternal;
extern Vector3DefaultTypeInternal _Vector3_default_instance_;
class Version;
struct VersionDefaultTypeInternal;
extern VersionDefaultTypeInternal _Version_default_instance_;
class WarpGateUsed;
struct WarpGateUsedDefaultTypeInternal;
extern WarpGateUsedDefaultTypeInternal _WarpGateUsed_default_instance_;
class WeaponSwitched;
struct WeaponSwitchedDefaultTypeInternal;
extern WeaponSwitchedDefaultTypeInternal _WeaponSwitched_default_instance_;
class WraithPortal;
struct WraithPortalDefaultTypeInternal;
extern WraithPortalDefaultTypeInternal _WraithPortal_default_instance_;
class ZiplineUsed;
struct ZiplineUsedDefaultTypeInternal;
extern ZiplineUsedDefaultTypeInternal _ZiplineUsed_default_instance_;
}  // namespace liveapi
}  // namespace rtech
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace rtech {
namespace liveapi {
enum PlayerOfInterest : int {
  UNSPECIFIED = 0,
  NEXT = 1,
  PREVIOUS = 2,
  KILL_LEADER = 3,
  CLOSEST_ENEMY = 4,
  CLOSEST_PLAYER = 5,
  LATEST_ATTACKER = 6,
  PlayerOfInterest_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  PlayerOfInterest_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool PlayerOfInterest_IsValid(int value);
extern const uint32_t PlayerOfInterest_internal_data_[];
constexpr PlayerOfInterest PlayerOfInterest_MIN = static_cast<PlayerOfInterest>(0);
constexpr PlayerOfInterest PlayerOfInterest_MAX = static_cast<PlayerOfInterest>(6);
constexpr int PlayerOfInterest_ARRAYSIZE = 6 + 1;
const ::google::protobuf::EnumDescriptor*
PlayerOfInterest_descriptor();
template <typename T>
const std::string& PlayerOfInterest_Name(T value) {
  static_assert(std::is_same<T, PlayerOfInterest>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to PlayerOfInterest_Name().");
  return PlayerOfInterest_Name(static_cast<PlayerOfInterest>(value));
}
template <>
inline const std::string& PlayerOfInterest_Name(PlayerOfInterest value) {
  return ::google::protobuf::internal::NameOfDenseEnum<PlayerOfInterest_descriptor,
                                                 0, 6>(
      static_cast<int>(value));
}
inline bool PlayerOfInterest_Parse(absl::string_view name, PlayerOfInterest* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PlayerOfInterest>(
      PlayerOfInterest_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class Version final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rtech.liveapi.Version) */ {
 public:
  inline Version() : Version(nullptr) {}
  ~Version() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Version(::google::protobuf::internal::ConstantInitialized);

  inline Version(const Version& from)
      : Version(nullptr, from) {}
  Version(Version&& from) noexcept
    : Version() {
    *this = ::std::move(from);
  }

  inline Version& operator=(const Version& from) {
    CopyFrom(from);
    return *this;
  }
  inline Version& operator=(Version&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Version& default_instance() {
    return *internal_default_instance();
  }
  static inline const Version* internal_default_instance() {
    return reinterpret_cast<const Version*>(
               &_Version_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Version& a, Version& b) {
    a.Swap(&b);
  }
  inline void Swap(Version* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Version* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Version* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Version>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Version& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Version& from) {
    Version::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Version* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "rtech.liveapi.Version";
  }
  protected:
  explicit Version(::google::protobuf::Arena* arena);
  Version(::google::protobuf::Arena* arena, const Version& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRevisionFieldNumber = 4,
    kMajorNumFieldNumber = 1,
    kMinorNumFieldNumber = 2,
    kBuildStampFieldNumber = 3,
  };
  // string revision = 4;
  void clear_revision() ;
  const std::string& revision() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_revision(Arg_&& arg, Args_... args);
  std::string* mutable_revision();
  PROTOBUF_NODISCARD std::string* release_revision();
  void set_allocated_revision(std::string* value);

  private:
  const std::string& _internal_revision() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_revision(
      const std::string& value);
  std::string* _internal_mutable_revision();

  public:
  // uint32 major_num = 1;
  void clear_major_num() ;
  ::uint32_t major_num() const;
  void set_major_num(::uint32_t value);

  private:
  ::uint32_t _internal_major_num() const;
  void _internal_set_major_num(::uint32_t value);

  public:
  // uint32 minor_num = 2;
  void clear_minor_num() ;
  ::uint32_t minor_num() const;
  void set_minor_num(::uint32_t value);

  private:
  ::uint32_t _internal_minor_num() const;
  void _internal_set_minor_num(::uint32_t value);

  public:
  // uint32 build_stamp = 3;
  void clear_build_stamp() ;
  ::uint32_t build_stamp() const;
  void set_build_stamp(::uint32_t value);

  private:
  ::uint32_t _internal_build_stamp() const;
  void _internal_set_build_stamp(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:rtech.liveapi.Version)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 0,
      38, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr revision_;
    ::uint32_t major_num_;
    ::uint32_t minor_num_;
    ::uint32_t build_stamp_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_events_2eproto;
};// -------------------------------------------------------------------

class Vector3 final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rtech.liveapi.Vector3) */ {
 public:
  inline Vector3() : Vector3(nullptr) {}
  ~Vector3() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Vector3(::google::protobuf::internal::ConstantInitialized);

  inline Vector3(const Vector3& from)
      : Vector3(nullptr, from) {}
  Vector3(Vector3&& from) noexcept
    : Vector3() {
    *this = ::std::move(from);
  }

  inline Vector3& operator=(const Vector3& from) {
    CopyFrom(from);
    return *this;
  }
  inline Vector3& operator=(Vector3&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Vector3& default_instance() {
    return *internal_default_instance();
  }
  static inline const Vector3* internal_default_instance() {
    return reinterpret_cast<const Vector3*>(
               &_Vector3_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Vector3& a, Vector3& b) {
    a.Swap(&b);
  }
  inline void Swap(Vector3* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Vector3* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Vector3* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Vector3>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Vector3& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Vector3& from) {
    Vector3::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Vector3* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "rtech.liveapi.Vector3";
  }
  protected:
  explicit Vector3(::google::protobuf::Arena* arena);
  Vector3(::google::protobuf::Arena* arena, const Vector3& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kZFieldNumber = 3,
  };
  // float x = 1;
  void clear_x() ;
  float x() const;
  void set_x(float value);

  private:
  float _internal_x() const;
  void _internal_set_x(float value);

  public:
  // float y = 2;
  void clear_y() ;
  float y() const;
  void set_y(float value);

  private:
  float _internal_y() const;
  void _internal_set_y(float value);

  public:
  // float z = 3;
  void clear_z() ;
  float z() const;
  void set_z(float value);

  private:
  float _internal_z() const;
  void _internal_set_z(float value);

  public:
  // @@protoc_insertion_point(class_scope:rtech.liveapi.Vector3)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    float x_;
    float y_;
    float z_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_events_2eproto;
};// -------------------------------------------------------------------

class RequestStatus final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rtech.liveapi.RequestStatus) */ {
 public:
  inline RequestStatus() : RequestStatus(nullptr) {}
  ~RequestStatus() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RequestStatus(::google::protobuf::internal::ConstantInitialized);

  inline RequestStatus(const RequestStatus& from)
      : RequestStatus(nullptr, from) {}
  RequestStatus(RequestStatus&& from) noexcept
    : RequestStatus() {
    *this = ::std::move(from);
  }

  inline RequestStatus& operator=(const RequestStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline RequestStatus& operator=(RequestStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RequestStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const RequestStatus* internal_default_instance() {
    return reinterpret_cast<const RequestStatus*>(
               &_RequestStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    60;

  friend void swap(RequestStatus& a, RequestStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(RequestStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RequestStatus* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RequestStatus* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RequestStatus>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RequestStatus& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const RequestStatus& from) {
    RequestStatus::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RequestStatus* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "rtech.liveapi.RequestStatus";
  }
  protected:
  explicit RequestStatus(::google::protobuf::Arena* arena);
  RequestStatus(::google::protobuf::Arena* arena, const RequestStatus& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 1,
  };
  // string status = 1;
  void clear_status() ;
  const std::string& status() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_status(Arg_&& arg, Args_... args);
  std::string* mutable_status();
  PROTOBUF_NODISCARD std::string* release_status();
  void set_allocated_status(std::string* value);

  private:
  const std::string& _internal_status() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_status(
      const std::string& value);
  std::string* _internal_mutable_status();

  public:
  // @@protoc_insertion_point(class_scope:rtech.liveapi.RequestStatus)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      42, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr status_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_events_2eproto;
};// -------------------------------------------------------------------

class PauseToggle final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rtech.liveapi.PauseToggle) */ {
 public:
  inline PauseToggle() : PauseToggle(nullptr) {}
  ~PauseToggle() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR PauseToggle(::google::protobuf::internal::ConstantInitialized);

  inline PauseToggle(const PauseToggle& from)
      : PauseToggle(nullptr, from) {}
  PauseToggle(PauseToggle&& from) noexcept
    : PauseToggle() {
    *this = ::std::move(from);
  }

  inline PauseToggle& operator=(const PauseToggle& from) {
    CopyFrom(from);
    return *this;
  }
  inline PauseToggle& operator=(PauseToggle&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PauseToggle& default_instance() {
    return *internal_default_instance();
  }
  static inline const PauseToggle* internal_default_instance() {
    return reinterpret_cast<const PauseToggle*>(
               &_PauseToggle_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    46;

  friend void swap(PauseToggle& a, PauseToggle& b) {
    a.Swap(&b);
  }
  inline void Swap(PauseToggle* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PauseToggle* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PauseToggle* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PauseToggle>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PauseToggle& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const PauseToggle& from) {
    PauseToggle::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(PauseToggle* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "rtech.liveapi.PauseToggle";
  }
  protected:
  explicit PauseToggle(::google::protobuf::Arena* arena);
  PauseToggle(::google::protobuf::Arena* arena, const PauseToggle& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPreTimerFieldNumber = 1,
  };
  // float preTimer = 1;
  void clear_pretimer() ;
  float pretimer() const;
  void set_pretimer(float value);

  private:
  float _internal_pretimer() const;
  void _internal_set_pretimer(float value);

  public:
  // @@protoc_insertion_point(class_scope:rtech.liveapi.PauseToggle)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    float pretimer_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_events_2eproto;
};// -------------------------------------------------------------------

class ObserverAnnotation final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rtech.liveapi.ObserverAnnotation) */ {
 public:
  inline ObserverAnnotation() : ObserverAnnotation(nullptr) {}
  ~ObserverAnnotation() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ObserverAnnotation(::google::protobuf::internal::ConstantInitialized);

  inline ObserverAnnotation(const ObserverAnnotation& from)
      : ObserverAnnotation(nullptr, from) {}
  ObserverAnnotation(ObserverAnnotation&& from) noexcept
    : ObserverAnnotation() {
    *this = ::std::move(from);
  }

  inline ObserverAnnotation& operator=(const ObserverAnnotation& from) {
    CopyFrom(from);
    return *this;
  }
  inline ObserverAnnotation& operator=(ObserverAnnotation&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ObserverAnnotation& default_instance() {
    return *internal_default_instance();
  }
  static inline const ObserverAnnotation* internal_default_instance() {
    return reinterpret_cast<const ObserverAnnotation*>(
               &_ObserverAnnotation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(ObserverAnnotation& a, ObserverAnnotation& b) {
    a.Swap(&b);
  }
  inline void Swap(ObserverAnnotation* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ObserverAnnotation* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ObserverAnnotation* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ObserverAnnotation>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ObserverAnnotation& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ObserverAnnotation& from) {
    ObserverAnnotation::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ObserverAnnotation* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "rtech.liveapi.ObserverAnnotation";
  }
  protected:
  explicit ObserverAnnotation(::google::protobuf::Arena* arena);
  ObserverAnnotation(::google::protobuf::Arena* arena, const ObserverAnnotation& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCategoryFieldNumber = 2,
    kTimestampFieldNumber = 1,
    kAnnotationSerialFieldNumber = 3,
  };
  // string category = 2;
  void clear_category() ;
  const std::string& category() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_category(Arg_&& arg, Args_... args);
  std::string* mutable_category();
  PROTOBUF_NODISCARD std::string* release_category();
  void set_allocated_category(std::string* value);

  private:
  const std::string& _internal_category() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_category(
      const std::string& value);
  std::string* _internal_mutable_category();

  public:
  // uint64 timestamp = 1;
  void clear_timestamp() ;
  ::uint64_t timestamp() const;
  void set_timestamp(::uint64_t value);

  private:
  ::uint64_t _internal_timestamp() const;
  void _internal_set_timestamp(::uint64_t value);

  public:
  // int32 annotationSerial = 3;
  void clear_annotationserial() ;
  ::int32_t annotationserial() const;
  void set_annotationserial(::int32_t value);

  private:
  ::int32_t _internal_annotationserial() const;
  void _internal_set_annotationserial(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:rtech.liveapi.ObserverAnnotation)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      49, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr category_;
    ::uint64_t timestamp_;
    ::int32_t annotationserial_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_events_2eproto;
};// -------------------------------------------------------------------

class InventoryItem final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rtech.liveapi.InventoryItem) */ {
 public:
  inline InventoryItem() : InventoryItem(nullptr) {}
  ~InventoryItem() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR InventoryItem(::google::protobuf::internal::ConstantInitialized);

  inline InventoryItem(const InventoryItem& from)
      : InventoryItem(nullptr, from) {}
  InventoryItem(InventoryItem&& from) noexcept
    : InventoryItem() {
    *this = ::std::move(from);
  }

  inline InventoryItem& operator=(const InventoryItem& from) {
    CopyFrom(from);
    return *this;
  }
  inline InventoryItem& operator=(InventoryItem&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InventoryItem& default_instance() {
    return *internal_default_instance();
  }
  static inline const InventoryItem* internal_default_instance() {
    return reinterpret_cast<const InventoryItem*>(
               &_InventoryItem_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(InventoryItem& a, InventoryItem& b) {
    a.Swap(&b);
  }
  inline void Swap(InventoryItem* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InventoryItem* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InventoryItem* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InventoryItem>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const InventoryItem& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const InventoryItem& from) {
    InventoryItem::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(InventoryItem* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "rtech.liveapi.InventoryItem";
  }
  protected:
  explicit InventoryItem(::google::protobuf::Arena* arena);
  InventoryItem(::google::protobuf::Arena* arena, const InventoryItem& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemFieldNumber = 2,
    kExtraDataFieldNumber = 3,
    kQuantityFieldNumber = 1,
  };
  // string item = 2;
  void clear_item() ;
  const std::string& item() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_item(Arg_&& arg, Args_... args);
  std::string* mutable_item();
  PROTOBUF_NODISCARD std::string* release_item();
  void set_allocated_item(std::string* value);

  private:
  const std::string& _internal_item() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_item(
      const std::string& value);
  std::string* _internal_mutable_item();

  public:
  // string extraData = 3;
  void clear_extradata() ;
  const std::string& extradata() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_extradata(Arg_&& arg, Args_... args);
  std::string* mutable_extradata();
  PROTOBUF_NODISCARD std::string* release_extradata();
  void set_allocated_extradata(std::string* value);

  private:
  const std::string& _internal_extradata() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_extradata(
      const std::string& value);
  std::string* _internal_mutable_extradata();

  public:
  // int32 quantity = 1;
  void clear_quantity() ;
  ::int32_t quantity() const;
  void set_quantity(::int32_t value);

  private:
  ::int32_t _internal_quantity() const;
  void _internal_set_quantity(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:rtech.liveapi.InventoryItem)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      49, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr item_;
    ::google::protobuf::internal::ArenaStringPtr extradata_;
    ::int32_t quantity_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_events_2eproto;
};// -------------------------------------------------------------------

class GameStateChanged final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rtech.liveapi.GameStateChanged) */ {
 public:
  inline GameStateChanged() : GameStateChanged(nullptr) {}
  ~GameStateChanged() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GameStateChanged(::google::protobuf::internal::ConstantInitialized);

  inline GameStateChanged(const GameStateChanged& from)
      : GameStateChanged(nullptr, from) {}
  GameStateChanged(GameStateChanged&& from) noexcept
    : GameStateChanged() {
    *this = ::std::move(from);
  }

  inline GameStateChanged& operator=(const GameStateChanged& from) {
    CopyFrom(from);
    return *this;
  }
  inline GameStateChanged& operator=(GameStateChanged&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GameStateChanged& default_instance() {
    return *internal_default_instance();
  }
  static inline const GameStateChanged* internal_default_instance() {
    return reinterpret_cast<const GameStateChanged*>(
               &_GameStateChanged_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(GameStateChanged& a, GameStateChanged& b) {
    a.Swap(&b);
  }
  inline void Swap(GameStateChanged* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GameStateChanged* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GameStateChanged* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GameStateChanged>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GameStateChanged& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const GameStateChanged& from) {
    GameStateChanged::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GameStateChanged* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "rtech.liveapi.GameStateChanged";
  }
  protected:
  explicit GameStateChanged(::google::protobuf::Arena* arena);
  GameStateChanged(::google::protobuf::Arena* arena, const GameStateChanged& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCategoryFieldNumber = 2,
    kStateFieldNumber = 3,
    kTimestampFieldNumber = 1,
  };
  // string category = 2;
  void clear_category() ;
  const std::string& category() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_category(Arg_&& arg, Args_... args);
  std::string* mutable_category();
  PROTOBUF_NODISCARD std::string* release_category();
  void set_allocated_category(std::string* value);

  private:
  const std::string& _internal_category() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_category(
      const std::string& value);
  std::string* _internal_mutable_category();

  public:
  // string state = 3;
  void clear_state() ;
  const std::string& state() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_state(Arg_&& arg, Args_... args);
  std::string* mutable_state();
  PROTOBUF_NODISCARD std::string* release_state();
  void set_allocated_state(std::string* value);

  private:
  const std::string& _internal_state() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_state(
      const std::string& value);
  std::string* _internal_mutable_state();

  public:
  // uint64 timestamp = 1;
  void clear_timestamp() ;
  ::uint64_t timestamp() const;
  void set_timestamp(::uint64_t value);

  private:
  ::uint64_t _internal_timestamp() const;
  void _internal_set_timestamp(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:rtech.liveapi.GameStateChanged)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      52, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr category_;
    ::google::protobuf::internal::ArenaStringPtr state_;
    ::uint64_t timestamp_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_events_2eproto;
};// -------------------------------------------------------------------

class Datacenter final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rtech.liveapi.Datacenter) */ {
 public:
  inline Datacenter() : Datacenter(nullptr) {}
  ~Datacenter() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Datacenter(::google::protobuf::internal::ConstantInitialized);

  inline Datacenter(const Datacenter& from)
      : Datacenter(nullptr, from) {}
  Datacenter(Datacenter&& from) noexcept
    : Datacenter() {
    *this = ::std::move(from);
  }

  inline Datacenter& operator=(const Datacenter& from) {
    CopyFrom(from);
    return *this;
  }
  inline Datacenter& operator=(Datacenter&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Datacenter& default_instance() {
    return *internal_default_instance();
  }
  static inline const Datacenter* internal_default_instance() {
    return reinterpret_cast<const Datacenter*>(
               &_Datacenter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Datacenter& a, Datacenter& b) {
    a.Swap(&b);
  }
  inline void Swap(Datacenter* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Datacenter* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Datacenter* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Datacenter>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Datacenter& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Datacenter& from) {
    Datacenter::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Datacenter* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "rtech.liveapi.Datacenter";
  }
  protected:
  explicit Datacenter(::google::protobuf::Arena* arena);
  Datacenter(::google::protobuf::Arena* arena, const Datacenter& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCategoryFieldNumber = 2,
    kNameFieldNumber = 3,
    kTimestampFieldNumber = 1,
  };
  // string category = 2;
  void clear_category() ;
  const std::string& category() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_category(Arg_&& arg, Args_... args);
  std::string* mutable_category();
  PROTOBUF_NODISCARD std::string* release_category();
  void set_allocated_category(std::string* value);

  private:
  const std::string& _internal_category() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_category(
      const std::string& value);
  std::string* _internal_mutable_category();

  public:
  // string name = 3;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // uint64 timestamp = 1;
  void clear_timestamp() ;
  ::uint64_t timestamp() const;
  void set_timestamp(::uint64_t value);

  private:
  ::uint64_t _internal_timestamp() const;
  void _internal_set_timestamp(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:rtech.liveapi.Datacenter)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      45, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr category_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::uint64_t timestamp_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_events_2eproto;
};// -------------------------------------------------------------------

class CustomMatch_SetTeamName final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rtech.liveapi.CustomMatch_SetTeamName) */ {
 public:
  inline CustomMatch_SetTeamName() : CustomMatch_SetTeamName(nullptr) {}
  ~CustomMatch_SetTeamName() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CustomMatch_SetTeamName(::google::protobuf::internal::ConstantInitialized);

  inline CustomMatch_SetTeamName(const CustomMatch_SetTeamName& from)
      : CustomMatch_SetTeamName(nullptr, from) {}
  CustomMatch_SetTeamName(CustomMatch_SetTeamName&& from) noexcept
    : CustomMatch_SetTeamName() {
    *this = ::std::move(from);
  }

  inline CustomMatch_SetTeamName& operator=(const CustomMatch_SetTeamName& from) {
    CopyFrom(from);
    return *this;
  }
  inline CustomMatch_SetTeamName& operator=(CustomMatch_SetTeamName&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CustomMatch_SetTeamName& default_instance() {
    return *internal_default_instance();
  }
  static inline const CustomMatch_SetTeamName* internal_default_instance() {
    return reinterpret_cast<const CustomMatch_SetTeamName*>(
               &_CustomMatch_SetTeamName_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    57;

  friend void swap(CustomMatch_SetTeamName& a, CustomMatch_SetTeamName& b) {
    a.Swap(&b);
  }
  inline void Swap(CustomMatch_SetTeamName* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CustomMatch_SetTeamName* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CustomMatch_SetTeamName* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CustomMatch_SetTeamName>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CustomMatch_SetTeamName& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const CustomMatch_SetTeamName& from) {
    CustomMatch_SetTeamName::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CustomMatch_SetTeamName* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "rtech.liveapi.CustomMatch_SetTeamName";
  }
  protected:
  explicit CustomMatch_SetTeamName(::google::protobuf::Arena* arena);
  CustomMatch_SetTeamName(::google::protobuf::Arena* arena, const CustomMatch_SetTeamName& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTeamNameFieldNumber = 2,
    kTeamIdFieldNumber = 1,
  };
  // string teamName = 2;
  void clear_teamname() ;
  const std::string& teamname() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_teamname(Arg_&& arg, Args_... args);
  std::string* mutable_teamname();
  PROTOBUF_NODISCARD std::string* release_teamname();
  void set_allocated_teamname(std::string* value);

  private:
  const std::string& _internal_teamname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_teamname(
      const std::string& value);
  std::string* _internal_mutable_teamname();

  public:
  // int32 teamId = 1;
  void clear_teamid() ;
  ::int32_t teamid() const;
  void set_teamid(::int32_t value);

  private:
  ::int32_t _internal_teamid() const;
  void _internal_set_teamid(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:rtech.liveapi.CustomMatch_SetTeamName)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      54, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr teamname_;
    ::int32_t teamid_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_events_2eproto;
};// -------------------------------------------------------------------

class CustomMatch_SetTeam final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rtech.liveapi.CustomMatch_SetTeam) */ {
 public:
  inline CustomMatch_SetTeam() : CustomMatch_SetTeam(nullptr) {}
  ~CustomMatch_SetTeam() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CustomMatch_SetTeam(::google::protobuf::internal::ConstantInitialized);

  inline CustomMatch_SetTeam(const CustomMatch_SetTeam& from)
      : CustomMatch_SetTeam(nullptr, from) {}
  CustomMatch_SetTeam(CustomMatch_SetTeam&& from) noexcept
    : CustomMatch_SetTeam() {
    *this = ::std::move(from);
  }

  inline CustomMatch_SetTeam& operator=(const CustomMatch_SetTeam& from) {
    CopyFrom(from);
    return *this;
  }
  inline CustomMatch_SetTeam& operator=(CustomMatch_SetTeam&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CustomMatch_SetTeam& default_instance() {
    return *internal_default_instance();
  }
  static inline const CustomMatch_SetTeam* internal_default_instance() {
    return reinterpret_cast<const CustomMatch_SetTeam*>(
               &_CustomMatch_SetTeam_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    53;

  friend void swap(CustomMatch_SetTeam& a, CustomMatch_SetTeam& b) {
    a.Swap(&b);
  }
  inline void Swap(CustomMatch_SetTeam* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CustomMatch_SetTeam* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CustomMatch_SetTeam* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CustomMatch_SetTeam>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CustomMatch_SetTeam& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const CustomMatch_SetTeam& from) {
    CustomMatch_SetTeam::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CustomMatch_SetTeam* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "rtech.liveapi.CustomMatch_SetTeam";
  }
  protected:
  explicit CustomMatch_SetTeam(::google::protobuf::Arena* arena);
  CustomMatch_SetTeam(::google::protobuf::Arena* arena, const CustomMatch_SetTeam& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTargetHardwareNameFieldNumber = 2,
    kTargetNucleusHashFieldNumber = 3,
    kTeamIdFieldNumber = 1,
  };
  // string targetHardwareName = 2;
  void clear_targethardwarename() ;
  const std::string& targethardwarename() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_targethardwarename(Arg_&& arg, Args_... args);
  std::string* mutable_targethardwarename();
  PROTOBUF_NODISCARD std::string* release_targethardwarename();
  void set_allocated_targethardwarename(std::string* value);

  private:
  const std::string& _internal_targethardwarename() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_targethardwarename(
      const std::string& value);
  std::string* _internal_mutable_targethardwarename();

  public:
  // string targetNucleusHash = 3;
  void clear_targetnucleushash() ;
  const std::string& targetnucleushash() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_targetnucleushash(Arg_&& arg, Args_... args);
  std::string* mutable_targetnucleushash();
  PROTOBUF_NODISCARD std::string* release_targetnucleushash();
  void set_allocated_targetnucleushash(std::string* value);

  private:
  const std::string& _internal_targetnucleushash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_targetnucleushash(
      const std::string& value);
  std::string* _internal_mutable_targetnucleushash();

  public:
  // int32 teamId = 1;
  void clear_teamid() ;
  ::int32_t teamid() const;
  void set_teamid(::int32_t value);

  private:
  ::int32_t _internal_teamid() const;
  void _internal_set_teamid(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:rtech.liveapi.CustomMatch_SetTeam)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      77, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr targethardwarename_;
    ::google::protobuf::internal::ArenaStringPtr targetnucleushash_;
    ::int32_t teamid_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_events_2eproto;
};// -------------------------------------------------------------------

class CustomMatch_SetSettings final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rtech.liveapi.CustomMatch_SetSettings) */ {
 public:
  inline CustomMatch_SetSettings() : CustomMatch_SetSettings(nullptr) {}
  ~CustomMatch_SetSettings() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CustomMatch_SetSettings(::google::protobuf::internal::ConstantInitialized);

  inline CustomMatch_SetSettings(const CustomMatch_SetSettings& from)
      : CustomMatch_SetSettings(nullptr, from) {}
  CustomMatch_SetSettings(CustomMatch_SetSettings&& from) noexcept
    : CustomMatch_SetSettings() {
    *this = ::std::move(from);
  }

  inline CustomMatch_SetSettings& operator=(const CustomMatch_SetSettings& from) {
    CopyFrom(from);
    return *this;
  }
  inline CustomMatch_SetSettings& operator=(CustomMatch_SetSettings&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CustomMatch_SetSettings& default_instance() {
    return *internal_default_instance();
  }
  static inline const CustomMatch_SetSettings* internal_default_instance() {
    return reinterpret_cast<const CustomMatch_SetSettings*>(
               &_CustomMatch_SetSettings_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    55;

  friend void swap(CustomMatch_SetSettings& a, CustomMatch_SetSettings& b) {
    a.Swap(&b);
  }
  inline void Swap(CustomMatch_SetSettings* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CustomMatch_SetSettings* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CustomMatch_SetSettings* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CustomMatch_SetSettings>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CustomMatch_SetSettings& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const CustomMatch_SetSettings& from) {
    CustomMatch_SetSettings::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CustomMatch_SetSettings* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "rtech.liveapi.CustomMatch_SetSettings";
  }
  protected:
  explicit CustomMatch_SetSettings(::google::protobuf::Arena* arena);
  CustomMatch_SetSettings(::google::protobuf::Arena* arena, const CustomMatch_SetSettings& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlaylistNameFieldNumber = 1,
    kAdminChatFieldNumber = 2,
    kTeamRenameFieldNumber = 3,
    kSelfAssignFieldNumber = 4,
    kAimAssistFieldNumber = 5,
    kAnonModeFieldNumber = 6,
  };
  // string playlistName = 1;
  void clear_playlistname() ;
  const std::string& playlistname() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_playlistname(Arg_&& arg, Args_... args);
  std::string* mutable_playlistname();
  PROTOBUF_NODISCARD std::string* release_playlistname();
  void set_allocated_playlistname(std::string* value);

  private:
  const std::string& _internal_playlistname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_playlistname(
      const std::string& value);
  std::string* _internal_mutable_playlistname();

  public:
  // bool adminChat = 2;
  void clear_adminchat() ;
  bool adminchat() const;
  void set_adminchat(bool value);

  private:
  bool _internal_adminchat() const;
  void _internal_set_adminchat(bool value);

  public:
  // bool teamRename = 3;
  void clear_teamrename() ;
  bool teamrename() const;
  void set_teamrename(bool value);

  private:
  bool _internal_teamrename() const;
  void _internal_set_teamrename(bool value);

  public:
  // bool selfAssign = 4;
  void clear_selfassign() ;
  bool selfassign() const;
  void set_selfassign(bool value);

  private:
  bool _internal_selfassign() const;
  void _internal_set_selfassign(bool value);

  public:
  // bool aimAssist = 5;
  void clear_aimassist() ;
  bool aimassist() const;
  void set_aimassist(bool value);

  private:
  bool _internal_aimassist() const;
  void _internal_set_aimassist(bool value);

  public:
  // bool anonMode = 6;
  void clear_anonmode() ;
  bool anonmode() const;
  void set_anonmode(bool value);

  private:
  bool _internal_anonmode() const;
  void _internal_set_anonmode(bool value);

  public:
  // @@protoc_insertion_point(class_scope:rtech.liveapi.CustomMatch_SetSettings)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 6, 0,
      58, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr playlistname_;
    bool adminchat_;
    bool teamrename_;
    bool selfassign_;
    bool aimassist_;
    bool anonmode_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_events_2eproto;
};// -------------------------------------------------------------------

class CustomMatch_SetReady final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rtech.liveapi.CustomMatch_SetReady) */ {
 public:
  inline CustomMatch_SetReady() : CustomMatch_SetReady(nullptr) {}
  ~CustomMatch_SetReady() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CustomMatch_SetReady(::google::protobuf::internal::ConstantInitialized);

  inline CustomMatch_SetReady(const CustomMatch_SetReady& from)
      : CustomMatch_SetReady(nullptr, from) {}
  CustomMatch_SetReady(CustomMatch_SetReady&& from) noexcept
    : CustomMatch_SetReady() {
    *this = ::std::move(from);
  }

  inline CustomMatch_SetReady& operator=(const CustomMatch_SetReady& from) {
    CopyFrom(from);
    return *this;
  }
  inline CustomMatch_SetReady& operator=(CustomMatch_SetReady&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CustomMatch_SetReady& default_instance() {
    return *internal_default_instance();
  }
  static inline const CustomMatch_SetReady* internal_default_instance() {
    return reinterpret_cast<const CustomMatch_SetReady*>(
               &_CustomMatch_SetReady_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    50;

  friend void swap(CustomMatch_SetReady& a, CustomMatch_SetReady& b) {
    a.Swap(&b);
  }
  inline void Swap(CustomMatch_SetReady* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CustomMatch_SetReady* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CustomMatch_SetReady* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CustomMatch_SetReady>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CustomMatch_SetReady& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const CustomMatch_SetReady& from) {
    CustomMatch_SetReady::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CustomMatch_SetReady* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "rtech.liveapi.CustomMatch_SetReady";
  }
  protected:
  explicit CustomMatch_SetReady(::google::protobuf::Arena* arena);
  CustomMatch_SetReady(::google::protobuf::Arena* arena, const CustomMatch_SetReady& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIsReadyFieldNumber = 1,
  };
  // bool isReady = 1;
  void clear_isready() ;
  bool isready() const;
  void set_isready(bool value);

  private:
  bool _internal_isready() const;
  void _internal_set_isready(bool value);

  public:
  // @@protoc_insertion_point(class_scope:rtech.liveapi.CustomMatch_SetReady)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    bool isready_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_events_2eproto;
};// -------------------------------------------------------------------

class CustomMatch_SetMatchmaking final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rtech.liveapi.CustomMatch_SetMatchmaking) */ {
 public:
  inline CustomMatch_SetMatchmaking() : CustomMatch_SetMatchmaking(nullptr) {}
  ~CustomMatch_SetMatchmaking() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CustomMatch_SetMatchmaking(::google::protobuf::internal::ConstantInitialized);

  inline CustomMatch_SetMatchmaking(const CustomMatch_SetMatchmaking& from)
      : CustomMatch_SetMatchmaking(nullptr, from) {}
  CustomMatch_SetMatchmaking(CustomMatch_SetMatchmaking&& from) noexcept
    : CustomMatch_SetMatchmaking() {
    *this = ::std::move(from);
  }

  inline CustomMatch_SetMatchmaking& operator=(const CustomMatch_SetMatchmaking& from) {
    CopyFrom(from);
    return *this;
  }
  inline CustomMatch_SetMatchmaking& operator=(CustomMatch_SetMatchmaking&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CustomMatch_SetMatchmaking& default_instance() {
    return *internal_default_instance();
  }
  static inline const CustomMatch_SetMatchmaking* internal_default_instance() {
    return reinterpret_cast<const CustomMatch_SetMatchmaking*>(
               &_CustomMatch_SetMatchmaking_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    52;

  friend void swap(CustomMatch_SetMatchmaking& a, CustomMatch_SetMatchmaking& b) {
    a.Swap(&b);
  }
  inline void Swap(CustomMatch_SetMatchmaking* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CustomMatch_SetMatchmaking* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CustomMatch_SetMatchmaking* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CustomMatch_SetMatchmaking>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CustomMatch_SetMatchmaking& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const CustomMatch_SetMatchmaking& from) {
    CustomMatch_SetMatchmaking::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CustomMatch_SetMatchmaking* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "rtech.liveapi.CustomMatch_SetMatchmaking";
  }
  protected:
  explicit CustomMatch_SetMatchmaking(::google::protobuf::Arena* arena);
  CustomMatch_SetMatchmaking(::google::protobuf::Arena* arena, const CustomMatch_SetMatchmaking& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnabledFieldNumber = 1,
  };
  // bool enabled = 1;
  void clear_enabled() ;
  bool enabled() const;
  void set_enabled(bool value);

  private:
  bool _internal_enabled() const;
  void _internal_set_enabled(bool value);

  public:
  // @@protoc_insertion_point(class_scope:rtech.liveapi.CustomMatch_SetMatchmaking)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    bool enabled_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_events_2eproto;
};// -------------------------------------------------------------------

class CustomMatch_SendChat final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rtech.liveapi.CustomMatch_SendChat) */ {
 public:
  inline CustomMatch_SendChat() : CustomMatch_SendChat(nullptr) {}
  ~CustomMatch_SendChat() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CustomMatch_SendChat(::google::protobuf::internal::ConstantInitialized);

  inline CustomMatch_SendChat(const CustomMatch_SendChat& from)
      : CustomMatch_SendChat(nullptr, from) {}
  CustomMatch_SendChat(CustomMatch_SendChat&& from) noexcept
    : CustomMatch_SendChat() {
    *this = ::std::move(from);
  }

  inline CustomMatch_SendChat& operator=(const CustomMatch_SendChat& from) {
    CopyFrom(from);
    return *this;
  }
  inline CustomMatch_SendChat& operator=(CustomMatch_SendChat&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CustomMatch_SendChat& default_instance() {
    return *internal_default_instance();
  }
  static inline const CustomMatch_SendChat* internal_default_instance() {
    return reinterpret_cast<const CustomMatch_SendChat*>(
               &_CustomMatch_SendChat_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    58;

  friend void swap(CustomMatch_SendChat& a, CustomMatch_SendChat& b) {
    a.Swap(&b);
  }
  inline void Swap(CustomMatch_SendChat* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CustomMatch_SendChat* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CustomMatch_SendChat* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CustomMatch_SendChat>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CustomMatch_SendChat& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const CustomMatch_SendChat& from) {
    CustomMatch_SendChat::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CustomMatch_SendChat* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "rtech.liveapi.CustomMatch_SendChat";
  }
  protected:
  explicit CustomMatch_SendChat(::google::protobuf::Arena* arena);
  CustomMatch_SendChat(::google::protobuf::Arena* arena, const CustomMatch_SendChat& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTextFieldNumber = 1,
  };
  // string text = 1;
  void clear_text() ;
  const std::string& text() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_text(Arg_&& arg, Args_... args);
  std::string* mutable_text();
  PROTOBUF_NODISCARD std::string* release_text();
  void set_allocated_text(std::string* value);

  private:
  const std::string& _internal_text() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_text(
      const std::string& value);
  std::string* _internal_mutable_text();

  public:
  // @@protoc_insertion_point(class_scope:rtech.liveapi.CustomMatch_SendChat)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      47, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr text_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_events_2eproto;
};// -------------------------------------------------------------------

class CustomMatch_LobbyPlayer final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rtech.liveapi.CustomMatch_LobbyPlayer) */ {
 public:
  inline CustomMatch_LobbyPlayer() : CustomMatch_LobbyPlayer(nullptr) {}
  ~CustomMatch_LobbyPlayer() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CustomMatch_LobbyPlayer(::google::protobuf::internal::ConstantInitialized);

  inline CustomMatch_LobbyPlayer(const CustomMatch_LobbyPlayer& from)
      : CustomMatch_LobbyPlayer(nullptr, from) {}
  CustomMatch_LobbyPlayer(CustomMatch_LobbyPlayer&& from) noexcept
    : CustomMatch_LobbyPlayer() {
    *this = ::std::move(from);
  }

  inline CustomMatch_LobbyPlayer& operator=(const CustomMatch_LobbyPlayer& from) {
    CopyFrom(from);
    return *this;
  }
  inline CustomMatch_LobbyPlayer& operator=(CustomMatch_LobbyPlayer&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CustomMatch_LobbyPlayer& default_instance() {
    return *internal_default_instance();
  }
  static inline const CustomMatch_LobbyPlayer* internal_default_instance() {
    return reinterpret_cast<const CustomMatch_LobbyPlayer*>(
               &_CustomMatch_LobbyPlayer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(CustomMatch_LobbyPlayer& a, CustomMatch_LobbyPlayer& b) {
    a.Swap(&b);
  }
  inline void Swap(CustomMatch_LobbyPlayer* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CustomMatch_LobbyPlayer* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CustomMatch_LobbyPlayer* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CustomMatch_LobbyPlayer>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CustomMatch_LobbyPlayer& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const CustomMatch_LobbyPlayer& from) {
    CustomMatch_LobbyPlayer::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CustomMatch_LobbyPlayer* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "rtech.liveapi.CustomMatch_LobbyPlayer";
  }
  protected:
  explicit CustomMatch_LobbyPlayer(::google::protobuf::Arena* arena);
  CustomMatch_LobbyPlayer(::google::protobuf::Arena* arena, const CustomMatch_LobbyPlayer& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kNucleusHashFieldNumber = 3,
    kHardwareNameFieldNumber = 4,
    kTeamIdFieldNumber = 2,
  };
  // string name = 1;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // string nucleusHash = 3;
  void clear_nucleushash() ;
  const std::string& nucleushash() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_nucleushash(Arg_&& arg, Args_... args);
  std::string* mutable_nucleushash();
  PROTOBUF_NODISCARD std::string* release_nucleushash();
  void set_allocated_nucleushash(std::string* value);

  private:
  const std::string& _internal_nucleushash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_nucleushash(
      const std::string& value);
  std::string* _internal_mutable_nucleushash();

  public:
  // string hardwareName = 4;
  void clear_hardwarename() ;
  const std::string& hardwarename() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_hardwarename(Arg_&& arg, Args_... args);
  std::string* mutable_hardwarename();
  PROTOBUF_NODISCARD std::string* release_hardwarename();
  void set_allocated_hardwarename(std::string* value);

  private:
  const std::string& _internal_hardwarename() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hardwarename(
      const std::string& value);
  std::string* _internal_mutable_hardwarename();

  public:
  // uint32 teamId = 2;
  void clear_teamid() ;
  ::uint32_t teamid() const;
  void set_teamid(::uint32_t value);

  private:
  ::uint32_t _internal_teamid() const;
  void _internal_set_teamid(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:rtech.liveapi.CustomMatch_LobbyPlayer)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 0,
      73, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::google::protobuf::internal::ArenaStringPtr nucleushash_;
    ::google::protobuf::internal::ArenaStringPtr hardwarename_;
    ::uint32_t teamid_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_events_2eproto;
};// -------------------------------------------------------------------

class CustomMatch_LeaveLobby final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:rtech.liveapi.CustomMatch_LeaveLobby) */ {
 public:
  inline CustomMatch_LeaveLobby() : CustomMatch_LeaveLobby(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CustomMatch_LeaveLobby(::google::protobuf::internal::ConstantInitialized);

  inline CustomMatch_LeaveLobby(const CustomMatch_LeaveLobby& from)
      : CustomMatch_LeaveLobby(nullptr, from) {}
  CustomMatch_LeaveLobby(CustomMatch_LeaveLobby&& from) noexcept
    : CustomMatch_LeaveLobby() {
    *this = ::std::move(from);
  }

  inline CustomMatch_LeaveLobby& operator=(const CustomMatch_LeaveLobby& from) {
    CopyFrom(from);
    return *this;
  }
  inline CustomMatch_LeaveLobby& operator=(CustomMatch_LeaveLobby&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CustomMatch_LeaveLobby& default_instance() {
    return *internal_default_instance();
  }
  static inline const CustomMatch_LeaveLobby* internal_default_instance() {
    return reinterpret_cast<const CustomMatch_LeaveLobby*>(
               &_CustomMatch_LeaveLobby_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    49;

  friend void swap(CustomMatch_LeaveLobby& a, CustomMatch_LeaveLobby& b) {
    a.Swap(&b);
  }
  inline void Swap(CustomMatch_LeaveLobby* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CustomMatch_LeaveLobby* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CustomMatch_LeaveLobby* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CustomMatch_LeaveLobby>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const CustomMatch_LeaveLobby& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const CustomMatch_LeaveLobby& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "rtech.liveapi.CustomMatch_LeaveLobby";
  }
  protected:
  explicit CustomMatch_LeaveLobby(::google::protobuf::Arena* arena);
  CustomMatch_LeaveLobby(::google::protobuf::Arena* arena, const CustomMatch_LeaveLobby& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:rtech.liveapi.CustomMatch_LeaveLobby)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_events_2eproto;
};// -------------------------------------------------------------------

class CustomMatch_KickPlayer final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rtech.liveapi.CustomMatch_KickPlayer) */ {
 public:
  inline CustomMatch_KickPlayer() : CustomMatch_KickPlayer(nullptr) {}
  ~CustomMatch_KickPlayer() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CustomMatch_KickPlayer(::google::protobuf::internal::ConstantInitialized);

  inline CustomMatch_KickPlayer(const CustomMatch_KickPlayer& from)
      : CustomMatch_KickPlayer(nullptr, from) {}
  CustomMatch_KickPlayer(CustomMatch_KickPlayer&& from) noexcept
    : CustomMatch_KickPlayer() {
    *this = ::std::move(from);
  }

  inline CustomMatch_KickPlayer& operator=(const CustomMatch_KickPlayer& from) {
    CopyFrom(from);
    return *this;
  }
  inline CustomMatch_KickPlayer& operator=(CustomMatch_KickPlayer&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CustomMatch_KickPlayer& default_instance() {
    return *internal_default_instance();
  }
  static inline const CustomMatch_KickPlayer* internal_default_instance() {
    return reinterpret_cast<const CustomMatch_KickPlayer*>(
               &_CustomMatch_KickPlayer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    54;

  friend void swap(CustomMatch_KickPlayer& a, CustomMatch_KickPlayer& b) {
    a.Swap(&b);
  }
  inline void Swap(CustomMatch_KickPlayer* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CustomMatch_KickPlayer* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CustomMatch_KickPlayer* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CustomMatch_KickPlayer>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CustomMatch_KickPlayer& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const CustomMatch_KickPlayer& from) {
    CustomMatch_KickPlayer::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CustomMatch_KickPlayer* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "rtech.liveapi.CustomMatch_KickPlayer";
  }
  protected:
  explicit CustomMatch_KickPlayer(::google::protobuf::Arena* arena);
  CustomMatch_KickPlayer(::google::protobuf::Arena* arena, const CustomMatch_KickPlayer& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTargetHardwareNameFieldNumber = 1,
    kTargetNucleusHashFieldNumber = 2,
  };
  // string targetHardwareName = 1;
  void clear_targethardwarename() ;
  const std::string& targethardwarename() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_targethardwarename(Arg_&& arg, Args_... args);
  std::string* mutable_targethardwarename();
  PROTOBUF_NODISCARD std::string* release_targethardwarename();
  void set_allocated_targethardwarename(std::string* value);

  private:
  const std::string& _internal_targethardwarename() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_targethardwarename(
      const std::string& value);
  std::string* _internal_mutable_targethardwarename();

  public:
  // string targetNucleusHash = 2;
  void clear_targetnucleushash() ;
  const std::string& targetnucleushash() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_targetnucleushash(Arg_&& arg, Args_... args);
  std::string* mutable_targetnucleushash();
  PROTOBUF_NODISCARD std::string* release_targetnucleushash();
  void set_allocated_targetnucleushash(std::string* value);

  private:
  const std::string& _internal_targetnucleushash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_targetnucleushash(
      const std::string& value);
  std::string* _internal_mutable_targetnucleushash();

  public:
  // @@protoc_insertion_point(class_scope:rtech.liveapi.CustomMatch_KickPlayer)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      80, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr targethardwarename_;
    ::google::protobuf::internal::ArenaStringPtr targetnucleushash_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_events_2eproto;
};// -------------------------------------------------------------------

class CustomMatch_JoinLobby final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rtech.liveapi.CustomMatch_JoinLobby) */ {
 public:
  inline CustomMatch_JoinLobby() : CustomMatch_JoinLobby(nullptr) {}
  ~CustomMatch_JoinLobby() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CustomMatch_JoinLobby(::google::protobuf::internal::ConstantInitialized);

  inline CustomMatch_JoinLobby(const CustomMatch_JoinLobby& from)
      : CustomMatch_JoinLobby(nullptr, from) {}
  CustomMatch_JoinLobby(CustomMatch_JoinLobby&& from) noexcept
    : CustomMatch_JoinLobby() {
    *this = ::std::move(from);
  }

  inline CustomMatch_JoinLobby& operator=(const CustomMatch_JoinLobby& from) {
    CopyFrom(from);
    return *this;
  }
  inline CustomMatch_JoinLobby& operator=(CustomMatch_JoinLobby&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CustomMatch_JoinLobby& default_instance() {
    return *internal_default_instance();
  }
  static inline const CustomMatch_JoinLobby* internal_default_instance() {
    return reinterpret_cast<const CustomMatch_JoinLobby*>(
               &_CustomMatch_JoinLobby_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    48;

  friend void swap(CustomMatch_JoinLobby& a, CustomMatch_JoinLobby& b) {
    a.Swap(&b);
  }
  inline void Swap(CustomMatch_JoinLobby* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CustomMatch_JoinLobby* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CustomMatch_JoinLobby* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CustomMatch_JoinLobby>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CustomMatch_JoinLobby& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const CustomMatch_JoinLobby& from) {
    CustomMatch_JoinLobby::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CustomMatch_JoinLobby* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "rtech.liveapi.CustomMatch_JoinLobby";
  }
  protected:
  explicit CustomMatch_JoinLobby(::google::protobuf::Arena* arena);
  CustomMatch_JoinLobby(::google::protobuf::Arena* arena, const CustomMatch_JoinLobby& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRoleTokenFieldNumber = 1,
  };
  // string roleToken = 1;
  void clear_roletoken() ;
  const std::string& roletoken() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_roletoken(Arg_&& arg, Args_... args);
  std::string* mutable_roletoken();
  PROTOBUF_NODISCARD std::string* release_roletoken();
  void set_allocated_roletoken(std::string* value);

  private:
  const std::string& _internal_roletoken() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_roletoken(
      const std::string& value);
  std::string* _internal_mutable_roletoken();

  public:
  // @@protoc_insertion_point(class_scope:rtech.liveapi.CustomMatch_JoinLobby)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      53, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr roletoken_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_events_2eproto;
};// -------------------------------------------------------------------

class CustomMatch_GetSettings final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:rtech.liveapi.CustomMatch_GetSettings) */ {
 public:
  inline CustomMatch_GetSettings() : CustomMatch_GetSettings(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CustomMatch_GetSettings(::google::protobuf::internal::ConstantInitialized);

  inline CustomMatch_GetSettings(const CustomMatch_GetSettings& from)
      : CustomMatch_GetSettings(nullptr, from) {}
  CustomMatch_GetSettings(CustomMatch_GetSettings&& from) noexcept
    : CustomMatch_GetSettings() {
    *this = ::std::move(from);
  }

  inline CustomMatch_GetSettings& operator=(const CustomMatch_GetSettings& from) {
    CopyFrom(from);
    return *this;
  }
  inline CustomMatch_GetSettings& operator=(CustomMatch_GetSettings&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CustomMatch_GetSettings& default_instance() {
    return *internal_default_instance();
  }
  static inline const CustomMatch_GetSettings* internal_default_instance() {
    return reinterpret_cast<const CustomMatch_GetSettings*>(
               &_CustomMatch_GetSettings_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    56;

  friend void swap(CustomMatch_GetSettings& a, CustomMatch_GetSettings& b) {
    a.Swap(&b);
  }
  inline void Swap(CustomMatch_GetSettings* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CustomMatch_GetSettings* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CustomMatch_GetSettings* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CustomMatch_GetSettings>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const CustomMatch_GetSettings& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const CustomMatch_GetSettings& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "rtech.liveapi.CustomMatch_GetSettings";
  }
  protected:
  explicit CustomMatch_GetSettings(::google::protobuf::Arena* arena);
  CustomMatch_GetSettings(::google::protobuf::Arena* arena, const CustomMatch_GetSettings& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:rtech.liveapi.CustomMatch_GetSettings)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_events_2eproto;
};// -------------------------------------------------------------------

class CustomMatch_GetLobbyPlayers final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:rtech.liveapi.CustomMatch_GetLobbyPlayers) */ {
 public:
  inline CustomMatch_GetLobbyPlayers() : CustomMatch_GetLobbyPlayers(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CustomMatch_GetLobbyPlayers(::google::protobuf::internal::ConstantInitialized);

  inline CustomMatch_GetLobbyPlayers(const CustomMatch_GetLobbyPlayers& from)
      : CustomMatch_GetLobbyPlayers(nullptr, from) {}
  CustomMatch_GetLobbyPlayers(CustomMatch_GetLobbyPlayers&& from) noexcept
    : CustomMatch_GetLobbyPlayers() {
    *this = ::std::move(from);
  }

  inline CustomMatch_GetLobbyPlayers& operator=(const CustomMatch_GetLobbyPlayers& from) {
    CopyFrom(from);
    return *this;
  }
  inline CustomMatch_GetLobbyPlayers& operator=(CustomMatch_GetLobbyPlayers&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CustomMatch_GetLobbyPlayers& default_instance() {
    return *internal_default_instance();
  }
  static inline const CustomMatch_GetLobbyPlayers* internal_default_instance() {
    return reinterpret_cast<const CustomMatch_GetLobbyPlayers*>(
               &_CustomMatch_GetLobbyPlayers_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    51;

  friend void swap(CustomMatch_GetLobbyPlayers& a, CustomMatch_GetLobbyPlayers& b) {
    a.Swap(&b);
  }
  inline void Swap(CustomMatch_GetLobbyPlayers* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CustomMatch_GetLobbyPlayers* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CustomMatch_GetLobbyPlayers* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CustomMatch_GetLobbyPlayers>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const CustomMatch_GetLobbyPlayers& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const CustomMatch_GetLobbyPlayers& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "rtech.liveapi.CustomMatch_GetLobbyPlayers";
  }
  protected:
  explicit CustomMatch_GetLobbyPlayers(::google::protobuf::Arena* arena);
  CustomMatch_GetLobbyPlayers(::google::protobuf::Arena* arena, const CustomMatch_GetLobbyPlayers& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:rtech.liveapi.CustomMatch_GetLobbyPlayers)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_events_2eproto;
};// -------------------------------------------------------------------

class CustomMatch_CreateLobby final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:rtech.liveapi.CustomMatch_CreateLobby) */ {
 public:
  inline CustomMatch_CreateLobby() : CustomMatch_CreateLobby(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CustomMatch_CreateLobby(::google::protobuf::internal::ConstantInitialized);

  inline CustomMatch_CreateLobby(const CustomMatch_CreateLobby& from)
      : CustomMatch_CreateLobby(nullptr, from) {}
  CustomMatch_CreateLobby(CustomMatch_CreateLobby&& from) noexcept
    : CustomMatch_CreateLobby() {
    *this = ::std::move(from);
  }

  inline CustomMatch_CreateLobby& operator=(const CustomMatch_CreateLobby& from) {
    CopyFrom(from);
    return *this;
  }
  inline CustomMatch_CreateLobby& operator=(CustomMatch_CreateLobby&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CustomMatch_CreateLobby& default_instance() {
    return *internal_default_instance();
  }
  static inline const CustomMatch_CreateLobby* internal_default_instance() {
    return reinterpret_cast<const CustomMatch_CreateLobby*>(
               &_CustomMatch_CreateLobby_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    47;

  friend void swap(CustomMatch_CreateLobby& a, CustomMatch_CreateLobby& b) {
    a.Swap(&b);
  }
  inline void Swap(CustomMatch_CreateLobby* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CustomMatch_CreateLobby* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CustomMatch_CreateLobby* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CustomMatch_CreateLobby>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const CustomMatch_CreateLobby& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const CustomMatch_CreateLobby& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "rtech.liveapi.CustomMatch_CreateLobby";
  }
  protected:
  explicit CustomMatch_CreateLobby(::google::protobuf::Arena* arena);
  CustomMatch_CreateLobby(::google::protobuf::Arena* arena, const CustomMatch_CreateLobby& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:rtech.liveapi.CustomMatch_CreateLobby)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_events_2eproto;
};// -------------------------------------------------------------------

class ChangeCamera final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rtech.liveapi.ChangeCamera) */ {
 public:
  inline ChangeCamera() : ChangeCamera(nullptr) {}
  ~ChangeCamera() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ChangeCamera(::google::protobuf::internal::ConstantInitialized);

  inline ChangeCamera(const ChangeCamera& from)
      : ChangeCamera(nullptr, from) {}
  ChangeCamera(ChangeCamera&& from) noexcept
    : ChangeCamera() {
    *this = ::std::move(from);
  }

  inline ChangeCamera& operator=(const ChangeCamera& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChangeCamera& operator=(ChangeCamera&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChangeCamera& default_instance() {
    return *internal_default_instance();
  }
  enum TargetCase {
    kPoi = 1,
    kName = 2,
    TARGET_NOT_SET = 0,
  };

  static inline const ChangeCamera* internal_default_instance() {
    return reinterpret_cast<const ChangeCamera*>(
               &_ChangeCamera_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    45;

  friend void swap(ChangeCamera& a, ChangeCamera& b) {
    a.Swap(&b);
  }
  inline void Swap(ChangeCamera* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChangeCamera* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChangeCamera* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChangeCamera>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ChangeCamera& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ChangeCamera& from) {
    ChangeCamera::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ChangeCamera* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "rtech.liveapi.ChangeCamera";
  }
  protected:
  explicit ChangeCamera(::google::protobuf::Arena* arena);
  ChangeCamera(::google::protobuf::Arena* arena, const ChangeCamera& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPoiFieldNumber = 1,
    kNameFieldNumber = 2,
  };
  // .rtech.liveapi.PlayerOfInterest poi = 1;
  bool has_poi() const;
  void clear_poi() ;
  ::rtech::liveapi::PlayerOfInterest poi() const;
  void set_poi(::rtech::liveapi::PlayerOfInterest value);

  private:
  ::rtech::liveapi::PlayerOfInterest _internal_poi() const;
  void _internal_set_poi(::rtech::liveapi::PlayerOfInterest value);

  public:
  // string name = 2;
  bool has_name() const;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  void clear_target();
  TargetCase target_case() const;
  // @@protoc_insertion_point(class_scope:rtech.liveapi.ChangeCamera)
 private:
  class _Internal;
  void set_has_poi();
  void set_has_name();

  inline bool has_target() const;
  inline void clear_has_target();

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 2, 0,
      39, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    union TargetUnion {
      constexpr TargetUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      int poi_;
      ::google::protobuf::internal::ArenaStringPtr name_;
    } target_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];

    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_events_2eproto;
};// -------------------------------------------------------------------

class RingStartClosing final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rtech.liveapi.RingStartClosing) */ {
 public:
  inline RingStartClosing() : RingStartClosing(nullptr) {}
  ~RingStartClosing() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RingStartClosing(::google::protobuf::internal::ConstantInitialized);

  inline RingStartClosing(const RingStartClosing& from)
      : RingStartClosing(nullptr, from) {}
  RingStartClosing(RingStartClosing&& from) noexcept
    : RingStartClosing() {
    *this = ::std::move(from);
  }

  inline RingStartClosing& operator=(const RingStartClosing& from) {
    CopyFrom(from);
    return *this;
  }
  inline RingStartClosing& operator=(RingStartClosing&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RingStartClosing& default_instance() {
    return *internal_default_instance();
  }
  static inline const RingStartClosing* internal_default_instance() {
    return reinterpret_cast<const RingStartClosing*>(
               &_RingStartClosing_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(RingStartClosing& a, RingStartClosing& b) {
    a.Swap(&b);
  }
  inline void Swap(RingStartClosing* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RingStartClosing* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RingStartClosing* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RingStartClosing>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RingStartClosing& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const RingStartClosing& from) {
    RingStartClosing::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RingStartClosing* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "rtech.liveapi.RingStartClosing";
  }
  protected:
  explicit RingStartClosing(::google::protobuf::Arena* arena);
  RingStartClosing(::google::protobuf::Arena* arena, const RingStartClosing& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCategoryFieldNumber = 2,
    kCenterFieldNumber = 4,
    kTimestampFieldNumber = 1,
    kStageFieldNumber = 3,
    kCurrentRadiusFieldNumber = 5,
    kEndRadiusFieldNumber = 6,
    kShrinkDurationFieldNumber = 7,
  };
  // string category = 2;
  void clear_category() ;
  const std::string& category() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_category(Arg_&& arg, Args_... args);
  std::string* mutable_category();
  PROTOBUF_NODISCARD std::string* release_category();
  void set_allocated_category(std::string* value);

  private:
  const std::string& _internal_category() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_category(
      const std::string& value);
  std::string* _internal_mutable_category();

  public:
  // .rtech.liveapi.Vector3 center = 4;
  bool has_center() const;
  void clear_center() ;
  const ::rtech::liveapi::Vector3& center() const;
  PROTOBUF_NODISCARD ::rtech::liveapi::Vector3* release_center();
  ::rtech::liveapi::Vector3* mutable_center();
  void set_allocated_center(::rtech::liveapi::Vector3* value);
  void unsafe_arena_set_allocated_center(::rtech::liveapi::Vector3* value);
  ::rtech::liveapi::Vector3* unsafe_arena_release_center();

  private:
  const ::rtech::liveapi::Vector3& _internal_center() const;
  ::rtech::liveapi::Vector3* _internal_mutable_center();

  public:
  // uint64 timestamp = 1;
  void clear_timestamp() ;
  ::uint64_t timestamp() const;
  void set_timestamp(::uint64_t value);

  private:
  ::uint64_t _internal_timestamp() const;
  void _internal_set_timestamp(::uint64_t value);

  public:
  // uint32 stage = 3;
  void clear_stage() ;
  ::uint32_t stage() const;
  void set_stage(::uint32_t value);

  private:
  ::uint32_t _internal_stage() const;
  void _internal_set_stage(::uint32_t value);

  public:
  // float currentRadius = 5;
  void clear_currentradius() ;
  float currentradius() const;
  void set_currentradius(float value);

  private:
  float _internal_currentradius() const;
  void _internal_set_currentradius(float value);

  public:
  // float endRadius = 6;
  void clear_endradius() ;
  float endradius() const;
  void set_endradius(float value);

  private:
  float _internal_endradius() const;
  void _internal_set_endradius(float value);

  public:
  // float shrinkDuration = 7;
  void clear_shrinkduration() ;
  float shrinkduration() const;
  void set_shrinkduration(float value);

  private:
  float _internal_shrinkduration() const;
  void _internal_set_shrinkduration(float value);

  public:
  // @@protoc_insertion_point(class_scope:rtech.liveapi.RingStartClosing)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 7, 1,
      47, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr category_;
    ::rtech::liveapi::Vector3* center_;
    ::uint64_t timestamp_;
    ::uint32_t stage_;
    float currentradius_;
    float endradius_;
    float shrinkduration_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_events_2eproto;
};// -------------------------------------------------------------------

class RingFinishedClosing final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rtech.liveapi.RingFinishedClosing) */ {
 public:
  inline RingFinishedClosing() : RingFinishedClosing(nullptr) {}
  ~RingFinishedClosing() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RingFinishedClosing(::google::protobuf::internal::ConstantInitialized);

  inline RingFinishedClosing(const RingFinishedClosing& from)
      : RingFinishedClosing(nullptr, from) {}
  RingFinishedClosing(RingFinishedClosing&& from) noexcept
    : RingFinishedClosing() {
    *this = ::std::move(from);
  }

  inline RingFinishedClosing& operator=(const RingFinishedClosing& from) {
    CopyFrom(from);
    return *this;
  }
  inline RingFinishedClosing& operator=(RingFinishedClosing&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RingFinishedClosing& default_instance() {
    return *internal_default_instance();
  }
  static inline const RingFinishedClosing* internal_default_instance() {
    return reinterpret_cast<const RingFinishedClosing*>(
               &_RingFinishedClosing_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(RingFinishedClosing& a, RingFinishedClosing& b) {
    a.Swap(&b);
  }
  inline void Swap(RingFinishedClosing* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RingFinishedClosing* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RingFinishedClosing* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RingFinishedClosing>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RingFinishedClosing& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const RingFinishedClosing& from) {
    RingFinishedClosing::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RingFinishedClosing* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "rtech.liveapi.RingFinishedClosing";
  }
  protected:
  explicit RingFinishedClosing(::google::protobuf::Arena* arena);
  RingFinishedClosing(::google::protobuf::Arena* arena, const RingFinishedClosing& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCategoryFieldNumber = 2,
    kCenterFieldNumber = 4,
    kTimestampFieldNumber = 1,
    kStageFieldNumber = 3,
    kCurrentRadiusFieldNumber = 5,
    kShrinkDurationFieldNumber = 7,
  };
  // string category = 2;
  void clear_category() ;
  const std::string& category() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_category(Arg_&& arg, Args_... args);
  std::string* mutable_category();
  PROTOBUF_NODISCARD std::string* release_category();
  void set_allocated_category(std::string* value);

  private:
  const std::string& _internal_category() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_category(
      const std::string& value);
  std::string* _internal_mutable_category();

  public:
  // .rtech.liveapi.Vector3 center = 4;
  bool has_center() const;
  void clear_center() ;
  const ::rtech::liveapi::Vector3& center() const;
  PROTOBUF_NODISCARD ::rtech::liveapi::Vector3* release_center();
  ::rtech::liveapi::Vector3* mutable_center();
  void set_allocated_center(::rtech::liveapi::Vector3* value);
  void unsafe_arena_set_allocated_center(::rtech::liveapi::Vector3* value);
  ::rtech::liveapi::Vector3* unsafe_arena_release_center();

  private:
  const ::rtech::liveapi::Vector3& _internal_center() const;
  ::rtech::liveapi::Vector3* _internal_mutable_center();

  public:
  // uint64 timestamp = 1;
  void clear_timestamp() ;
  ::uint64_t timestamp() const;
  void set_timestamp(::uint64_t value);

  private:
  ::uint64_t _internal_timestamp() const;
  void _internal_set_timestamp(::uint64_t value);

  public:
  // uint32 stage = 3;
  void clear_stage() ;
  ::uint32_t stage() const;
  void set_stage(::uint32_t value);

  private:
  ::uint32_t _internal_stage() const;
  void _internal_set_stage(::uint32_t value);

  public:
  // float currentRadius = 5;
  void clear_currentradius() ;
  float currentradius() const;
  void set_currentradius(float value);

  private:
  float _internal_currentradius() const;
  void _internal_set_currentradius(float value);

  public:
  // float shrinkDuration = 7;
  void clear_shrinkduration() ;
  float shrinkduration() const;
  void set_shrinkduration(float value);

  private:
  float _internal_shrinkduration() const;
  void _internal_set_shrinkduration(float value);

  public:
  // @@protoc_insertion_point(class_scope:rtech.liveapi.RingFinishedClosing)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 6, 1,
      50, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr category_;
    ::rtech::liveapi::Vector3* center_;
    ::uint64_t timestamp_;
    ::uint32_t stage_;
    float currentradius_;
    float shrinkduration_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_events_2eproto;
};// -------------------------------------------------------------------

class Response final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rtech.liveapi.Response) */ {
 public:
  inline Response() : Response(nullptr) {}
  ~Response() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Response(::google::protobuf::internal::ConstantInitialized);

  inline Response(const Response& from)
      : Response(nullptr, from) {}
  Response(Response&& from) noexcept
    : Response() {
    *this = ::std::move(from);
  }

  inline Response& operator=(const Response& from) {
    CopyFrom(from);
    return *this;
  }
  inline Response& operator=(Response&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Response& default_instance() {
    return *internal_default_instance();
  }
  static inline const Response* internal_default_instance() {
    return reinterpret_cast<const Response*>(
               &_Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    61;

  friend void swap(Response& a, Response& b) {
    a.Swap(&b);
  }
  inline void Swap(Response* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Response* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Response* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Response>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Response& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Response& from) {
    Response::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Response* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "rtech.liveapi.Response";
  }
  protected:
  explicit Response(::google::protobuf::Arena* arena);
  Response(::google::protobuf::Arena* arena, const Response& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultFieldNumber = 2,
    kSuccessFieldNumber = 1,
  };
  // .google.protobuf.Any result = 2;
  bool has_result() const;
  void clear_result() ;
  const ::google::protobuf::Any& result() const;
  PROTOBUF_NODISCARD ::google::protobuf::Any* release_result();
  ::google::protobuf::Any* mutable_result();
  void set_allocated_result(::google::protobuf::Any* value);
  void unsafe_arena_set_allocated_result(::google::protobuf::Any* value);
  ::google::protobuf::Any* unsafe_arena_release_result();

  private:
  const ::google::protobuf::Any& _internal_result() const;
  ::google::protobuf::Any* _internal_mutable_result();

  public:
  // bool success = 1;
  void clear_success() ;
  bool success() const;
  void set_success(bool value);

  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);

  public:
  // @@protoc_insertion_point(class_scope:rtech.liveapi.Response)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::Any* result_;
    bool success_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_events_2eproto;
};// -------------------------------------------------------------------

class Request final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rtech.liveapi.Request) */ {
 public:
  inline Request() : Request(nullptr) {}
  ~Request() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Request(::google::protobuf::internal::ConstantInitialized);

  inline Request(const Request& from)
      : Request(nullptr, from) {}
  Request(Request&& from) noexcept
    : Request() {
    *this = ::std::move(from);
  }

  inline Request& operator=(const Request& from) {
    CopyFrom(from);
    return *this;
  }
  inline Request& operator=(Request&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Request& default_instance() {
    return *internal_default_instance();
  }
  enum ActionsCase {
    kChangeCam = 4,
    kPauseToggle = 5,
    kCustomMatchCreateLobby = 10,
    kCustomMatchJoinLobby = 11,
    kCustomMatchLeaveLobby = 12,
    kCustomMatchSetReady = 13,
    kCustomMatchSetMatchmaking = 14,
    kCustomMatchSetTeam = 15,
    kCustomMatchKickPlayer = 16,
    kCustomMatchSetSettings = 17,
    kCustomMatchSendChat = 18,
    kCustomMatchGetLobbyPlayers = 19,
    kCustomMatchSetTeamName = 20,
    kCustomMatchGetSettings = 21,
    ACTIONS_NOT_SET = 0,
  };

  static inline const Request* internal_default_instance() {
    return reinterpret_cast<const Request*>(
               &_Request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    59;

  friend void swap(Request& a, Request& b) {
    a.Swap(&b);
  }
  inline void Swap(Request* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Request* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Request* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Request>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Request& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Request& from) {
    Request::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Request* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "rtech.liveapi.Request";
  }
  protected:
  explicit Request(::google::protobuf::Arena* arena);
  Request(::google::protobuf::Arena* arena, const Request& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPreSharedKeyFieldNumber = 2,
    kWithAckFieldNumber = 1,
    kChangeCamFieldNumber = 4,
    kPauseToggleFieldNumber = 5,
    kCustomMatchCreateLobbyFieldNumber = 10,
    kCustomMatchJoinLobbyFieldNumber = 11,
    kCustomMatchLeaveLobbyFieldNumber = 12,
    kCustomMatchSetReadyFieldNumber = 13,
    kCustomMatchSetMatchmakingFieldNumber = 14,
    kCustomMatchSetTeamFieldNumber = 15,
    kCustomMatchKickPlayerFieldNumber = 16,
    kCustomMatchSetSettingsFieldNumber = 17,
    kCustomMatchSendChatFieldNumber = 18,
    kCustomMatchGetLobbyPlayersFieldNumber = 19,
    kCustomMatchSetTeamNameFieldNumber = 20,
    kCustomMatchGetSettingsFieldNumber = 21,
  };
  // string preSharedKey = 2;
  void clear_presharedkey() ;
  const std::string& presharedkey() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_presharedkey(Arg_&& arg, Args_... args);
  std::string* mutable_presharedkey();
  PROTOBUF_NODISCARD std::string* release_presharedkey();
  void set_allocated_presharedkey(std::string* value);

  private:
  const std::string& _internal_presharedkey() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_presharedkey(
      const std::string& value);
  std::string* _internal_mutable_presharedkey();

  public:
  // bool withAck = 1;
  void clear_withack() ;
  bool withack() const;
  void set_withack(bool value);

  private:
  bool _internal_withack() const;
  void _internal_set_withack(bool value);

  public:
  // .rtech.liveapi.ChangeCamera changeCam = 4;
  bool has_changecam() const;
  private:
  bool _internal_has_changecam() const;

  public:
  void clear_changecam() ;
  const ::rtech::liveapi::ChangeCamera& changecam() const;
  PROTOBUF_NODISCARD ::rtech::liveapi::ChangeCamera* release_changecam();
  ::rtech::liveapi::ChangeCamera* mutable_changecam();
  void set_allocated_changecam(::rtech::liveapi::ChangeCamera* value);
  void unsafe_arena_set_allocated_changecam(::rtech::liveapi::ChangeCamera* value);
  ::rtech::liveapi::ChangeCamera* unsafe_arena_release_changecam();

  private:
  const ::rtech::liveapi::ChangeCamera& _internal_changecam() const;
  ::rtech::liveapi::ChangeCamera* _internal_mutable_changecam();

  public:
  // .rtech.liveapi.PauseToggle pauseToggle = 5;
  bool has_pausetoggle() const;
  private:
  bool _internal_has_pausetoggle() const;

  public:
  void clear_pausetoggle() ;
  const ::rtech::liveapi::PauseToggle& pausetoggle() const;
  PROTOBUF_NODISCARD ::rtech::liveapi::PauseToggle* release_pausetoggle();
  ::rtech::liveapi::PauseToggle* mutable_pausetoggle();
  void set_allocated_pausetoggle(::rtech::liveapi::PauseToggle* value);
  void unsafe_arena_set_allocated_pausetoggle(::rtech::liveapi::PauseToggle* value);
  ::rtech::liveapi::PauseToggle* unsafe_arena_release_pausetoggle();

  private:
  const ::rtech::liveapi::PauseToggle& _internal_pausetoggle() const;
  ::rtech::liveapi::PauseToggle* _internal_mutable_pausetoggle();

  public:
  // .rtech.liveapi.CustomMatch_CreateLobby customMatch_CreateLobby = 10;
  bool has_custommatch_createlobby() const;
  private:
  bool _internal_has_custommatch_createlobby() const;

  public:
  void clear_custommatch_createlobby() ;
  const ::rtech::liveapi::CustomMatch_CreateLobby& custommatch_createlobby() const;
  PROTOBUF_NODISCARD ::rtech::liveapi::CustomMatch_CreateLobby* release_custommatch_createlobby();
  ::rtech::liveapi::CustomMatch_CreateLobby* mutable_custommatch_createlobby();
  void set_allocated_custommatch_createlobby(::rtech::liveapi::CustomMatch_CreateLobby* value);
  void unsafe_arena_set_allocated_custommatch_createlobby(::rtech::liveapi::CustomMatch_CreateLobby* value);
  ::rtech::liveapi::CustomMatch_CreateLobby* unsafe_arena_release_custommatch_createlobby();

  private:
  const ::rtech::liveapi::CustomMatch_CreateLobby& _internal_custommatch_createlobby() const;
  ::rtech::liveapi::CustomMatch_CreateLobby* _internal_mutable_custommatch_createlobby();

  public:
  // .rtech.liveapi.CustomMatch_JoinLobby customMatch_JoinLobby = 11;
  bool has_custommatch_joinlobby() const;
  private:
  bool _internal_has_custommatch_joinlobby() const;

  public:
  void clear_custommatch_joinlobby() ;
  const ::rtech::liveapi::CustomMatch_JoinLobby& custommatch_joinlobby() const;
  PROTOBUF_NODISCARD ::rtech::liveapi::CustomMatch_JoinLobby* release_custommatch_joinlobby();
  ::rtech::liveapi::CustomMatch_JoinLobby* mutable_custommatch_joinlobby();
  void set_allocated_custommatch_joinlobby(::rtech::liveapi::CustomMatch_JoinLobby* value);
  void unsafe_arena_set_allocated_custommatch_joinlobby(::rtech::liveapi::CustomMatch_JoinLobby* value);
  ::rtech::liveapi::CustomMatch_JoinLobby* unsafe_arena_release_custommatch_joinlobby();

  private:
  const ::rtech::liveapi::CustomMatch_JoinLobby& _internal_custommatch_joinlobby() const;
  ::rtech::liveapi::CustomMatch_JoinLobby* _internal_mutable_custommatch_joinlobby();

  public:
  // .rtech.liveapi.CustomMatch_LeaveLobby customMatch_LeaveLobby = 12;
  bool has_custommatch_leavelobby() const;
  private:
  bool _internal_has_custommatch_leavelobby() const;

  public:
  void clear_custommatch_leavelobby() ;
  const ::rtech::liveapi::CustomMatch_LeaveLobby& custommatch_leavelobby() const;
  PROTOBUF_NODISCARD ::rtech::liveapi::CustomMatch_LeaveLobby* release_custommatch_leavelobby();
  ::rtech::liveapi::CustomMatch_LeaveLobby* mutable_custommatch_leavelobby();
  void set_allocated_custommatch_leavelobby(::rtech::liveapi::CustomMatch_LeaveLobby* value);
  void unsafe_arena_set_allocated_custommatch_leavelobby(::rtech::liveapi::CustomMatch_LeaveLobby* value);
  ::rtech::liveapi::CustomMatch_LeaveLobby* unsafe_arena_release_custommatch_leavelobby();

  private:
  const ::rtech::liveapi::CustomMatch_LeaveLobby& _internal_custommatch_leavelobby() const;
  ::rtech::liveapi::CustomMatch_LeaveLobby* _internal_mutable_custommatch_leavelobby();

  public:
  // .rtech.liveapi.CustomMatch_SetReady customMatch_SetReady = 13;
  bool has_custommatch_setready() const;
  private:
  bool _internal_has_custommatch_setready() const;

  public:
  void clear_custommatch_setready() ;
  const ::rtech::liveapi::CustomMatch_SetReady& custommatch_setready() const;
  PROTOBUF_NODISCARD ::rtech::liveapi::CustomMatch_SetReady* release_custommatch_setready();
  ::rtech::liveapi::CustomMatch_SetReady* mutable_custommatch_setready();
  void set_allocated_custommatch_setready(::rtech::liveapi::CustomMatch_SetReady* value);
  void unsafe_arena_set_allocated_custommatch_setready(::rtech::liveapi::CustomMatch_SetReady* value);
  ::rtech::liveapi::CustomMatch_SetReady* unsafe_arena_release_custommatch_setready();

  private:
  const ::rtech::liveapi::CustomMatch_SetReady& _internal_custommatch_setready() const;
  ::rtech::liveapi::CustomMatch_SetReady* _internal_mutable_custommatch_setready();

  public:
  // .rtech.liveapi.CustomMatch_SetMatchmaking customMatch_SetMatchmaking = 14;
  bool has_custommatch_setmatchmaking() const;
  private:
  bool _internal_has_custommatch_setmatchmaking() const;

  public:
  void clear_custommatch_setmatchmaking() ;
  const ::rtech::liveapi::CustomMatch_SetMatchmaking& custommatch_setmatchmaking() const;
  PROTOBUF_NODISCARD ::rtech::liveapi::CustomMatch_SetMatchmaking* release_custommatch_setmatchmaking();
  ::rtech::liveapi::CustomMatch_SetMatchmaking* mutable_custommatch_setmatchmaking();
  void set_allocated_custommatch_setmatchmaking(::rtech::liveapi::CustomMatch_SetMatchmaking* value);
  void unsafe_arena_set_allocated_custommatch_setmatchmaking(::rtech::liveapi::CustomMatch_SetMatchmaking* value);
  ::rtech::liveapi::CustomMatch_SetMatchmaking* unsafe_arena_release_custommatch_setmatchmaking();

  private:
  const ::rtech::liveapi::CustomMatch_SetMatchmaking& _internal_custommatch_setmatchmaking() const;
  ::rtech::liveapi::CustomMatch_SetMatchmaking* _internal_mutable_custommatch_setmatchmaking();

  public:
  // .rtech.liveapi.CustomMatch_SetTeam customMatch_SetTeam = 15;
  bool has_custommatch_setteam() const;
  private:
  bool _internal_has_custommatch_setteam() const;

  public:
  void clear_custommatch_setteam() ;
  const ::rtech::liveapi::CustomMatch_SetTeam& custommatch_setteam() const;
  PROTOBUF_NODISCARD ::rtech::liveapi::CustomMatch_SetTeam* release_custommatch_setteam();
  ::rtech::liveapi::CustomMatch_SetTeam* mutable_custommatch_setteam();
  void set_allocated_custommatch_setteam(::rtech::liveapi::CustomMatch_SetTeam* value);
  void unsafe_arena_set_allocated_custommatch_setteam(::rtech::liveapi::CustomMatch_SetTeam* value);
  ::rtech::liveapi::CustomMatch_SetTeam* unsafe_arena_release_custommatch_setteam();

  private:
  const ::rtech::liveapi::CustomMatch_SetTeam& _internal_custommatch_setteam() const;
  ::rtech::liveapi::CustomMatch_SetTeam* _internal_mutable_custommatch_setteam();

  public:
  // .rtech.liveapi.CustomMatch_KickPlayer customMatch_KickPlayer = 16;
  bool has_custommatch_kickplayer() const;
  private:
  bool _internal_has_custommatch_kickplayer() const;

  public:
  void clear_custommatch_kickplayer() ;
  const ::rtech::liveapi::CustomMatch_KickPlayer& custommatch_kickplayer() const;
  PROTOBUF_NODISCARD ::rtech::liveapi::CustomMatch_KickPlayer* release_custommatch_kickplayer();
  ::rtech::liveapi::CustomMatch_KickPlayer* mutable_custommatch_kickplayer();
  void set_allocated_custommatch_kickplayer(::rtech::liveapi::CustomMatch_KickPlayer* value);
  void unsafe_arena_set_allocated_custommatch_kickplayer(::rtech::liveapi::CustomMatch_KickPlayer* value);
  ::rtech::liveapi::CustomMatch_KickPlayer* unsafe_arena_release_custommatch_kickplayer();

  private:
  const ::rtech::liveapi::CustomMatch_KickPlayer& _internal_custommatch_kickplayer() const;
  ::rtech::liveapi::CustomMatch_KickPlayer* _internal_mutable_custommatch_kickplayer();

  public:
  // .rtech.liveapi.CustomMatch_SetSettings customMatch_SetSettings = 17;
  bool has_custommatch_setsettings() const;
  private:
  bool _internal_has_custommatch_setsettings() const;

  public:
  void clear_custommatch_setsettings() ;
  const ::rtech::liveapi::CustomMatch_SetSettings& custommatch_setsettings() const;
  PROTOBUF_NODISCARD ::rtech::liveapi::CustomMatch_SetSettings* release_custommatch_setsettings();
  ::rtech::liveapi::CustomMatch_SetSettings* mutable_custommatch_setsettings();
  void set_allocated_custommatch_setsettings(::rtech::liveapi::CustomMatch_SetSettings* value);
  void unsafe_arena_set_allocated_custommatch_setsettings(::rtech::liveapi::CustomMatch_SetSettings* value);
  ::rtech::liveapi::CustomMatch_SetSettings* unsafe_arena_release_custommatch_setsettings();

  private:
  const ::rtech::liveapi::CustomMatch_SetSettings& _internal_custommatch_setsettings() const;
  ::rtech::liveapi::CustomMatch_SetSettings* _internal_mutable_custommatch_setsettings();

  public:
  // .rtech.liveapi.CustomMatch_SendChat customMatch_SendChat = 18;
  bool has_custommatch_sendchat() const;
  private:
  bool _internal_has_custommatch_sendchat() const;

  public:
  void clear_custommatch_sendchat() ;
  const ::rtech::liveapi::CustomMatch_SendChat& custommatch_sendchat() const;
  PROTOBUF_NODISCARD ::rtech::liveapi::CustomMatch_SendChat* release_custommatch_sendchat();
  ::rtech::liveapi::CustomMatch_SendChat* mutable_custommatch_sendchat();
  void set_allocated_custommatch_sendchat(::rtech::liveapi::CustomMatch_SendChat* value);
  void unsafe_arena_set_allocated_custommatch_sendchat(::rtech::liveapi::CustomMatch_SendChat* value);
  ::rtech::liveapi::CustomMatch_SendChat* unsafe_arena_release_custommatch_sendchat();

  private:
  const ::rtech::liveapi::CustomMatch_SendChat& _internal_custommatch_sendchat() const;
  ::rtech::liveapi::CustomMatch_SendChat* _internal_mutable_custommatch_sendchat();

  public:
  // .rtech.liveapi.CustomMatch_GetLobbyPlayers customMatch_GetLobbyPlayers = 19;
  bool has_custommatch_getlobbyplayers() const;
  private:
  bool _internal_has_custommatch_getlobbyplayers() const;

  public:
  void clear_custommatch_getlobbyplayers() ;
  const ::rtech::liveapi::CustomMatch_GetLobbyPlayers& custommatch_getlobbyplayers() const;
  PROTOBUF_NODISCARD ::rtech::liveapi::CustomMatch_GetLobbyPlayers* release_custommatch_getlobbyplayers();
  ::rtech::liveapi::CustomMatch_GetLobbyPlayers* mutable_custommatch_getlobbyplayers();
  void set_allocated_custommatch_getlobbyplayers(::rtech::liveapi::CustomMatch_GetLobbyPlayers* value);
  void unsafe_arena_set_allocated_custommatch_getlobbyplayers(::rtech::liveapi::CustomMatch_GetLobbyPlayers* value);
  ::rtech::liveapi::CustomMatch_GetLobbyPlayers* unsafe_arena_release_custommatch_getlobbyplayers();

  private:
  const ::rtech::liveapi::CustomMatch_GetLobbyPlayers& _internal_custommatch_getlobbyplayers() const;
  ::rtech::liveapi::CustomMatch_GetLobbyPlayers* _internal_mutable_custommatch_getlobbyplayers();

  public:
  // .rtech.liveapi.CustomMatch_SetTeamName customMatch_SetTeamName = 20;
  bool has_custommatch_setteamname() const;
  private:
  bool _internal_has_custommatch_setteamname() const;

  public:
  void clear_custommatch_setteamname() ;
  const ::rtech::liveapi::CustomMatch_SetTeamName& custommatch_setteamname() const;
  PROTOBUF_NODISCARD ::rtech::liveapi::CustomMatch_SetTeamName* release_custommatch_setteamname();
  ::rtech::liveapi::CustomMatch_SetTeamName* mutable_custommatch_setteamname();
  void set_allocated_custommatch_setteamname(::rtech::liveapi::CustomMatch_SetTeamName* value);
  void unsafe_arena_set_allocated_custommatch_setteamname(::rtech::liveapi::CustomMatch_SetTeamName* value);
  ::rtech::liveapi::CustomMatch_SetTeamName* unsafe_arena_release_custommatch_setteamname();

  private:
  const ::rtech::liveapi::CustomMatch_SetTeamName& _internal_custommatch_setteamname() const;
  ::rtech::liveapi::CustomMatch_SetTeamName* _internal_mutable_custommatch_setteamname();

  public:
  // .rtech.liveapi.CustomMatch_GetSettings customMatch_GetSettings = 21;
  bool has_custommatch_getsettings() const;
  private:
  bool _internal_has_custommatch_getsettings() const;

  public:
  void clear_custommatch_getsettings() ;
  const ::rtech::liveapi::CustomMatch_GetSettings& custommatch_getsettings() const;
  PROTOBUF_NODISCARD ::rtech::liveapi::CustomMatch_GetSettings* release_custommatch_getsettings();
  ::rtech::liveapi::CustomMatch_GetSettings* mutable_custommatch_getsettings();
  void set_allocated_custommatch_getsettings(::rtech::liveapi::CustomMatch_GetSettings* value);
  void unsafe_arena_set_allocated_custommatch_getsettings(::rtech::liveapi::CustomMatch_GetSettings* value);
  ::rtech::liveapi::CustomMatch_GetSettings* unsafe_arena_release_custommatch_getsettings();

  private:
  const ::rtech::liveapi::CustomMatch_GetSettings& _internal_custommatch_getsettings() const;
  ::rtech::liveapi::CustomMatch_GetSettings* _internal_mutable_custommatch_getsettings();

  public:
  void clear_actions();
  ActionsCase actions_case() const;
  // @@protoc_insertion_point(class_scope:rtech.liveapi.Request)
 private:
  class _Internal;
  void set_has_changecam();
  void set_has_pausetoggle();
  void set_has_custommatch_createlobby();
  void set_has_custommatch_joinlobby();
  void set_has_custommatch_leavelobby();
  void set_has_custommatch_setready();
  void set_has_custommatch_setmatchmaking();
  void set_has_custommatch_setteam();
  void set_has_custommatch_kickplayer();
  void set_has_custommatch_setsettings();
  void set_has_custommatch_sendchat();
  void set_has_custommatch_getlobbyplayers();
  void set_has_custommatch_setteamname();
  void set_has_custommatch_getsettings();

  inline bool has_actions() const;
  inline void clear_has_actions();

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 16, 14,
      58, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr presharedkey_;
    bool withack_;
    union ActionsUnion {
      constexpr ActionsUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::rtech::liveapi::ChangeCamera* changecam_;
      ::rtech::liveapi::PauseToggle* pausetoggle_;
      ::rtech::liveapi::CustomMatch_CreateLobby* custommatch_createlobby_;
      ::rtech::liveapi::CustomMatch_JoinLobby* custommatch_joinlobby_;
      ::rtech::liveapi::CustomMatch_LeaveLobby* custommatch_leavelobby_;
      ::rtech::liveapi::CustomMatch_SetReady* custommatch_setready_;
      ::rtech::liveapi::CustomMatch_SetMatchmaking* custommatch_setmatchmaking_;
      ::rtech::liveapi::CustomMatch_SetTeam* custommatch_setteam_;
      ::rtech::liveapi::CustomMatch_KickPlayer* custommatch_kickplayer_;
      ::rtech::liveapi::CustomMatch_SetSettings* custommatch_setsettings_;
      ::rtech::liveapi::CustomMatch_SendChat* custommatch_sendchat_;
      ::rtech::liveapi::CustomMatch_GetLobbyPlayers* custommatch_getlobbyplayers_;
      ::rtech::liveapi::CustomMatch_SetTeamName* custommatch_setteamname_;
      ::rtech::liveapi::CustomMatch_GetSettings* custommatch_getsettings_;
    } actions_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];

    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_events_2eproto;
};// -------------------------------------------------------------------

class Player final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rtech.liveapi.Player) */ {
 public:
  inline Player() : Player(nullptr) {}
  ~Player() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Player(::google::protobuf::internal::ConstantInitialized);

  inline Player(const Player& from)
      : Player(nullptr, from) {}
  Player(Player&& from) noexcept
    : Player() {
    *this = ::std::move(from);
  }

  inline Player& operator=(const Player& from) {
    CopyFrom(from);
    return *this;
  }
  inline Player& operator=(Player&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Player& default_instance() {
    return *internal_default_instance();
  }
  static inline const Player* internal_default_instance() {
    return reinterpret_cast<const Player*>(
               &_Player_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Player& a, Player& b) {
    a.Swap(&b);
  }
  inline void Swap(Player* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Player* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Player* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Player>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Player& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Player& from) {
    Player::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Player* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "rtech.liveapi.Player";
  }
  protected:
  explicit Player(::google::protobuf::Arena* arena);
  Player(::google::protobuf::Arena* arena, const Player& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kNucleusHashFieldNumber = 9,
    kHardwareNameFieldNumber = 10,
    kTeamNameFieldNumber = 11,
    kCharacterFieldNumber = 13,
    kSkinFieldNumber = 14,
    kPosFieldNumber = 3,
    kAnglesFieldNumber = 4,
    kTeamIdFieldNumber = 2,
    kCurrentHealthFieldNumber = 5,
    kMaxHealthFieldNumber = 6,
    kShieldHealthFieldNumber = 7,
    kShieldMaxHealthFieldNumber = 8,
    kSquadIndexFieldNumber = 12,
  };
  // string name = 1;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // string nucleusHash = 9;
  void clear_nucleushash() ;
  const std::string& nucleushash() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_nucleushash(Arg_&& arg, Args_... args);
  std::string* mutable_nucleushash();
  PROTOBUF_NODISCARD std::string* release_nucleushash();
  void set_allocated_nucleushash(std::string* value);

  private:
  const std::string& _internal_nucleushash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_nucleushash(
      const std::string& value);
  std::string* _internal_mutable_nucleushash();

  public:
  // string hardwareName = 10;
  void clear_hardwarename() ;
  const std::string& hardwarename() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_hardwarename(Arg_&& arg, Args_... args);
  std::string* mutable_hardwarename();
  PROTOBUF_NODISCARD std::string* release_hardwarename();
  void set_allocated_hardwarename(std::string* value);

  private:
  const std::string& _internal_hardwarename() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hardwarename(
      const std::string& value);
  std::string* _internal_mutable_hardwarename();

  public:
  // string teamName = 11;
  void clear_teamname() ;
  const std::string& teamname() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_teamname(Arg_&& arg, Args_... args);
  std::string* mutable_teamname();
  PROTOBUF_NODISCARD std::string* release_teamname();
  void set_allocated_teamname(std::string* value);

  private:
  const std::string& _internal_teamname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_teamname(
      const std::string& value);
  std::string* _internal_mutable_teamname();

  public:
  // string character = 13;
  void clear_character() ;
  const std::string& character() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_character(Arg_&& arg, Args_... args);
  std::string* mutable_character();
  PROTOBUF_NODISCARD std::string* release_character();
  void set_allocated_character(std::string* value);

  private:
  const std::string& _internal_character() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_character(
      const std::string& value);
  std::string* _internal_mutable_character();

  public:
  // string skin = 14;
  void clear_skin() ;
  const std::string& skin() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_skin(Arg_&& arg, Args_... args);
  std::string* mutable_skin();
  PROTOBUF_NODISCARD std::string* release_skin();
  void set_allocated_skin(std::string* value);

  private:
  const std::string& _internal_skin() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_skin(
      const std::string& value);
  std::string* _internal_mutable_skin();

  public:
  // .rtech.liveapi.Vector3 pos = 3;
  bool has_pos() const;
  void clear_pos() ;
  const ::rtech::liveapi::Vector3& pos() const;
  PROTOBUF_NODISCARD ::rtech::liveapi::Vector3* release_pos();
  ::rtech::liveapi::Vector3* mutable_pos();
  void set_allocated_pos(::rtech::liveapi::Vector3* value);
  void unsafe_arena_set_allocated_pos(::rtech::liveapi::Vector3* value);
  ::rtech::liveapi::Vector3* unsafe_arena_release_pos();

  private:
  const ::rtech::liveapi::Vector3& _internal_pos() const;
  ::rtech::liveapi::Vector3* _internal_mutable_pos();

  public:
  // .rtech.liveapi.Vector3 angles = 4;
  bool has_angles() const;
  void clear_angles() ;
  const ::rtech::liveapi::Vector3& angles() const;
  PROTOBUF_NODISCARD ::rtech::liveapi::Vector3* release_angles();
  ::rtech::liveapi::Vector3* mutable_angles();
  void set_allocated_angles(::rtech::liveapi::Vector3* value);
  void unsafe_arena_set_allocated_angles(::rtech::liveapi::Vector3* value);
  ::rtech::liveapi::Vector3* unsafe_arena_release_angles();

  private:
  const ::rtech::liveapi::Vector3& _internal_angles() const;
  ::rtech::liveapi::Vector3* _internal_mutable_angles();

  public:
  // uint32 teamId = 2;
  void clear_teamid() ;
  ::uint32_t teamid() const;
  void set_teamid(::uint32_t value);

  private:
  ::uint32_t _internal_teamid() const;
  void _internal_set_teamid(::uint32_t value);

  public:
  // uint32 currentHealth = 5;
  void clear_currenthealth() ;
  ::uint32_t currenthealth() const;
  void set_currenthealth(::uint32_t value);

  private:
  ::uint32_t _internal_currenthealth() const;
  void _internal_set_currenthealth(::uint32_t value);

  public:
  // uint32 maxHealth = 6;
  void clear_maxhealth() ;
  ::uint32_t maxhealth() const;
  void set_maxhealth(::uint32_t value);

  private:
  ::uint32_t _internal_maxhealth() const;
  void _internal_set_maxhealth(::uint32_t value);

  public:
  // uint32 shieldHealth = 7;
  void clear_shieldhealth() ;
  ::uint32_t shieldhealth() const;
  void set_shieldhealth(::uint32_t value);

  private:
  ::uint32_t _internal_shieldhealth() const;
  void _internal_set_shieldhealth(::uint32_t value);

  public:
  // uint32 shieldMaxHealth = 8;
  void clear_shieldmaxhealth() ;
  ::uint32_t shieldmaxhealth() const;
  void set_shieldmaxhealth(::uint32_t value);

  private:
  ::uint32_t _internal_shieldmaxhealth() const;
  void _internal_set_shieldmaxhealth(::uint32_t value);

  public:
  // uint32 squadIndex = 12;
  void clear_squadindex() ;
  ::uint32_t squadindex() const;
  void set_squadindex(::uint32_t value);

  private:
  ::uint32_t _internal_squadindex() const;
  void _internal_set_squadindex(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:rtech.liveapi.Player)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 14, 2,
      85, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::google::protobuf::internal::ArenaStringPtr nucleushash_;
    ::google::protobuf::internal::ArenaStringPtr hardwarename_;
    ::google::protobuf::internal::ArenaStringPtr teamname_;
    ::google::protobuf::internal::ArenaStringPtr character_;
    ::google::protobuf::internal::ArenaStringPtr skin_;
    ::rtech::liveapi::Vector3* pos_;
    ::rtech::liveapi::Vector3* angles_;
    ::uint32_t teamid_;
    ::uint32_t currenthealth_;
    ::uint32_t maxhealth_;
    ::uint32_t shieldhealth_;
    ::uint32_t shieldmaxhealth_;
    ::uint32_t squadindex_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_events_2eproto;
};// -------------------------------------------------------------------

class LoadoutConfiguration final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rtech.liveapi.LoadoutConfiguration) */ {
 public:
  inline LoadoutConfiguration() : LoadoutConfiguration(nullptr) {}
  ~LoadoutConfiguration() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR LoadoutConfiguration(::google::protobuf::internal::ConstantInitialized);

  inline LoadoutConfiguration(const LoadoutConfiguration& from)
      : LoadoutConfiguration(nullptr, from) {}
  LoadoutConfiguration(LoadoutConfiguration&& from) noexcept
    : LoadoutConfiguration() {
    *this = ::std::move(from);
  }

  inline LoadoutConfiguration& operator=(const LoadoutConfiguration& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoadoutConfiguration& operator=(LoadoutConfiguration&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LoadoutConfiguration& default_instance() {
    return *internal_default_instance();
  }
  static inline const LoadoutConfiguration* internal_default_instance() {
    return reinterpret_cast<const LoadoutConfiguration*>(
               &_LoadoutConfiguration_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(LoadoutConfiguration& a, LoadoutConfiguration& b) {
    a.Swap(&b);
  }
  inline void Swap(LoadoutConfiguration* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoadoutConfiguration* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LoadoutConfiguration* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LoadoutConfiguration>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const LoadoutConfiguration& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const LoadoutConfiguration& from) {
    LoadoutConfiguration::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(LoadoutConfiguration* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "rtech.liveapi.LoadoutConfiguration";
  }
  protected:
  explicit LoadoutConfiguration(::google::protobuf::Arena* arena);
  LoadoutConfiguration(::google::protobuf::Arena* arena, const LoadoutConfiguration& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWeaponsFieldNumber = 1,
    kEquipmentFieldNumber = 2,
  };
  // repeated .rtech.liveapi.InventoryItem weapons = 1;
  int weapons_size() const;
  private:
  int _internal_weapons_size() const;

  public:
  void clear_weapons() ;
  ::rtech::liveapi::InventoryItem* mutable_weapons(int index);
  ::google::protobuf::RepeatedPtrField< ::rtech::liveapi::InventoryItem >*
      mutable_weapons();
  private:
  const ::google::protobuf::RepeatedPtrField<::rtech::liveapi::InventoryItem>& _internal_weapons() const;
  ::google::protobuf::RepeatedPtrField<::rtech::liveapi::InventoryItem>* _internal_mutable_weapons();
  public:
  const ::rtech::liveapi::InventoryItem& weapons(int index) const;
  ::rtech::liveapi::InventoryItem* add_weapons();
  const ::google::protobuf::RepeatedPtrField< ::rtech::liveapi::InventoryItem >&
      weapons() const;
  // repeated .rtech.liveapi.InventoryItem equipment = 2;
  int equipment_size() const;
  private:
  int _internal_equipment_size() const;

  public:
  void clear_equipment() ;
  ::rtech::liveapi::InventoryItem* mutable_equipment(int index);
  ::google::protobuf::RepeatedPtrField< ::rtech::liveapi::InventoryItem >*
      mutable_equipment();
  private:
  const ::google::protobuf::RepeatedPtrField<::rtech::liveapi::InventoryItem>& _internal_equipment() const;
  ::google::protobuf::RepeatedPtrField<::rtech::liveapi::InventoryItem>* _internal_mutable_equipment();
  public:
  const ::rtech::liveapi::InventoryItem& equipment(int index) const;
  ::rtech::liveapi::InventoryItem* add_equipment();
  const ::google::protobuf::RepeatedPtrField< ::rtech::liveapi::InventoryItem >&
      equipment() const;
  // @@protoc_insertion_point(class_scope:rtech.liveapi.LoadoutConfiguration)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField< ::rtech::liveapi::InventoryItem > weapons_;
    ::google::protobuf::RepeatedPtrField< ::rtech::liveapi::InventoryItem > equipment_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_events_2eproto;
};// -------------------------------------------------------------------

class LiveAPIEvent final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rtech.liveapi.LiveAPIEvent) */ {
 public:
  inline LiveAPIEvent() : LiveAPIEvent(nullptr) {}
  ~LiveAPIEvent() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR LiveAPIEvent(::google::protobuf::internal::ConstantInitialized);

  inline LiveAPIEvent(const LiveAPIEvent& from)
      : LiveAPIEvent(nullptr, from) {}
  LiveAPIEvent(LiveAPIEvent&& from) noexcept
    : LiveAPIEvent() {
    *this = ::std::move(from);
  }

  inline LiveAPIEvent& operator=(const LiveAPIEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline LiveAPIEvent& operator=(LiveAPIEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LiveAPIEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const LiveAPIEvent* internal_default_instance() {
    return reinterpret_cast<const LiveAPIEvent*>(
               &_LiveAPIEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    62;

  friend void swap(LiveAPIEvent& a, LiveAPIEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(LiveAPIEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LiveAPIEvent* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LiveAPIEvent* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LiveAPIEvent>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const LiveAPIEvent& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const LiveAPIEvent& from) {
    LiveAPIEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(LiveAPIEvent* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "rtech.liveapi.LiveAPIEvent";
  }
  protected:
  explicit LiveAPIEvent(::google::protobuf::Arena* arena);
  LiveAPIEvent(::google::protobuf::Arena* arena, const LiveAPIEvent& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGameMessageFieldNumber = 3,
    kEventSizeFieldNumber = 1,
  };
  // .google.protobuf.Any gameMessage = 3;
  bool has_gamemessage() const;
  void clear_gamemessage() ;
  const ::google::protobuf::Any& gamemessage() const;
  PROTOBUF_NODISCARD ::google::protobuf::Any* release_gamemessage();
  ::google::protobuf::Any* mutable_gamemessage();
  void set_allocated_gamemessage(::google::protobuf::Any* value);
  void unsafe_arena_set_allocated_gamemessage(::google::protobuf::Any* value);
  ::google::protobuf::Any* unsafe_arena_release_gamemessage();

  private:
  const ::google::protobuf::Any& _internal_gamemessage() const;
  ::google::protobuf::Any* _internal_mutable_gamemessage();

  public:
  // fixed32 event_size = 1;
  void clear_event_size() ;
  ::uint32_t event_size() const;
  void set_event_size(::uint32_t value);

  private:
  ::uint32_t _internal_event_size() const;
  void _internal_set_event_size(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:rtech.liveapi.LiveAPIEvent)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 2, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::Any* gamemessage_;
    ::uint32_t event_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_events_2eproto;
};// -------------------------------------------------------------------

class Init final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rtech.liveapi.Init) */ {
 public:
  inline Init() : Init(nullptr) {}
  ~Init() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Init(::google::protobuf::internal::ConstantInitialized);

  inline Init(const Init& from)
      : Init(nullptr, from) {}
  Init(Init&& from) noexcept
    : Init() {
    *this = ::std::move(from);
  }

  inline Init& operator=(const Init& from) {
    CopyFrom(from);
    return *this;
  }
  inline Init& operator=(Init&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Init& default_instance() {
    return *internal_default_instance();
  }
  static inline const Init* internal_default_instance() {
    return reinterpret_cast<const Init*>(
               &_Init_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(Init& a, Init& b) {
    a.Swap(&b);
  }
  inline void Swap(Init* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Init* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Init* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Init>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Init& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Init& from) {
    Init::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Init* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "rtech.liveapi.Init";
  }
  protected:
  explicit Init(::google::protobuf::Arena* arena);
  Init(::google::protobuf::Arena* arena, const Init& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCategoryFieldNumber = 2,
    kGameVersionFieldNumber = 3,
    kPlatformFieldNumber = 5,
    kNameFieldNumber = 6,
    kApiVersionFieldNumber = 4,
    kTimestampFieldNumber = 1,
  };
  // string category = 2;
  void clear_category() ;
  const std::string& category() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_category(Arg_&& arg, Args_... args);
  std::string* mutable_category();
  PROTOBUF_NODISCARD std::string* release_category();
  void set_allocated_category(std::string* value);

  private:
  const std::string& _internal_category() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_category(
      const std::string& value);
  std::string* _internal_mutable_category();

  public:
  // string gameVersion = 3;
  void clear_gameversion() ;
  const std::string& gameversion() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_gameversion(Arg_&& arg, Args_... args);
  std::string* mutable_gameversion();
  PROTOBUF_NODISCARD std::string* release_gameversion();
  void set_allocated_gameversion(std::string* value);

  private:
  const std::string& _internal_gameversion() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_gameversion(
      const std::string& value);
  std::string* _internal_mutable_gameversion();

  public:
  // string platform = 5;
  void clear_platform() ;
  const std::string& platform() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_platform(Arg_&& arg, Args_... args);
  std::string* mutable_platform();
  PROTOBUF_NODISCARD std::string* release_platform();
  void set_allocated_platform(std::string* value);

  private:
  const std::string& _internal_platform() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_platform(
      const std::string& value);
  std::string* _internal_mutable_platform();

  public:
  // string name = 6;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // .rtech.liveapi.Version apiVersion = 4;
  bool has_apiversion() const;
  void clear_apiversion() ;
  const ::rtech::liveapi::Version& apiversion() const;
  PROTOBUF_NODISCARD ::rtech::liveapi::Version* release_apiversion();
  ::rtech::liveapi::Version* mutable_apiversion();
  void set_allocated_apiversion(::rtech::liveapi::Version* value);
  void unsafe_arena_set_allocated_apiversion(::rtech::liveapi::Version* value);
  ::rtech::liveapi::Version* unsafe_arena_release_apiversion();

  private:
  const ::rtech::liveapi::Version& _internal_apiversion() const;
  ::rtech::liveapi::Version* _internal_mutable_apiversion();

  public:
  // uint64 timestamp = 1;
  void clear_timestamp() ;
  ::uint64_t timestamp() const;
  void set_timestamp(::uint64_t value);

  private:
  ::uint64_t _internal_timestamp() const;
  void _internal_set_timestamp(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:rtech.liveapi.Init)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 6, 1,
      58, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr category_;
    ::google::protobuf::internal::ArenaStringPtr gameversion_;
    ::google::protobuf::internal::ArenaStringPtr platform_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::rtech::liveapi::Version* apiversion_;
    ::uint64_t timestamp_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_events_2eproto;
};// -------------------------------------------------------------------

class CustomMatch_LobbyPlayers final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rtech.liveapi.CustomMatch_LobbyPlayers) */ {
 public:
  inline CustomMatch_LobbyPlayers() : CustomMatch_LobbyPlayers(nullptr) {}
  ~CustomMatch_LobbyPlayers() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CustomMatch_LobbyPlayers(::google::protobuf::internal::ConstantInitialized);

  inline CustomMatch_LobbyPlayers(const CustomMatch_LobbyPlayers& from)
      : CustomMatch_LobbyPlayers(nullptr, from) {}
  CustomMatch_LobbyPlayers(CustomMatch_LobbyPlayers&& from) noexcept
    : CustomMatch_LobbyPlayers() {
    *this = ::std::move(from);
  }

  inline CustomMatch_LobbyPlayers& operator=(const CustomMatch_LobbyPlayers& from) {
    CopyFrom(from);
    return *this;
  }
  inline CustomMatch_LobbyPlayers& operator=(CustomMatch_LobbyPlayers&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CustomMatch_LobbyPlayers& default_instance() {
    return *internal_default_instance();
  }
  static inline const CustomMatch_LobbyPlayers* internal_default_instance() {
    return reinterpret_cast<const CustomMatch_LobbyPlayers*>(
               &_CustomMatch_LobbyPlayers_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(CustomMatch_LobbyPlayers& a, CustomMatch_LobbyPlayers& b) {
    a.Swap(&b);
  }
  inline void Swap(CustomMatch_LobbyPlayers* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CustomMatch_LobbyPlayers* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CustomMatch_LobbyPlayers* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CustomMatch_LobbyPlayers>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CustomMatch_LobbyPlayers& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const CustomMatch_LobbyPlayers& from) {
    CustomMatch_LobbyPlayers::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CustomMatch_LobbyPlayers* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "rtech.liveapi.CustomMatch_LobbyPlayers";
  }
  protected:
  explicit CustomMatch_LobbyPlayers(::google::protobuf::Arena* arena);
  CustomMatch_LobbyPlayers(::google::protobuf::Arena* arena, const CustomMatch_LobbyPlayers& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayersFieldNumber = 2,
    kPlayerTokenFieldNumber = 1,
  };
  // repeated .rtech.liveapi.CustomMatch_LobbyPlayer players = 2;
  int players_size() const;
  private:
  int _internal_players_size() const;

  public:
  void clear_players() ;
  ::rtech::liveapi::CustomMatch_LobbyPlayer* mutable_players(int index);
  ::google::protobuf::RepeatedPtrField< ::rtech::liveapi::CustomMatch_LobbyPlayer >*
      mutable_players();
  private:
  const ::google::protobuf::RepeatedPtrField<::rtech::liveapi::CustomMatch_LobbyPlayer>& _internal_players() const;
  ::google::protobuf::RepeatedPtrField<::rtech::liveapi::CustomMatch_LobbyPlayer>* _internal_mutable_players();
  public:
  const ::rtech::liveapi::CustomMatch_LobbyPlayer& players(int index) const;
  ::rtech::liveapi::CustomMatch_LobbyPlayer* add_players();
  const ::google::protobuf::RepeatedPtrField< ::rtech::liveapi::CustomMatch_LobbyPlayer >&
      players() const;
  // string playerToken = 1;
  void clear_playertoken() ;
  const std::string& playertoken() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_playertoken(Arg_&& arg, Args_... args);
  std::string* mutable_playertoken();
  PROTOBUF_NODISCARD std::string* release_playertoken();
  void set_allocated_playertoken(std::string* value);

  private:
  const std::string& _internal_playertoken() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_playertoken(
      const std::string& value);
  std::string* _internal_mutable_playertoken();

  public:
  // @@protoc_insertion_point(class_scope:rtech.liveapi.CustomMatch_LobbyPlayers)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      58, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField< ::rtech::liveapi::CustomMatch_LobbyPlayer > players_;
    ::google::protobuf::internal::ArenaStringPtr playertoken_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_events_2eproto;
};// -------------------------------------------------------------------

class ZiplineUsed final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rtech.liveapi.ZiplineUsed) */ {
 public:
  inline ZiplineUsed() : ZiplineUsed(nullptr) {}
  ~ZiplineUsed() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ZiplineUsed(::google::protobuf::internal::ConstantInitialized);

  inline ZiplineUsed(const ZiplineUsed& from)
      : ZiplineUsed(nullptr, from) {}
  ZiplineUsed(ZiplineUsed&& from) noexcept
    : ZiplineUsed() {
    *this = ::std::move(from);
  }

  inline ZiplineUsed& operator=(const ZiplineUsed& from) {
    CopyFrom(from);
    return *this;
  }
  inline ZiplineUsed& operator=(ZiplineUsed&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ZiplineUsed& default_instance() {
    return *internal_default_instance();
  }
  static inline const ZiplineUsed* internal_default_instance() {
    return reinterpret_cast<const ZiplineUsed*>(
               &_ZiplineUsed_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    38;

  friend void swap(ZiplineUsed& a, ZiplineUsed& b) {
    a.Swap(&b);
  }
  inline void Swap(ZiplineUsed* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ZiplineUsed* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ZiplineUsed* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ZiplineUsed>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ZiplineUsed& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ZiplineUsed& from) {
    ZiplineUsed::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ZiplineUsed* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "rtech.liveapi.ZiplineUsed";
  }
  protected:
  explicit ZiplineUsed(::google::protobuf::Arena* arena);
  ZiplineUsed(::google::protobuf::Arena* arena, const ZiplineUsed& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCategoryFieldNumber = 2,
    kLinkedEntityFieldNumber = 4,
    kPlayerFieldNumber = 3,
    kTimestampFieldNumber = 1,
  };
  // string category = 2;
  void clear_category() ;
  const std::string& category() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_category(Arg_&& arg, Args_... args);
  std::string* mutable_category();
  PROTOBUF_NODISCARD std::string* release_category();
  void set_allocated_category(std::string* value);

  private:
  const std::string& _internal_category() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_category(
      const std::string& value);
  std::string* _internal_mutable_category();

  public:
  // string linkedEntity = 4;
  void clear_linkedentity() ;
  const std::string& linkedentity() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_linkedentity(Arg_&& arg, Args_... args);
  std::string* mutable_linkedentity();
  PROTOBUF_NODISCARD std::string* release_linkedentity();
  void set_allocated_linkedentity(std::string* value);

  private:
  const std::string& _internal_linkedentity() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_linkedentity(
      const std::string& value);
  std::string* _internal_mutable_linkedentity();

  public:
  // .rtech.liveapi.Player player = 3;
  bool has_player() const;
  void clear_player() ;
  const ::rtech::liveapi::Player& player() const;
  PROTOBUF_NODISCARD ::rtech::liveapi::Player* release_player();
  ::rtech::liveapi::Player* mutable_player();
  void set_allocated_player(::rtech::liveapi::Player* value);
  void unsafe_arena_set_allocated_player(::rtech::liveapi::Player* value);
  ::rtech::liveapi::Player* unsafe_arena_release_player();

  private:
  const ::rtech::liveapi::Player& _internal_player() const;
  ::rtech::liveapi::Player* _internal_mutable_player();

  public:
  // uint64 timestamp = 1;
  void clear_timestamp() ;
  ::uint64_t timestamp() const;
  void set_timestamp(::uint64_t value);

  private:
  ::uint64_t _internal_timestamp() const;
  void _internal_set_timestamp(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:rtech.liveapi.ZiplineUsed)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 1,
      54, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr category_;
    ::google::protobuf::internal::ArenaStringPtr linkedentity_;
    ::rtech::liveapi::Player* player_;
    ::uint64_t timestamp_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_events_2eproto;
};// -------------------------------------------------------------------

class WraithPortal final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rtech.liveapi.WraithPortal) */ {
 public:
  inline WraithPortal() : WraithPortal(nullptr) {}
  ~WraithPortal() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR WraithPortal(::google::protobuf::internal::ConstantInitialized);

  inline WraithPortal(const WraithPortal& from)
      : WraithPortal(nullptr, from) {}
  WraithPortal(WraithPortal&& from) noexcept
    : WraithPortal() {
    *this = ::std::move(from);
  }

  inline WraithPortal& operator=(const WraithPortal& from) {
    CopyFrom(from);
    return *this;
  }
  inline WraithPortal& operator=(WraithPortal&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WraithPortal& default_instance() {
    return *internal_default_instance();
  }
  static inline const WraithPortal* internal_default_instance() {
    return reinterpret_cast<const WraithPortal*>(
               &_WraithPortal_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    41;

  friend void swap(WraithPortal& a, WraithPortal& b) {
    a.Swap(&b);
  }
  inline void Swap(WraithPortal* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WraithPortal* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WraithPortal* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WraithPortal>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const WraithPortal& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const WraithPortal& from) {
    WraithPortal::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(WraithPortal* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "rtech.liveapi.WraithPortal";
  }
  protected:
  explicit WraithPortal(::google::protobuf::Arena* arena);
  WraithPortal(::google::protobuf::Arena* arena, const WraithPortal& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCategoryFieldNumber = 2,
    kPlayerFieldNumber = 3,
    kTimestampFieldNumber = 1,
  };
  // string category = 2;
  void clear_category() ;
  const std::string& category() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_category(Arg_&& arg, Args_... args);
  std::string* mutable_category();
  PROTOBUF_NODISCARD std::string* release_category();
  void set_allocated_category(std::string* value);

  private:
  const std::string& _internal_category() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_category(
      const std::string& value);
  std::string* _internal_mutable_category();

  public:
  // .rtech.liveapi.Player player = 3;
  bool has_player() const;
  void clear_player() ;
  const ::rtech::liveapi::Player& player() const;
  PROTOBUF_NODISCARD ::rtech::liveapi::Player* release_player();
  ::rtech::liveapi::Player* mutable_player();
  void set_allocated_player(::rtech::liveapi::Player* value);
  void unsafe_arena_set_allocated_player(::rtech::liveapi::Player* value);
  ::rtech::liveapi::Player* unsafe_arena_release_player();

  private:
  const ::rtech::liveapi::Player& _internal_player() const;
  ::rtech::liveapi::Player* _internal_mutable_player();

  public:
  // uint64 timestamp = 1;
  void clear_timestamp() ;
  ::uint64_t timestamp() const;
  void set_timestamp(::uint64_t value);

  private:
  ::uint64_t _internal_timestamp() const;
  void _internal_set_timestamp(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:rtech.liveapi.WraithPortal)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      43, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr category_;
    ::rtech::liveapi::Player* player_;
    ::uint64_t timestamp_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_events_2eproto;
};// -------------------------------------------------------------------

class WeaponSwitched final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rtech.liveapi.WeaponSwitched) */ {
 public:
  inline WeaponSwitched() : WeaponSwitched(nullptr) {}
  ~WeaponSwitched() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR WeaponSwitched(::google::protobuf::internal::ConstantInitialized);

  inline WeaponSwitched(const WeaponSwitched& from)
      : WeaponSwitched(nullptr, from) {}
  WeaponSwitched(WeaponSwitched&& from) noexcept
    : WeaponSwitched() {
    *this = ::std::move(from);
  }

  inline WeaponSwitched& operator=(const WeaponSwitched& from) {
    CopyFrom(from);
    return *this;
  }
  inline WeaponSwitched& operator=(WeaponSwitched&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WeaponSwitched& default_instance() {
    return *internal_default_instance();
  }
  static inline const WeaponSwitched* internal_default_instance() {
    return reinterpret_cast<const WeaponSwitched*>(
               &_WeaponSwitched_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    44;

  friend void swap(WeaponSwitched& a, WeaponSwitched& b) {
    a.Swap(&b);
  }
  inline void Swap(WeaponSwitched* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WeaponSwitched* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WeaponSwitched* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WeaponSwitched>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const WeaponSwitched& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const WeaponSwitched& from) {
    WeaponSwitched::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(WeaponSwitched* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "rtech.liveapi.WeaponSwitched";
  }
  protected:
  explicit WeaponSwitched(::google::protobuf::Arena* arena);
  WeaponSwitched(::google::protobuf::Arena* arena, const WeaponSwitched& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCategoryFieldNumber = 2,
    kOldWeaponFieldNumber = 4,
    kNewWeaponFieldNumber = 5,
    kPlayerFieldNumber = 3,
    kTimestampFieldNumber = 1,
  };
  // string category = 2;
  void clear_category() ;
  const std::string& category() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_category(Arg_&& arg, Args_... args);
  std::string* mutable_category();
  PROTOBUF_NODISCARD std::string* release_category();
  void set_allocated_category(std::string* value);

  private:
  const std::string& _internal_category() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_category(
      const std::string& value);
  std::string* _internal_mutable_category();

  public:
  // string oldWeapon = 4;
  void clear_oldweapon() ;
  const std::string& oldweapon() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_oldweapon(Arg_&& arg, Args_... args);
  std::string* mutable_oldweapon();
  PROTOBUF_NODISCARD std::string* release_oldweapon();
  void set_allocated_oldweapon(std::string* value);

  private:
  const std::string& _internal_oldweapon() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_oldweapon(
      const std::string& value);
  std::string* _internal_mutable_oldweapon();

  public:
  // string newWeapon = 5;
  void clear_newweapon() ;
  const std::string& newweapon() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_newweapon(Arg_&& arg, Args_... args);
  std::string* mutable_newweapon();
  PROTOBUF_NODISCARD std::string* release_newweapon();
  void set_allocated_newweapon(std::string* value);

  private:
  const std::string& _internal_newweapon() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_newweapon(
      const std::string& value);
  std::string* _internal_mutable_newweapon();

  public:
  // .rtech.liveapi.Player player = 3;
  bool has_player() const;
  void clear_player() ;
  const ::rtech::liveapi::Player& player() const;
  PROTOBUF_NODISCARD ::rtech::liveapi::Player* release_player();
  ::rtech::liveapi::Player* mutable_player();
  void set_allocated_player(::rtech::liveapi::Player* value);
  void unsafe_arena_set_allocated_player(::rtech::liveapi::Player* value);
  ::rtech::liveapi::Player* unsafe_arena_release_player();

  private:
  const ::rtech::liveapi::Player& _internal_player() const;
  ::rtech::liveapi::Player* _internal_mutable_player();

  public:
  // uint64 timestamp = 1;
  void clear_timestamp() ;
  ::uint64_t timestamp() const;
  void set_timestamp(::uint64_t value);

  private:
  ::uint64_t _internal_timestamp() const;
  void _internal_set_timestamp(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:rtech.liveapi.WeaponSwitched)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 1,
      63, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr category_;
    ::google::protobuf::internal::ArenaStringPtr oldweapon_;
    ::google::protobuf::internal::ArenaStringPtr newweapon_;
    ::rtech::liveapi::Player* player_;
    ::uint64_t timestamp_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_events_2eproto;
};// -------------------------------------------------------------------

class WarpGateUsed final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rtech.liveapi.WarpGateUsed) */ {
 public:
  inline WarpGateUsed() : WarpGateUsed(nullptr) {}
  ~WarpGateUsed() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR WarpGateUsed(::google::protobuf::internal::ConstantInitialized);

  inline WarpGateUsed(const WarpGateUsed& from)
      : WarpGateUsed(nullptr, from) {}
  WarpGateUsed(WarpGateUsed&& from) noexcept
    : WarpGateUsed() {
    *this = ::std::move(from);
  }

  inline WarpGateUsed& operator=(const WarpGateUsed& from) {
    CopyFrom(from);
    return *this;
  }
  inline WarpGateUsed& operator=(WarpGateUsed&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WarpGateUsed& default_instance() {
    return *internal_default_instance();
  }
  static inline const WarpGateUsed* internal_default_instance() {
    return reinterpret_cast<const WarpGateUsed*>(
               &_WarpGateUsed_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    42;

  friend void swap(WarpGateUsed& a, WarpGateUsed& b) {
    a.Swap(&b);
  }
  inline void Swap(WarpGateUsed* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WarpGateUsed* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WarpGateUsed* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WarpGateUsed>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const WarpGateUsed& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const WarpGateUsed& from) {
    WarpGateUsed::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(WarpGateUsed* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "rtech.liveapi.WarpGateUsed";
  }
  protected:
  explicit WarpGateUsed(::google::protobuf::Arena* arena);
  WarpGateUsed(::google::protobuf::Arena* arena, const WarpGateUsed& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCategoryFieldNumber = 2,
    kPlayerFieldNumber = 3,
    kTimestampFieldNumber = 1,
  };
  // string category = 2;
  void clear_category() ;
  const std::string& category() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_category(Arg_&& arg, Args_... args);
  std::string* mutable_category();
  PROTOBUF_NODISCARD std::string* release_category();
  void set_allocated_category(std::string* value);

  private:
  const std::string& _internal_category() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_category(
      const std::string& value);
  std::string* _internal_mutable_category();

  public:
  // .rtech.liveapi.Player player = 3;
  bool has_player() const;
  void clear_player() ;
  const ::rtech::liveapi::Player& player() const;
  PROTOBUF_NODISCARD ::rtech::liveapi::Player* release_player();
  ::rtech::liveapi::Player* mutable_player();
  void set_allocated_player(::rtech::liveapi::Player* value);
  void unsafe_arena_set_allocated_player(::rtech::liveapi::Player* value);
  ::rtech::liveapi::Player* unsafe_arena_release_player();

  private:
  const ::rtech::liveapi::Player& _internal_player() const;
  ::rtech::liveapi::Player* _internal_mutable_player();

  public:
  // uint64 timestamp = 1;
  void clear_timestamp() ;
  ::uint64_t timestamp() const;
  void set_timestamp(::uint64_t value);

  private:
  ::uint64_t _internal_timestamp() const;
  void _internal_set_timestamp(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:rtech.liveapi.WarpGateUsed)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      43, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr category_;
    ::rtech::liveapi::Player* player_;
    ::uint64_t timestamp_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_events_2eproto;
};// -------------------------------------------------------------------

class SquadEliminated final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rtech.liveapi.SquadEliminated) */ {
 public:
  inline SquadEliminated() : SquadEliminated(nullptr) {}
  ~SquadEliminated() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SquadEliminated(::google::protobuf::internal::ConstantInitialized);

  inline SquadEliminated(const SquadEliminated& from)
      : SquadEliminated(nullptr, from) {}
  SquadEliminated(SquadEliminated&& from) noexcept
    : SquadEliminated() {
    *this = ::std::move(from);
  }

  inline SquadEliminated& operator=(const SquadEliminated& from) {
    CopyFrom(from);
    return *this;
  }
  inline SquadEliminated& operator=(SquadEliminated&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SquadEliminated& default_instance() {
    return *internal_default_instance();
  }
  static inline const SquadEliminated* internal_default_instance() {
    return reinterpret_cast<const SquadEliminated*>(
               &_SquadEliminated_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(SquadEliminated& a, SquadEliminated& b) {
    a.Swap(&b);
  }
  inline void Swap(SquadEliminated* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SquadEliminated* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SquadEliminated* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SquadEliminated>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SquadEliminated& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SquadEliminated& from) {
    SquadEliminated::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(SquadEliminated* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "rtech.liveapi.SquadEliminated";
  }
  protected:
  explicit SquadEliminated(::google::protobuf::Arena* arena);
  SquadEliminated(::google::protobuf::Arena* arena, const SquadEliminated& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayersFieldNumber = 3,
    kCategoryFieldNumber = 2,
    kTimestampFieldNumber = 1,
  };
  // repeated .rtech.liveapi.Player players = 3;
  int players_size() const;
  private:
  int _internal_players_size() const;

  public:
  void clear_players() ;
  ::rtech::liveapi::Player* mutable_players(int index);
  ::google::protobuf::RepeatedPtrField< ::rtech::liveapi::Player >*
      mutable_players();
  private:
  const ::google::protobuf::RepeatedPtrField<::rtech::liveapi::Player>& _internal_players() const;
  ::google::protobuf::RepeatedPtrField<::rtech::liveapi::Player>* _internal_mutable_players();
  public:
  const ::rtech::liveapi::Player& players(int index) const;
  ::rtech::liveapi::Player* add_players();
  const ::google::protobuf::RepeatedPtrField< ::rtech::liveapi::Player >&
      players() const;
  // string category = 2;
  void clear_category() ;
  const std::string& category() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_category(Arg_&& arg, Args_... args);
  std::string* mutable_category();
  PROTOBUF_NODISCARD std::string* release_category();
  void set_allocated_category(std::string* value);

  private:
  const std::string& _internal_category() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_category(
      const std::string& value);
  std::string* _internal_mutable_category();

  public:
  // uint64 timestamp = 1;
  void clear_timestamp() ;
  ::uint64_t timestamp() const;
  void set_timestamp(::uint64_t value);

  private:
  ::uint64_t _internal_timestamp() const;
  void _internal_set_timestamp(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:rtech.liveapi.SquadEliminated)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      46, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField< ::rtech::liveapi::Player > players_;
    ::google::protobuf::internal::ArenaStringPtr category_;
    ::uint64_t timestamp_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_events_2eproto;
};// -------------------------------------------------------------------

class RevenantForgedShadowDamaged final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rtech.liveapi.RevenantForgedShadowDamaged) */ {
 public:
  inline RevenantForgedShadowDamaged() : RevenantForgedShadowDamaged(nullptr) {}
  ~RevenantForgedShadowDamaged() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RevenantForgedShadowDamaged(::google::protobuf::internal::ConstantInitialized);

  inline RevenantForgedShadowDamaged(const RevenantForgedShadowDamaged& from)
      : RevenantForgedShadowDamaged(nullptr, from) {}
  RevenantForgedShadowDamaged(RevenantForgedShadowDamaged&& from) noexcept
    : RevenantForgedShadowDamaged() {
    *this = ::std::move(from);
  }

  inline RevenantForgedShadowDamaged& operator=(const RevenantForgedShadowDamaged& from) {
    CopyFrom(from);
    return *this;
  }
  inline RevenantForgedShadowDamaged& operator=(RevenantForgedShadowDamaged&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RevenantForgedShadowDamaged& default_instance() {
    return *internal_default_instance();
  }
  static inline const RevenantForgedShadowDamaged* internal_default_instance() {
    return reinterpret_cast<const RevenantForgedShadowDamaged*>(
               &_RevenantForgedShadowDamaged_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(RevenantForgedShadowDamaged& a, RevenantForgedShadowDamaged& b) {
    a.Swap(&b);
  }
  inline void Swap(RevenantForgedShadowDamaged* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RevenantForgedShadowDamaged* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RevenantForgedShadowDamaged* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RevenantForgedShadowDamaged>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RevenantForgedShadowDamaged& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const RevenantForgedShadowDamaged& from) {
    RevenantForgedShadowDamaged::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RevenantForgedShadowDamaged* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "rtech.liveapi.RevenantForgedShadowDamaged";
  }
  protected:
  explicit RevenantForgedShadowDamaged(::google::protobuf::Arena* arena);
  RevenantForgedShadowDamaged(::google::protobuf::Arena* arena, const RevenantForgedShadowDamaged& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCategoryFieldNumber = 2,
    kAttackerFieldNumber = 3,
    kVictimFieldNumber = 4,
    kTimestampFieldNumber = 1,
    kDamageInflictedFieldNumber = 6,
  };
  // string category = 2;
  void clear_category() ;
  const std::string& category() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_category(Arg_&& arg, Args_... args);
  std::string* mutable_category();
  PROTOBUF_NODISCARD std::string* release_category();
  void set_allocated_category(std::string* value);

  private:
  const std::string& _internal_category() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_category(
      const std::string& value);
  std::string* _internal_mutable_category();

  public:
  // .rtech.liveapi.Player attacker = 3;
  bool has_attacker() const;
  void clear_attacker() ;
  const ::rtech::liveapi::Player& attacker() const;
  PROTOBUF_NODISCARD ::rtech::liveapi::Player* release_attacker();
  ::rtech::liveapi::Player* mutable_attacker();
  void set_allocated_attacker(::rtech::liveapi::Player* value);
  void unsafe_arena_set_allocated_attacker(::rtech::liveapi::Player* value);
  ::rtech::liveapi::Player* unsafe_arena_release_attacker();

  private:
  const ::rtech::liveapi::Player& _internal_attacker() const;
  ::rtech::liveapi::Player* _internal_mutable_attacker();

  public:
  // .rtech.liveapi.Player victim = 4;
  bool has_victim() const;
  void clear_victim() ;
  const ::rtech::liveapi::Player& victim() const;
  PROTOBUF_NODISCARD ::rtech::liveapi::Player* release_victim();
  ::rtech::liveapi::Player* mutable_victim();
  void set_allocated_victim(::rtech::liveapi::Player* value);
  void unsafe_arena_set_allocated_victim(::rtech::liveapi::Player* value);
  ::rtech::liveapi::Player* unsafe_arena_release_victim();

  private:
  const ::rtech::liveapi::Player& _internal_victim() const;
  ::rtech::liveapi::Player* _internal_mutable_victim();

  public:
  // uint64 timestamp = 1;
  void clear_timestamp() ;
  ::uint64_t timestamp() const;
  void set_timestamp(::uint64_t value);

  private:
  ::uint64_t _internal_timestamp() const;
  void _internal_set_timestamp(::uint64_t value);

  public:
  // uint32 damageInflicted = 6;
  void clear_damageinflicted() ;
  ::uint32_t damageinflicted() const;
  void set_damageinflicted(::uint32_t value);

  private:
  ::uint32_t _internal_damageinflicted() const;
  void _internal_set_damageinflicted(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:rtech.liveapi.RevenantForgedShadowDamaged)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 2,
      58, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr category_;
    ::rtech::liveapi::Player* attacker_;
    ::rtech::liveapi::Player* victim_;
    ::uint64_t timestamp_;
    ::uint32_t damageinflicted_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_events_2eproto;
};// -------------------------------------------------------------------

class PlayerUpgradeTierChanged final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rtech.liveapi.PlayerUpgradeTierChanged) */ {
 public:
  inline PlayerUpgradeTierChanged() : PlayerUpgradeTierChanged(nullptr) {}
  ~PlayerUpgradeTierChanged() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR PlayerUpgradeTierChanged(::google::protobuf::internal::ConstantInitialized);

  inline PlayerUpgradeTierChanged(const PlayerUpgradeTierChanged& from)
      : PlayerUpgradeTierChanged(nullptr, from) {}
  PlayerUpgradeTierChanged(PlayerUpgradeTierChanged&& from) noexcept
    : PlayerUpgradeTierChanged() {
    *this = ::std::move(from);
  }

  inline PlayerUpgradeTierChanged& operator=(const PlayerUpgradeTierChanged& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayerUpgradeTierChanged& operator=(PlayerUpgradeTierChanged&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlayerUpgradeTierChanged& default_instance() {
    return *internal_default_instance();
  }
  static inline const PlayerUpgradeTierChanged* internal_default_instance() {
    return reinterpret_cast<const PlayerUpgradeTierChanged*>(
               &_PlayerUpgradeTierChanged_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(PlayerUpgradeTierChanged& a, PlayerUpgradeTierChanged& b) {
    a.Swap(&b);
  }
  inline void Swap(PlayerUpgradeTierChanged* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlayerUpgradeTierChanged* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PlayerUpgradeTierChanged* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PlayerUpgradeTierChanged>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PlayerUpgradeTierChanged& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const PlayerUpgradeTierChanged& from) {
    PlayerUpgradeTierChanged::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(PlayerUpgradeTierChanged* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "rtech.liveapi.PlayerUpgradeTierChanged";
  }
  protected:
  explicit PlayerUpgradeTierChanged(::google::protobuf::Arena* arena);
  PlayerUpgradeTierChanged(::google::protobuf::Arena* arena, const PlayerUpgradeTierChanged& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCategoryFieldNumber = 2,
    kPlayerFieldNumber = 3,
    kTimestampFieldNumber = 1,
    kLevelFieldNumber = 4,
  };
  // string category = 2;
  void clear_category() ;
  const std::string& category() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_category(Arg_&& arg, Args_... args);
  std::string* mutable_category();
  PROTOBUF_NODISCARD std::string* release_category();
  void set_allocated_category(std::string* value);

  private:
  const std::string& _internal_category() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_category(
      const std::string& value);
  std::string* _internal_mutable_category();

  public:
  // .rtech.liveapi.Player player = 3;
  bool has_player() const;
  void clear_player() ;
  const ::rtech::liveapi::Player& player() const;
  PROTOBUF_NODISCARD ::rtech::liveapi::Player* release_player();
  ::rtech::liveapi::Player* mutable_player();
  void set_allocated_player(::rtech::liveapi::Player* value);
  void unsafe_arena_set_allocated_player(::rtech::liveapi::Player* value);
  ::rtech::liveapi::Player* unsafe_arena_release_player();

  private:
  const ::rtech::liveapi::Player& _internal_player() const;
  ::rtech::liveapi::Player* _internal_mutable_player();

  public:
  // uint64 timestamp = 1;
  void clear_timestamp() ;
  ::uint64_t timestamp() const;
  void set_timestamp(::uint64_t value);

  private:
  ::uint64_t _internal_timestamp() const;
  void _internal_set_timestamp(::uint64_t value);

  public:
  // int32 level = 4;
  void clear_level() ;
  ::int32_t level() const;
  void set_level(::int32_t value);

  private:
  ::int32_t _internal_level() const;
  void _internal_set_level(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:rtech.liveapi.PlayerUpgradeTierChanged)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 1,
      55, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr category_;
    ::rtech::liveapi::Player* player_;
    ::uint64_t timestamp_;
    ::int32_t level_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_events_2eproto;
};// -------------------------------------------------------------------

class PlayerStatChanged final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rtech.liveapi.PlayerStatChanged) */ {
 public:
  inline PlayerStatChanged() : PlayerStatChanged(nullptr) {}
  ~PlayerStatChanged() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR PlayerStatChanged(::google::protobuf::internal::ConstantInitialized);

  inline PlayerStatChanged(const PlayerStatChanged& from)
      : PlayerStatChanged(nullptr, from) {}
  PlayerStatChanged(PlayerStatChanged&& from) noexcept
    : PlayerStatChanged() {
    *this = ::std::move(from);
  }

  inline PlayerStatChanged& operator=(const PlayerStatChanged& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayerStatChanged& operator=(PlayerStatChanged&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlayerStatChanged& default_instance() {
    return *internal_default_instance();
  }
  static inline const PlayerStatChanged* internal_default_instance() {
    return reinterpret_cast<const PlayerStatChanged*>(
               &_PlayerStatChanged_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(PlayerStatChanged& a, PlayerStatChanged& b) {
    a.Swap(&b);
  }
  inline void Swap(PlayerStatChanged* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlayerStatChanged* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PlayerStatChanged* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PlayerStatChanged>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PlayerStatChanged& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const PlayerStatChanged& from) {
    PlayerStatChanged::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(PlayerStatChanged* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "rtech.liveapi.PlayerStatChanged";
  }
  protected:
  explicit PlayerStatChanged(::google::protobuf::Arena* arena);
  PlayerStatChanged(::google::protobuf::Arena* arena, const PlayerStatChanged& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCategoryFieldNumber = 2,
    kStatNameFieldNumber = 4,
    kPlayerFieldNumber = 3,
    kTimestampFieldNumber = 1,
    kNewValueFieldNumber = 5,
  };
  // string category = 2;
  void clear_category() ;
  const std::string& category() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_category(Arg_&& arg, Args_... args);
  std::string* mutable_category();
  PROTOBUF_NODISCARD std::string* release_category();
  void set_allocated_category(std::string* value);

  private:
  const std::string& _internal_category() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_category(
      const std::string& value);
  std::string* _internal_mutable_category();

  public:
  // string statName = 4;
  void clear_statname() ;
  const std::string& statname() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_statname(Arg_&& arg, Args_... args);
  std::string* mutable_statname();
  PROTOBUF_NODISCARD std::string* release_statname();
  void set_allocated_statname(std::string* value);

  private:
  const std::string& _internal_statname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_statname(
      const std::string& value);
  std::string* _internal_mutable_statname();

  public:
  // .rtech.liveapi.Player player = 3;
  bool has_player() const;
  void clear_player() ;
  const ::rtech::liveapi::Player& player() const;
  PROTOBUF_NODISCARD ::rtech::liveapi::Player* release_player();
  ::rtech::liveapi::Player* mutable_player();
  void set_allocated_player(::rtech::liveapi::Player* value);
  void unsafe_arena_set_allocated_player(::rtech::liveapi::Player* value);
  ::rtech::liveapi::Player* unsafe_arena_release_player();

  private:
  const ::rtech::liveapi::Player& _internal_player() const;
  ::rtech::liveapi::Player* _internal_mutable_player();

  public:
  // uint64 timestamp = 1;
  void clear_timestamp() ;
  ::uint64_t timestamp() const;
  void set_timestamp(::uint64_t value);

  private:
  ::uint64_t _internal_timestamp() const;
  void _internal_set_timestamp(::uint64_t value);

  public:
  // uint32 newValue = 5;
  void clear_newvalue() ;
  ::uint32_t newvalue() const;
  void set_newvalue(::uint32_t value);

  private:
  ::uint32_t _internal_newvalue() const;
  void _internal_set_newvalue(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:rtech.liveapi.PlayerStatChanged)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 1,
      56, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr category_;
    ::google::protobuf::internal::ArenaStringPtr statname_;
    ::rtech::liveapi::Player* player_;
    ::uint64_t timestamp_;
    ::uint32_t newvalue_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_events_2eproto;
};// -------------------------------------------------------------------

class PlayerRevive final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rtech.liveapi.PlayerRevive) */ {
 public:
  inline PlayerRevive() : PlayerRevive(nullptr) {}
  ~PlayerRevive() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR PlayerRevive(::google::protobuf::internal::ConstantInitialized);

  inline PlayerRevive(const PlayerRevive& from)
      : PlayerRevive(nullptr, from) {}
  PlayerRevive(PlayerRevive&& from) noexcept
    : PlayerRevive() {
    *this = ::std::move(from);
  }

  inline PlayerRevive& operator=(const PlayerRevive& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayerRevive& operator=(PlayerRevive&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlayerRevive& default_instance() {
    return *internal_default_instance();
  }
  static inline const PlayerRevive* internal_default_instance() {
    return reinterpret_cast<const PlayerRevive*>(
               &_PlayerRevive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(PlayerRevive& a, PlayerRevive& b) {
    a.Swap(&b);
  }
  inline void Swap(PlayerRevive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlayerRevive* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PlayerRevive* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PlayerRevive>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PlayerRevive& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const PlayerRevive& from) {
    PlayerRevive::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(PlayerRevive* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "rtech.liveapi.PlayerRevive";
  }
  protected:
  explicit PlayerRevive(::google::protobuf::Arena* arena);
  PlayerRevive(::google::protobuf::Arena* arena, const PlayerRevive& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCategoryFieldNumber = 2,
    kPlayerFieldNumber = 3,
    kRevivedFieldNumber = 4,
    kTimestampFieldNumber = 1,
  };
  // string category = 2;
  void clear_category() ;
  const std::string& category() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_category(Arg_&& arg, Args_... args);
  std::string* mutable_category();
  PROTOBUF_NODISCARD std::string* release_category();
  void set_allocated_category(std::string* value);

  private:
  const std::string& _internal_category() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_category(
      const std::string& value);
  std::string* _internal_mutable_category();

  public:
  // .rtech.liveapi.Player player = 3;
  bool has_player() const;
  void clear_player() ;
  const ::rtech::liveapi::Player& player() const;
  PROTOBUF_NODISCARD ::rtech::liveapi::Player* release_player();
  ::rtech::liveapi::Player* mutable_player();
  void set_allocated_player(::rtech::liveapi::Player* value);
  void unsafe_arena_set_allocated_player(::rtech::liveapi::Player* value);
  ::rtech::liveapi::Player* unsafe_arena_release_player();

  private:
  const ::rtech::liveapi::Player& _internal_player() const;
  ::rtech::liveapi::Player* _internal_mutable_player();

  public:
  // .rtech.liveapi.Player revived = 4;
  bool has_revived() const;
  void clear_revived() ;
  const ::rtech::liveapi::Player& revived() const;
  PROTOBUF_NODISCARD ::rtech::liveapi::Player* release_revived();
  ::rtech::liveapi::Player* mutable_revived();
  void set_allocated_revived(::rtech::liveapi::Player* value);
  void unsafe_arena_set_allocated_revived(::rtech::liveapi::Player* value);
  ::rtech::liveapi::Player* unsafe_arena_release_revived();

  private:
  const ::rtech::liveapi::Player& _internal_revived() const;
  ::rtech::liveapi::Player* _internal_mutable_revived();

  public:
  // uint64 timestamp = 1;
  void clear_timestamp() ;
  ::uint64_t timestamp() const;
  void set_timestamp(::uint64_t value);

  private:
  ::uint64_t _internal_timestamp() const;
  void _internal_set_timestamp(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:rtech.liveapi.PlayerRevive)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 2,
      43, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr category_;
    ::rtech::liveapi::Player* player_;
    ::rtech::liveapi::Player* revived_;
    ::uint64_t timestamp_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_events_2eproto;
};// -------------------------------------------------------------------

class PlayerRespawnTeam final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rtech.liveapi.PlayerRespawnTeam) */ {
 public:
  inline PlayerRespawnTeam() : PlayerRespawnTeam(nullptr) {}
  ~PlayerRespawnTeam() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR PlayerRespawnTeam(::google::protobuf::internal::ConstantInitialized);

  inline PlayerRespawnTeam(const PlayerRespawnTeam& from)
      : PlayerRespawnTeam(nullptr, from) {}
  PlayerRespawnTeam(PlayerRespawnTeam&& from) noexcept
    : PlayerRespawnTeam() {
    *this = ::std::move(from);
  }

  inline PlayerRespawnTeam& operator=(const PlayerRespawnTeam& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayerRespawnTeam& operator=(PlayerRespawnTeam&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlayerRespawnTeam& default_instance() {
    return *internal_default_instance();
  }
  static inline const PlayerRespawnTeam* internal_default_instance() {
    return reinterpret_cast<const PlayerRespawnTeam*>(
               &_PlayerRespawnTeam_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(PlayerRespawnTeam& a, PlayerRespawnTeam& b) {
    a.Swap(&b);
  }
  inline void Swap(PlayerRespawnTeam* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlayerRespawnTeam* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PlayerRespawnTeam* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PlayerRespawnTeam>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PlayerRespawnTeam& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const PlayerRespawnTeam& from) {
    PlayerRespawnTeam::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(PlayerRespawnTeam* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "rtech.liveapi.PlayerRespawnTeam";
  }
  protected:
  explicit PlayerRespawnTeam(::google::protobuf::Arena* arena);
  PlayerRespawnTeam(::google::protobuf::Arena* arena, const PlayerRespawnTeam& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCategoryFieldNumber = 2,
    kRespawnedFieldNumber = 4,
    kPlayerFieldNumber = 3,
    kTimestampFieldNumber = 1,
  };
  // string category = 2;
  void clear_category() ;
  const std::string& category() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_category(Arg_&& arg, Args_... args);
  std::string* mutable_category();
  PROTOBUF_NODISCARD std::string* release_category();
  void set_allocated_category(std::string* value);

  private:
  const std::string& _internal_category() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_category(
      const std::string& value);
  std::string* _internal_mutable_category();

  public:
  // string respawned = 4;
  void clear_respawned() ;
  const std::string& respawned() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_respawned(Arg_&& arg, Args_... args);
  std::string* mutable_respawned();
  PROTOBUF_NODISCARD std::string* release_respawned();
  void set_allocated_respawned(std::string* value);

  private:
  const std::string& _internal_respawned() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_respawned(
      const std::string& value);
  std::string* _internal_mutable_respawned();

  public:
  // .rtech.liveapi.Player player = 3;
  bool has_player() const;
  void clear_player() ;
  const ::rtech::liveapi::Player& player() const;
  PROTOBUF_NODISCARD ::rtech::liveapi::Player* release_player();
  ::rtech::liveapi::Player* mutable_player();
  void set_allocated_player(::rtech::liveapi::Player* value);
  void unsafe_arena_set_allocated_player(::rtech::liveapi::Player* value);
  ::rtech::liveapi::Player* unsafe_arena_release_player();

  private:
  const ::rtech::liveapi::Player& _internal_player() const;
  ::rtech::liveapi::Player* _internal_mutable_player();

  public:
  // uint64 timestamp = 1;
  void clear_timestamp() ;
  ::uint64_t timestamp() const;
  void set_timestamp(::uint64_t value);

  private:
  ::uint64_t _internal_timestamp() const;
  void _internal_set_timestamp(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:rtech.liveapi.PlayerRespawnTeam)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 1,
      57, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr category_;
    ::google::protobuf::internal::ArenaStringPtr respawned_;
    ::rtech::liveapi::Player* player_;
    ::uint64_t timestamp_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_events_2eproto;
};// -------------------------------------------------------------------

class PlayerKilled final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rtech.liveapi.PlayerKilled) */ {
 public:
  inline PlayerKilled() : PlayerKilled(nullptr) {}
  ~PlayerKilled() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR PlayerKilled(::google::protobuf::internal::ConstantInitialized);

  inline PlayerKilled(const PlayerKilled& from)
      : PlayerKilled(nullptr, from) {}
  PlayerKilled(PlayerKilled&& from) noexcept
    : PlayerKilled() {
    *this = ::std::move(from);
  }

  inline PlayerKilled& operator=(const PlayerKilled& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayerKilled& operator=(PlayerKilled&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlayerKilled& default_instance() {
    return *internal_default_instance();
  }
  static inline const PlayerKilled* internal_default_instance() {
    return reinterpret_cast<const PlayerKilled*>(
               &_PlayerKilled_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(PlayerKilled& a, PlayerKilled& b) {
    a.Swap(&b);
  }
  inline void Swap(PlayerKilled* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlayerKilled* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PlayerKilled* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PlayerKilled>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PlayerKilled& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const PlayerKilled& from) {
    PlayerKilled::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(PlayerKilled* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "rtech.liveapi.PlayerKilled";
  }
  protected:
  explicit PlayerKilled(::google::protobuf::Arena* arena);
  PlayerKilled(::google::protobuf::Arena* arena, const PlayerKilled& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCategoryFieldNumber = 2,
    kWeaponFieldNumber = 6,
    kAttackerFieldNumber = 3,
    kVictimFieldNumber = 4,
    kTimestampFieldNumber = 1,
  };
  // string category = 2;
  void clear_category() ;
  const std::string& category() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_category(Arg_&& arg, Args_... args);
  std::string* mutable_category();
  PROTOBUF_NODISCARD std::string* release_category();
  void set_allocated_category(std::string* value);

  private:
  const std::string& _internal_category() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_category(
      const std::string& value);
  std::string* _internal_mutable_category();

  public:
  // string weapon = 6;
  void clear_weapon() ;
  const std::string& weapon() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_weapon(Arg_&& arg, Args_... args);
  std::string* mutable_weapon();
  PROTOBUF_NODISCARD std::string* release_weapon();
  void set_allocated_weapon(std::string* value);

  private:
  const std::string& _internal_weapon() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_weapon(
      const std::string& value);
  std::string* _internal_mutable_weapon();

  public:
  // .rtech.liveapi.Player attacker = 3;
  bool has_attacker() const;
  void clear_attacker() ;
  const ::rtech::liveapi::Player& attacker() const;
  PROTOBUF_NODISCARD ::rtech::liveapi::Player* release_attacker();
  ::rtech::liveapi::Player* mutable_attacker();
  void set_allocated_attacker(::rtech::liveapi::Player* value);
  void unsafe_arena_set_allocated_attacker(::rtech::liveapi::Player* value);
  ::rtech::liveapi::Player* unsafe_arena_release_attacker();

  private:
  const ::rtech::liveapi::Player& _internal_attacker() const;
  ::rtech::liveapi::Player* _internal_mutable_attacker();

  public:
  // .rtech.liveapi.Player victim = 4;
  bool has_victim() const;
  void clear_victim() ;
  const ::rtech::liveapi::Player& victim() const;
  PROTOBUF_NODISCARD ::rtech::liveapi::Player* release_victim();
  ::rtech::liveapi::Player* mutable_victim();
  void set_allocated_victim(::rtech::liveapi::Player* value);
  void unsafe_arena_set_allocated_victim(::rtech::liveapi::Player* value);
  ::rtech::liveapi::Player* unsafe_arena_release_victim();

  private:
  const ::rtech::liveapi::Player& _internal_victim() const;
  ::rtech::liveapi::Player* _internal_mutable_victim();

  public:
  // uint64 timestamp = 1;
  void clear_timestamp() ;
  ::uint64_t timestamp() const;
  void set_timestamp(::uint64_t value);

  private:
  ::uint64_t _internal_timestamp() const;
  void _internal_set_timestamp(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:rtech.liveapi.PlayerKilled)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 2,
      49, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr category_;
    ::google::protobuf::internal::ArenaStringPtr weapon_;
    ::rtech::liveapi::Player* attacker_;
    ::rtech::liveapi::Player* victim_;
    ::uint64_t timestamp_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_events_2eproto;
};// -------------------------------------------------------------------

class PlayerDowned final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rtech.liveapi.PlayerDowned) */ {
 public:
  inline PlayerDowned() : PlayerDowned(nullptr) {}
  ~PlayerDowned() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR PlayerDowned(::google::protobuf::internal::ConstantInitialized);

  inline PlayerDowned(const PlayerDowned& from)
      : PlayerDowned(nullptr, from) {}
  PlayerDowned(PlayerDowned&& from) noexcept
    : PlayerDowned() {
    *this = ::std::move(from);
  }

  inline PlayerDowned& operator=(const PlayerDowned& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayerDowned& operator=(PlayerDowned&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlayerDowned& default_instance() {
    return *internal_default_instance();
  }
  static inline const PlayerDowned* internal_default_instance() {
    return reinterpret_cast<const PlayerDowned*>(
               &_PlayerDowned_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(PlayerDowned& a, PlayerDowned& b) {
    a.Swap(&b);
  }
  inline void Swap(PlayerDowned* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlayerDowned* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PlayerDowned* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PlayerDowned>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PlayerDowned& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const PlayerDowned& from) {
    PlayerDowned::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(PlayerDowned* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "rtech.liveapi.PlayerDowned";
  }
  protected:
  explicit PlayerDowned(::google::protobuf::Arena* arena);
  PlayerDowned(::google::protobuf::Arena* arena, const PlayerDowned& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCategoryFieldNumber = 2,
    kWeaponFieldNumber = 5,
    kAttackerFieldNumber = 3,
    kVictimFieldNumber = 4,
    kTimestampFieldNumber = 1,
  };
  // string category = 2;
  void clear_category() ;
  const std::string& category() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_category(Arg_&& arg, Args_... args);
  std::string* mutable_category();
  PROTOBUF_NODISCARD std::string* release_category();
  void set_allocated_category(std::string* value);

  private:
  const std::string& _internal_category() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_category(
      const std::string& value);
  std::string* _internal_mutable_category();

  public:
  // string weapon = 5;
  void clear_weapon() ;
  const std::string& weapon() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_weapon(Arg_&& arg, Args_... args);
  std::string* mutable_weapon();
  PROTOBUF_NODISCARD std::string* release_weapon();
  void set_allocated_weapon(std::string* value);

  private:
  const std::string& _internal_weapon() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_weapon(
      const std::string& value);
  std::string* _internal_mutable_weapon();

  public:
  // .rtech.liveapi.Player attacker = 3;
  bool has_attacker() const;
  void clear_attacker() ;
  const ::rtech::liveapi::Player& attacker() const;
  PROTOBUF_NODISCARD ::rtech::liveapi::Player* release_attacker();
  ::rtech::liveapi::Player* mutable_attacker();
  void set_allocated_attacker(::rtech::liveapi::Player* value);
  void unsafe_arena_set_allocated_attacker(::rtech::liveapi::Player* value);
  ::rtech::liveapi::Player* unsafe_arena_release_attacker();

  private:
  const ::rtech::liveapi::Player& _internal_attacker() const;
  ::rtech::liveapi::Player* _internal_mutable_attacker();

  public:
  // .rtech.liveapi.Player victim = 4;
  bool has_victim() const;
  void clear_victim() ;
  const ::rtech::liveapi::Player& victim() const;
  PROTOBUF_NODISCARD ::rtech::liveapi::Player* release_victim();
  ::rtech::liveapi::Player* mutable_victim();
  void set_allocated_victim(::rtech::liveapi::Player* value);
  void unsafe_arena_set_allocated_victim(::rtech::liveapi::Player* value);
  ::rtech::liveapi::Player* unsafe_arena_release_victim();

  private:
  const ::rtech::liveapi::Player& _internal_victim() const;
  ::rtech::liveapi::Player* _internal_mutable_victim();

  public:
  // uint64 timestamp = 1;
  void clear_timestamp() ;
  ::uint64_t timestamp() const;
  void set_timestamp(::uint64_t value);

  private:
  ::uint64_t _internal_timestamp() const;
  void _internal_set_timestamp(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:rtech.liveapi.PlayerDowned)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 2,
      49, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr category_;
    ::google::protobuf::internal::ArenaStringPtr weapon_;
    ::rtech::liveapi::Player* attacker_;
    ::rtech::liveapi::Player* victim_;
    ::uint64_t timestamp_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_events_2eproto;
};// -------------------------------------------------------------------

class PlayerDisconnected final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rtech.liveapi.PlayerDisconnected) */ {
 public:
  inline PlayerDisconnected() : PlayerDisconnected(nullptr) {}
  ~PlayerDisconnected() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR PlayerDisconnected(::google::protobuf::internal::ConstantInitialized);

  inline PlayerDisconnected(const PlayerDisconnected& from)
      : PlayerDisconnected(nullptr, from) {}
  PlayerDisconnected(PlayerDisconnected&& from) noexcept
    : PlayerDisconnected() {
    *this = ::std::move(from);
  }

  inline PlayerDisconnected& operator=(const PlayerDisconnected& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayerDisconnected& operator=(PlayerDisconnected&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlayerDisconnected& default_instance() {
    return *internal_default_instance();
  }
  static inline const PlayerDisconnected* internal_default_instance() {
    return reinterpret_cast<const PlayerDisconnected*>(
               &_PlayerDisconnected_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(PlayerDisconnected& a, PlayerDisconnected& b) {
    a.Swap(&b);
  }
  inline void Swap(PlayerDisconnected* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlayerDisconnected* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PlayerDisconnected* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PlayerDisconnected>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PlayerDisconnected& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const PlayerDisconnected& from) {
    PlayerDisconnected::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(PlayerDisconnected* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "rtech.liveapi.PlayerDisconnected";
  }
  protected:
  explicit PlayerDisconnected(::google::protobuf::Arena* arena);
  PlayerDisconnected(::google::protobuf::Arena* arena, const PlayerDisconnected& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCategoryFieldNumber = 2,
    kPlayerFieldNumber = 3,
    kTimestampFieldNumber = 1,
    kCanReconnectFieldNumber = 4,
    kIsAliveFieldNumber = 5,
  };
  // string category = 2;
  void clear_category() ;
  const std::string& category() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_category(Arg_&& arg, Args_... args);
  std::string* mutable_category();
  PROTOBUF_NODISCARD std::string* release_category();
  void set_allocated_category(std::string* value);

  private:
  const std::string& _internal_category() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_category(
      const std::string& value);
  std::string* _internal_mutable_category();

  public:
  // .rtech.liveapi.Player player = 3;
  bool has_player() const;
  void clear_player() ;
  const ::rtech::liveapi::Player& player() const;
  PROTOBUF_NODISCARD ::rtech::liveapi::Player* release_player();
  ::rtech::liveapi::Player* mutable_player();
  void set_allocated_player(::rtech::liveapi::Player* value);
  void unsafe_arena_set_allocated_player(::rtech::liveapi::Player* value);
  ::rtech::liveapi::Player* unsafe_arena_release_player();

  private:
  const ::rtech::liveapi::Player& _internal_player() const;
  ::rtech::liveapi::Player* _internal_mutable_player();

  public:
  // uint64 timestamp = 1;
  void clear_timestamp() ;
  ::uint64_t timestamp() const;
  void set_timestamp(::uint64_t value);

  private:
  ::uint64_t _internal_timestamp() const;
  void _internal_set_timestamp(::uint64_t value);

  public:
  // bool canReconnect = 4;
  void clear_canreconnect() ;
  bool canreconnect() const;
  void set_canreconnect(bool value);

  private:
  bool _internal_canreconnect() const;
  void _internal_set_canreconnect(bool value);

  public:
  // bool isAlive = 5;
  void clear_isalive() ;
  bool isalive() const;
  void set_isalive(bool value);

  private:
  bool _internal_isalive() const;
  void _internal_set_isalive(bool value);

  public:
  // @@protoc_insertion_point(class_scope:rtech.liveapi.PlayerDisconnected)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 1,
      49, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr category_;
    ::rtech::liveapi::Player* player_;
    ::uint64_t timestamp_;
    bool canreconnect_;
    bool isalive_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_events_2eproto;
};// -------------------------------------------------------------------

class PlayerDamaged final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rtech.liveapi.PlayerDamaged) */ {
 public:
  inline PlayerDamaged() : PlayerDamaged(nullptr) {}
  ~PlayerDamaged() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR PlayerDamaged(::google::protobuf::internal::ConstantInitialized);

  inline PlayerDamaged(const PlayerDamaged& from)
      : PlayerDamaged(nullptr, from) {}
  PlayerDamaged(PlayerDamaged&& from) noexcept
    : PlayerDamaged() {
    *this = ::std::move(from);
  }

  inline PlayerDamaged& operator=(const PlayerDamaged& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayerDamaged& operator=(PlayerDamaged&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlayerDamaged& default_instance() {
    return *internal_default_instance();
  }
  static inline const PlayerDamaged* internal_default_instance() {
    return reinterpret_cast<const PlayerDamaged*>(
               &_PlayerDamaged_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(PlayerDamaged& a, PlayerDamaged& b) {
    a.Swap(&b);
  }
  inline void Swap(PlayerDamaged* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlayerDamaged* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PlayerDamaged* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PlayerDamaged>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PlayerDamaged& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const PlayerDamaged& from) {
    PlayerDamaged::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(PlayerDamaged* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "rtech.liveapi.PlayerDamaged";
  }
  protected:
  explicit PlayerDamaged(::google::protobuf::Arena* arena);
  PlayerDamaged(::google::protobuf::Arena* arena, const PlayerDamaged& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCategoryFieldNumber = 2,
    kWeaponFieldNumber = 5,
    kAttackerFieldNumber = 3,
    kVictimFieldNumber = 4,
    kTimestampFieldNumber = 1,
    kDamageInflictedFieldNumber = 6,
  };
  // string category = 2;
  void clear_category() ;
  const std::string& category() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_category(Arg_&& arg, Args_... args);
  std::string* mutable_category();
  PROTOBUF_NODISCARD std::string* release_category();
  void set_allocated_category(std::string* value);

  private:
  const std::string& _internal_category() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_category(
      const std::string& value);
  std::string* _internal_mutable_category();

  public:
  // string weapon = 5;
  void clear_weapon() ;
  const std::string& weapon() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_weapon(Arg_&& arg, Args_... args);
  std::string* mutable_weapon();
  PROTOBUF_NODISCARD std::string* release_weapon();
  void set_allocated_weapon(std::string* value);

  private:
  const std::string& _internal_weapon() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_weapon(
      const std::string& value);
  std::string* _internal_mutable_weapon();

  public:
  // .rtech.liveapi.Player attacker = 3;
  bool has_attacker() const;
  void clear_attacker() ;
  const ::rtech::liveapi::Player& attacker() const;
  PROTOBUF_NODISCARD ::rtech::liveapi::Player* release_attacker();
  ::rtech::liveapi::Player* mutable_attacker();
  void set_allocated_attacker(::rtech::liveapi::Player* value);
  void unsafe_arena_set_allocated_attacker(::rtech::liveapi::Player* value);
  ::rtech::liveapi::Player* unsafe_arena_release_attacker();

  private:
  const ::rtech::liveapi::Player& _internal_attacker() const;
  ::rtech::liveapi::Player* _internal_mutable_attacker();

  public:
  // .rtech.liveapi.Player victim = 4;
  bool has_victim() const;
  void clear_victim() ;
  const ::rtech::liveapi::Player& victim() const;
  PROTOBUF_NODISCARD ::rtech::liveapi::Player* release_victim();
  ::rtech::liveapi::Player* mutable_victim();
  void set_allocated_victim(::rtech::liveapi::Player* value);
  void unsafe_arena_set_allocated_victim(::rtech::liveapi::Player* value);
  ::rtech::liveapi::Player* unsafe_arena_release_victim();

  private:
  const ::rtech::liveapi::Player& _internal_victim() const;
  ::rtech::liveapi::Player* _internal_mutable_victim();

  public:
  // uint64 timestamp = 1;
  void clear_timestamp() ;
  ::uint64_t timestamp() const;
  void set_timestamp(::uint64_t value);

  private:
  ::uint64_t _internal_timestamp() const;
  void _internal_set_timestamp(::uint64_t value);

  public:
  // uint32 damageInflicted = 6;
  void clear_damageinflicted() ;
  ::uint32_t damageinflicted() const;
  void set_damageinflicted(::uint32_t value);

  private:
  ::uint32_t _internal_damageinflicted() const;
  void _internal_set_damageinflicted(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:rtech.liveapi.PlayerDamaged)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 6, 2,
      50, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr category_;
    ::google::protobuf::internal::ArenaStringPtr weapon_;
    ::rtech::liveapi::Player* attacker_;
    ::rtech::liveapi::Player* victim_;
    ::uint64_t timestamp_;
    ::uint32_t damageinflicted_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_events_2eproto;
};// -------------------------------------------------------------------

class PlayerConnected final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rtech.liveapi.PlayerConnected) */ {
 public:
  inline PlayerConnected() : PlayerConnected(nullptr) {}
  ~PlayerConnected() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR PlayerConnected(::google::protobuf::internal::ConstantInitialized);

  inline PlayerConnected(const PlayerConnected& from)
      : PlayerConnected(nullptr, from) {}
  PlayerConnected(PlayerConnected&& from) noexcept
    : PlayerConnected() {
    *this = ::std::move(from);
  }

  inline PlayerConnected& operator=(const PlayerConnected& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayerConnected& operator=(PlayerConnected&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlayerConnected& default_instance() {
    return *internal_default_instance();
  }
  static inline const PlayerConnected* internal_default_instance() {
    return reinterpret_cast<const PlayerConnected*>(
               &_PlayerConnected_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(PlayerConnected& a, PlayerConnected& b) {
    a.Swap(&b);
  }
  inline void Swap(PlayerConnected* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlayerConnected* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PlayerConnected* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PlayerConnected>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PlayerConnected& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const PlayerConnected& from) {
    PlayerConnected::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(PlayerConnected* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "rtech.liveapi.PlayerConnected";
  }
  protected:
  explicit PlayerConnected(::google::protobuf::Arena* arena);
  PlayerConnected(::google::protobuf::Arena* arena, const PlayerConnected& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCategoryFieldNumber = 2,
    kPlayerFieldNumber = 3,
    kTimestampFieldNumber = 1,
  };
  // string category = 2;
  void clear_category() ;
  const std::string& category() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_category(Arg_&& arg, Args_... args);
  std::string* mutable_category();
  PROTOBUF_NODISCARD std::string* release_category();
  void set_allocated_category(std::string* value);

  private:
  const std::string& _internal_category() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_category(
      const std::string& value);
  std::string* _internal_mutable_category();

  public:
  // .rtech.liveapi.Player player = 3;
  bool has_player() const;
  void clear_player() ;
  const ::rtech::liveapi::Player& player() const;
  PROTOBUF_NODISCARD ::rtech::liveapi::Player* release_player();
  ::rtech::liveapi::Player* mutable_player();
  void set_allocated_player(::rtech::liveapi::Player* value);
  void unsafe_arena_set_allocated_player(::rtech::liveapi::Player* value);
  ::rtech::liveapi::Player* unsafe_arena_release_player();

  private:
  const ::rtech::liveapi::Player& _internal_player() const;
  ::rtech::liveapi::Player* _internal_mutable_player();

  public:
  // uint64 timestamp = 1;
  void clear_timestamp() ;
  ::uint64_t timestamp() const;
  void set_timestamp(::uint64_t value);

  private:
  ::uint64_t _internal_timestamp() const;
  void _internal_set_timestamp(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:rtech.liveapi.PlayerConnected)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      46, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr category_;
    ::rtech::liveapi::Player* player_;
    ::uint64_t timestamp_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_events_2eproto;
};// -------------------------------------------------------------------

class PlayerAssist final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rtech.liveapi.PlayerAssist) */ {
 public:
  inline PlayerAssist() : PlayerAssist(nullptr) {}
  ~PlayerAssist() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR PlayerAssist(::google::protobuf::internal::ConstantInitialized);

  inline PlayerAssist(const PlayerAssist& from)
      : PlayerAssist(nullptr, from) {}
  PlayerAssist(PlayerAssist&& from) noexcept
    : PlayerAssist() {
    *this = ::std::move(from);
  }

  inline PlayerAssist& operator=(const PlayerAssist& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayerAssist& operator=(PlayerAssist&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlayerAssist& default_instance() {
    return *internal_default_instance();
  }
  static inline const PlayerAssist* internal_default_instance() {
    return reinterpret_cast<const PlayerAssist*>(
               &_PlayerAssist_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(PlayerAssist& a, PlayerAssist& b) {
    a.Swap(&b);
  }
  inline void Swap(PlayerAssist* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlayerAssist* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PlayerAssist* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PlayerAssist>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PlayerAssist& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const PlayerAssist& from) {
    PlayerAssist::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(PlayerAssist* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "rtech.liveapi.PlayerAssist";
  }
  protected:
  explicit PlayerAssist(::google::protobuf::Arena* arena);
  PlayerAssist(::google::protobuf::Arena* arena, const PlayerAssist& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCategoryFieldNumber = 2,
    kWeaponFieldNumber = 5,
    kAssistantFieldNumber = 3,
    kVictimFieldNumber = 4,
    kTimestampFieldNumber = 1,
  };
  // string category = 2;
  void clear_category() ;
  const std::string& category() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_category(Arg_&& arg, Args_... args);
  std::string* mutable_category();
  PROTOBUF_NODISCARD std::string* release_category();
  void set_allocated_category(std::string* value);

  private:
  const std::string& _internal_category() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_category(
      const std::string& value);
  std::string* _internal_mutable_category();

  public:
  // string weapon = 5;
  void clear_weapon() ;
  const std::string& weapon() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_weapon(Arg_&& arg, Args_... args);
  std::string* mutable_weapon();
  PROTOBUF_NODISCARD std::string* release_weapon();
  void set_allocated_weapon(std::string* value);

  private:
  const std::string& _internal_weapon() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_weapon(
      const std::string& value);
  std::string* _internal_mutable_weapon();

  public:
  // .rtech.liveapi.Player assistant = 3;
  bool has_assistant() const;
  void clear_assistant() ;
  const ::rtech::liveapi::Player& assistant() const;
  PROTOBUF_NODISCARD ::rtech::liveapi::Player* release_assistant();
  ::rtech::liveapi::Player* mutable_assistant();
  void set_allocated_assistant(::rtech::liveapi::Player* value);
  void unsafe_arena_set_allocated_assistant(::rtech::liveapi::Player* value);
  ::rtech::liveapi::Player* unsafe_arena_release_assistant();

  private:
  const ::rtech::liveapi::Player& _internal_assistant() const;
  ::rtech::liveapi::Player* _internal_mutable_assistant();

  public:
  // .rtech.liveapi.Player victim = 4;
  bool has_victim() const;
  void clear_victim() ;
  const ::rtech::liveapi::Player& victim() const;
  PROTOBUF_NODISCARD ::rtech::liveapi::Player* release_victim();
  ::rtech::liveapi::Player* mutable_victim();
  void set_allocated_victim(::rtech::liveapi::Player* value);
  void unsafe_arena_set_allocated_victim(::rtech::liveapi::Player* value);
  ::rtech::liveapi::Player* unsafe_arena_release_victim();

  private:
  const ::rtech::liveapi::Player& _internal_victim() const;
  ::rtech::liveapi::Player* _internal_mutable_victim();

  public:
  // uint64 timestamp = 1;
  void clear_timestamp() ;
  ::uint64_t timestamp() const;
  void set_timestamp(::uint64_t value);

  private:
  ::uint64_t _internal_timestamp() const;
  void _internal_set_timestamp(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:rtech.liveapi.PlayerAssist)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 2,
      49, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr category_;
    ::google::protobuf::internal::ArenaStringPtr weapon_;
    ::rtech::liveapi::Player* assistant_;
    ::rtech::liveapi::Player* victim_;
    ::uint64_t timestamp_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_events_2eproto;
};// -------------------------------------------------------------------

class PlayerAbilityUsed final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rtech.liveapi.PlayerAbilityUsed) */ {
 public:
  inline PlayerAbilityUsed() : PlayerAbilityUsed(nullptr) {}
  ~PlayerAbilityUsed() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR PlayerAbilityUsed(::google::protobuf::internal::ConstantInitialized);

  inline PlayerAbilityUsed(const PlayerAbilityUsed& from)
      : PlayerAbilityUsed(nullptr, from) {}
  PlayerAbilityUsed(PlayerAbilityUsed&& from) noexcept
    : PlayerAbilityUsed() {
    *this = ::std::move(from);
  }

  inline PlayerAbilityUsed& operator=(const PlayerAbilityUsed& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayerAbilityUsed& operator=(PlayerAbilityUsed&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlayerAbilityUsed& default_instance() {
    return *internal_default_instance();
  }
  static inline const PlayerAbilityUsed* internal_default_instance() {
    return reinterpret_cast<const PlayerAbilityUsed*>(
               &_PlayerAbilityUsed_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  friend void swap(PlayerAbilityUsed& a, PlayerAbilityUsed& b) {
    a.Swap(&b);
  }
  inline void Swap(PlayerAbilityUsed* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlayerAbilityUsed* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PlayerAbilityUsed* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PlayerAbilityUsed>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PlayerAbilityUsed& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const PlayerAbilityUsed& from) {
    PlayerAbilityUsed::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(PlayerAbilityUsed* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "rtech.liveapi.PlayerAbilityUsed";
  }
  protected:
  explicit PlayerAbilityUsed(::google::protobuf::Arena* arena);
  PlayerAbilityUsed(::google::protobuf::Arena* arena, const PlayerAbilityUsed& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCategoryFieldNumber = 2,
    kLinkedEntityFieldNumber = 4,
    kPlayerFieldNumber = 3,
    kTimestampFieldNumber = 1,
  };
  // string category = 2;
  void clear_category() ;
  const std::string& category() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_category(Arg_&& arg, Args_... args);
  std::string* mutable_category();
  PROTOBUF_NODISCARD std::string* release_category();
  void set_allocated_category(std::string* value);

  private:
  const std::string& _internal_category() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_category(
      const std::string& value);
  std::string* _internal_mutable_category();

  public:
  // string linkedEntity = 4;
  void clear_linkedentity() ;
  const std::string& linkedentity() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_linkedentity(Arg_&& arg, Args_... args);
  std::string* mutable_linkedentity();
  PROTOBUF_NODISCARD std::string* release_linkedentity();
  void set_allocated_linkedentity(std::string* value);

  private:
  const std::string& _internal_linkedentity() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_linkedentity(
      const std::string& value);
  std::string* _internal_mutable_linkedentity();

  public:
  // .rtech.liveapi.Player player = 3;
  bool has_player() const;
  void clear_player() ;
  const ::rtech::liveapi::Player& player() const;
  PROTOBUF_NODISCARD ::rtech::liveapi::Player* release_player();
  ::rtech::liveapi::Player* mutable_player();
  void set_allocated_player(::rtech::liveapi::Player* value);
  void unsafe_arena_set_allocated_player(::rtech::liveapi::Player* value);
  ::rtech::liveapi::Player* unsafe_arena_release_player();

  private:
  const ::rtech::liveapi::Player& _internal_player() const;
  ::rtech::liveapi::Player* _internal_mutable_player();

  public:
  // uint64 timestamp = 1;
  void clear_timestamp() ;
  ::uint64_t timestamp() const;
  void set_timestamp(::uint64_t value);

  private:
  ::uint64_t _internal_timestamp() const;
  void _internal_set_timestamp(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:rtech.liveapi.PlayerAbilityUsed)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 1,
      60, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr category_;
    ::google::protobuf::internal::ArenaStringPtr linkedentity_;
    ::rtech::liveapi::Player* player_;
    ::uint64_t timestamp_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_events_2eproto;
};// -------------------------------------------------------------------

class ObserverSwitched final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rtech.liveapi.ObserverSwitched) */ {
 public:
  inline ObserverSwitched() : ObserverSwitched(nullptr) {}
  ~ObserverSwitched() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ObserverSwitched(::google::protobuf::internal::ConstantInitialized);

  inline ObserverSwitched(const ObserverSwitched& from)
      : ObserverSwitched(nullptr, from) {}
  ObserverSwitched(ObserverSwitched&& from) noexcept
    : ObserverSwitched() {
    *this = ::std::move(from);
  }

  inline ObserverSwitched& operator=(const ObserverSwitched& from) {
    CopyFrom(from);
    return *this;
  }
  inline ObserverSwitched& operator=(ObserverSwitched&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ObserverSwitched& default_instance() {
    return *internal_default_instance();
  }
  static inline const ObserverSwitched* internal_default_instance() {
    return reinterpret_cast<const ObserverSwitched*>(
               &_ObserverSwitched_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(ObserverSwitched& a, ObserverSwitched& b) {
    a.Swap(&b);
  }
  inline void Swap(ObserverSwitched* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ObserverSwitched* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ObserverSwitched* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ObserverSwitched>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ObserverSwitched& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ObserverSwitched& from) {
    ObserverSwitched::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ObserverSwitched* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "rtech.liveapi.ObserverSwitched";
  }
  protected:
  explicit ObserverSwitched(::google::protobuf::Arena* arena);
  ObserverSwitched(::google::protobuf::Arena* arena, const ObserverSwitched& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTargetTeamFieldNumber = 5,
    kCategoryFieldNumber = 2,
    kObserverFieldNumber = 3,
    kTargetFieldNumber = 4,
    kTimestampFieldNumber = 1,
  };
  // repeated .rtech.liveapi.Player targetTeam = 5;
  int targetteam_size() const;
  private:
  int _internal_targetteam_size() const;

  public:
  void clear_targetteam() ;
  ::rtech::liveapi::Player* mutable_targetteam(int index);
  ::google::protobuf::RepeatedPtrField< ::rtech::liveapi::Player >*
      mutable_targetteam();
  private:
  const ::google::protobuf::RepeatedPtrField<::rtech::liveapi::Player>& _internal_targetteam() const;
  ::google::protobuf::RepeatedPtrField<::rtech::liveapi::Player>* _internal_mutable_targetteam();
  public:
  const ::rtech::liveapi::Player& targetteam(int index) const;
  ::rtech::liveapi::Player* add_targetteam();
  const ::google::protobuf::RepeatedPtrField< ::rtech::liveapi::Player >&
      targetteam() const;
  // string category = 2;
  void clear_category() ;
  const std::string& category() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_category(Arg_&& arg, Args_... args);
  std::string* mutable_category();
  PROTOBUF_NODISCARD std::string* release_category();
  void set_allocated_category(std::string* value);

  private:
  const std::string& _internal_category() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_category(
      const std::string& value);
  std::string* _internal_mutable_category();

  public:
  // .rtech.liveapi.Player observer = 3;
  bool has_observer() const;
  void clear_observer() ;
  const ::rtech::liveapi::Player& observer() const;
  PROTOBUF_NODISCARD ::rtech::liveapi::Player* release_observer();
  ::rtech::liveapi::Player* mutable_observer();
  void set_allocated_observer(::rtech::liveapi::Player* value);
  void unsafe_arena_set_allocated_observer(::rtech::liveapi::Player* value);
  ::rtech::liveapi::Player* unsafe_arena_release_observer();

  private:
  const ::rtech::liveapi::Player& _internal_observer() const;
  ::rtech::liveapi::Player* _internal_mutable_observer();

  public:
  // .rtech.liveapi.Player target = 4;
  bool has_target() const;
  void clear_target() ;
  const ::rtech::liveapi::Player& target() const;
  PROTOBUF_NODISCARD ::rtech::liveapi::Player* release_target();
  ::rtech::liveapi::Player* mutable_target();
  void set_allocated_target(::rtech::liveapi::Player* value);
  void unsafe_arena_set_allocated_target(::rtech::liveapi::Player* value);
  ::rtech::liveapi::Player* unsafe_arena_release_target();

  private:
  const ::rtech::liveapi::Player& _internal_target() const;
  ::rtech::liveapi::Player* _internal_mutable_target();

  public:
  // uint64 timestamp = 1;
  void clear_timestamp() ;
  ::uint64_t timestamp() const;
  void set_timestamp(::uint64_t value);

  private:
  ::uint64_t _internal_timestamp() const;
  void _internal_set_timestamp(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:rtech.liveapi.ObserverSwitched)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 3,
      47, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::rtech::liveapi::Player > targetteam_;
    ::google::protobuf::internal::ArenaStringPtr category_;
    ::rtech::liveapi::Player* observer_;
    ::rtech::liveapi::Player* target_;
    ::uint64_t timestamp_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_events_2eproto;
};// -------------------------------------------------------------------

class MatchStateEnd final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rtech.liveapi.MatchStateEnd) */ {
 public:
  inline MatchStateEnd() : MatchStateEnd(nullptr) {}
  ~MatchStateEnd() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MatchStateEnd(::google::protobuf::internal::ConstantInitialized);

  inline MatchStateEnd(const MatchStateEnd& from)
      : MatchStateEnd(nullptr, from) {}
  MatchStateEnd(MatchStateEnd&& from) noexcept
    : MatchStateEnd() {
    *this = ::std::move(from);
  }

  inline MatchStateEnd& operator=(const MatchStateEnd& from) {
    CopyFrom(from);
    return *this;
  }
  inline MatchStateEnd& operator=(MatchStateEnd&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MatchStateEnd& default_instance() {
    return *internal_default_instance();
  }
  static inline const MatchStateEnd* internal_default_instance() {
    return reinterpret_cast<const MatchStateEnd*>(
               &_MatchStateEnd_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(MatchStateEnd& a, MatchStateEnd& b) {
    a.Swap(&b);
  }
  inline void Swap(MatchStateEnd* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MatchStateEnd* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MatchStateEnd* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MatchStateEnd>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const MatchStateEnd& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const MatchStateEnd& from) {
    MatchStateEnd::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(MatchStateEnd* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "rtech.liveapi.MatchStateEnd";
  }
  protected:
  explicit MatchStateEnd(::google::protobuf::Arena* arena);
  MatchStateEnd(::google::protobuf::Arena* arena, const MatchStateEnd& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWinnersFieldNumber = 4,
    kCategoryFieldNumber = 2,
    kStateFieldNumber = 3,
    kTimestampFieldNumber = 1,
  };
  // repeated .rtech.liveapi.Player winners = 4;
  int winners_size() const;
  private:
  int _internal_winners_size() const;

  public:
  void clear_winners() ;
  ::rtech::liveapi::Player* mutable_winners(int index);
  ::google::protobuf::RepeatedPtrField< ::rtech::liveapi::Player >*
      mutable_winners();
  private:
  const ::google::protobuf::RepeatedPtrField<::rtech::liveapi::Player>& _internal_winners() const;
  ::google::protobuf::RepeatedPtrField<::rtech::liveapi::Player>* _internal_mutable_winners();
  public:
  const ::rtech::liveapi::Player& winners(int index) const;
  ::rtech::liveapi::Player* add_winners();
  const ::google::protobuf::RepeatedPtrField< ::rtech::liveapi::Player >&
      winners() const;
  // string category = 2;
  void clear_category() ;
  const std::string& category() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_category(Arg_&& arg, Args_... args);
  std::string* mutable_category();
  PROTOBUF_NODISCARD std::string* release_category();
  void set_allocated_category(std::string* value);

  private:
  const std::string& _internal_category() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_category(
      const std::string& value);
  std::string* _internal_mutable_category();

  public:
  // string state = 3;
  void clear_state() ;
  const std::string& state() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_state(Arg_&& arg, Args_... args);
  std::string* mutable_state();
  PROTOBUF_NODISCARD std::string* release_state();
  void set_allocated_state(std::string* value);

  private:
  const std::string& _internal_state() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_state(
      const std::string& value);
  std::string* _internal_mutable_state();

  public:
  // uint64 timestamp = 1;
  void clear_timestamp() ;
  ::uint64_t timestamp() const;
  void set_timestamp(::uint64_t value);

  private:
  ::uint64_t _internal_timestamp() const;
  void _internal_set_timestamp(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:rtech.liveapi.MatchStateEnd)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 1,
      49, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField< ::rtech::liveapi::Player > winners_;
    ::google::protobuf::internal::ArenaStringPtr category_;
    ::google::protobuf::internal::ArenaStringPtr state_;
    ::uint64_t timestamp_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_events_2eproto;
};// -------------------------------------------------------------------

class MatchSetup final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rtech.liveapi.MatchSetup) */ {
 public:
  inline MatchSetup() : MatchSetup(nullptr) {}
  ~MatchSetup() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MatchSetup(::google::protobuf::internal::ConstantInitialized);

  inline MatchSetup(const MatchSetup& from)
      : MatchSetup(nullptr, from) {}
  MatchSetup(MatchSetup&& from) noexcept
    : MatchSetup() {
    *this = ::std::move(from);
  }

  inline MatchSetup& operator=(const MatchSetup& from) {
    CopyFrom(from);
    return *this;
  }
  inline MatchSetup& operator=(MatchSetup&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MatchSetup& default_instance() {
    return *internal_default_instance();
  }
  static inline const MatchSetup* internal_default_instance() {
    return reinterpret_cast<const MatchSetup*>(
               &_MatchSetup_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(MatchSetup& a, MatchSetup& b) {
    a.Swap(&b);
  }
  inline void Swap(MatchSetup* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MatchSetup* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MatchSetup* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MatchSetup>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const MatchSetup& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const MatchSetup& from) {
    MatchSetup::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(MatchSetup* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "rtech.liveapi.MatchSetup";
  }
  protected:
  explicit MatchSetup(::google::protobuf::Arena* arena);
  MatchSetup(::google::protobuf::Arena* arena, const MatchSetup& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCategoryFieldNumber = 2,
    kMapFieldNumber = 3,
    kPlaylistNameFieldNumber = 4,
    kPlaylistDescFieldNumber = 5,
    kServerIdFieldNumber = 9,
    kDatacenterFieldNumber = 6,
    kStartingLoadoutFieldNumber = 10,
    kTimestampFieldNumber = 1,
    kAimAssistOnFieldNumber = 7,
    kAnonymousModeFieldNumber = 8,
  };
  // string category = 2;
  void clear_category() ;
  const std::string& category() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_category(Arg_&& arg, Args_... args);
  std::string* mutable_category();
  PROTOBUF_NODISCARD std::string* release_category();
  void set_allocated_category(std::string* value);

  private:
  const std::string& _internal_category() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_category(
      const std::string& value);
  std::string* _internal_mutable_category();

  public:
  // string map = 3;
  void clear_map() ;
  const std::string& map() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_map(Arg_&& arg, Args_... args);
  std::string* mutable_map();
  PROTOBUF_NODISCARD std::string* release_map();
  void set_allocated_map(std::string* value);

  private:
  const std::string& _internal_map() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_map(
      const std::string& value);
  std::string* _internal_mutable_map();

  public:
  // string playlistName = 4;
  void clear_playlistname() ;
  const std::string& playlistname() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_playlistname(Arg_&& arg, Args_... args);
  std::string* mutable_playlistname();
  PROTOBUF_NODISCARD std::string* release_playlistname();
  void set_allocated_playlistname(std::string* value);

  private:
  const std::string& _internal_playlistname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_playlistname(
      const std::string& value);
  std::string* _internal_mutable_playlistname();

  public:
  // string playlistDesc = 5;
  void clear_playlistdesc() ;
  const std::string& playlistdesc() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_playlistdesc(Arg_&& arg, Args_... args);
  std::string* mutable_playlistdesc();
  PROTOBUF_NODISCARD std::string* release_playlistdesc();
  void set_allocated_playlistdesc(std::string* value);

  private:
  const std::string& _internal_playlistdesc() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_playlistdesc(
      const std::string& value);
  std::string* _internal_mutable_playlistdesc();

  public:
  // string serverId = 9;
  void clear_serverid() ;
  const std::string& serverid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_serverid(Arg_&& arg, Args_... args);
  std::string* mutable_serverid();
  PROTOBUF_NODISCARD std::string* release_serverid();
  void set_allocated_serverid(std::string* value);

  private:
  const std::string& _internal_serverid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_serverid(
      const std::string& value);
  std::string* _internal_mutable_serverid();

  public:
  // .rtech.liveapi.Datacenter datacenter = 6;
  bool has_datacenter() const;
  void clear_datacenter() ;
  const ::rtech::liveapi::Datacenter& datacenter() const;
  PROTOBUF_NODISCARD ::rtech::liveapi::Datacenter* release_datacenter();
  ::rtech::liveapi::Datacenter* mutable_datacenter();
  void set_allocated_datacenter(::rtech::liveapi::Datacenter* value);
  void unsafe_arena_set_allocated_datacenter(::rtech::liveapi::Datacenter* value);
  ::rtech::liveapi::Datacenter* unsafe_arena_release_datacenter();

  private:
  const ::rtech::liveapi::Datacenter& _internal_datacenter() const;
  ::rtech::liveapi::Datacenter* _internal_mutable_datacenter();

  public:
  // .rtech.liveapi.LoadoutConfiguration startingLoadout = 10;
  bool has_startingloadout() const;
  void clear_startingloadout() ;
  const ::rtech::liveapi::LoadoutConfiguration& startingloadout() const;
  PROTOBUF_NODISCARD ::rtech::liveapi::LoadoutConfiguration* release_startingloadout();
  ::rtech::liveapi::LoadoutConfiguration* mutable_startingloadout();
  void set_allocated_startingloadout(::rtech::liveapi::LoadoutConfiguration* value);
  void unsafe_arena_set_allocated_startingloadout(::rtech::liveapi::LoadoutConfiguration* value);
  ::rtech::liveapi::LoadoutConfiguration* unsafe_arena_release_startingloadout();

  private:
  const ::rtech::liveapi::LoadoutConfiguration& _internal_startingloadout() const;
  ::rtech::liveapi::LoadoutConfiguration* _internal_mutable_startingloadout();

  public:
  // uint64 timestamp = 1;
  void clear_timestamp() ;
  ::uint64_t timestamp() const;
  void set_timestamp(::uint64_t value);

  private:
  ::uint64_t _internal_timestamp() const;
  void _internal_set_timestamp(::uint64_t value);

  public:
  // bool aimAssistOn = 7;
  void clear_aimassiston() ;
  bool aimassiston() const;
  void set_aimassiston(bool value);

  private:
  bool _internal_aimassiston() const;
  void _internal_set_aimassiston(bool value);

  public:
  // bool anonymousMode = 8;
  void clear_anonymousmode() ;
  bool anonymousmode() const;
  void set_anonymousmode(bool value);

  private:
  bool _internal_anonymousmode() const;
  void _internal_set_anonymousmode(bool value);

  public:
  // @@protoc_insertion_point(class_scope:rtech.liveapi.MatchSetup)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 10, 2,
      84, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr category_;
    ::google::protobuf::internal::ArenaStringPtr map_;
    ::google::protobuf::internal::ArenaStringPtr playlistname_;
    ::google::protobuf::internal::ArenaStringPtr playlistdesc_;
    ::google::protobuf::internal::ArenaStringPtr serverid_;
    ::rtech::liveapi::Datacenter* datacenter_;
    ::rtech::liveapi::LoadoutConfiguration* startingloadout_;
    ::uint64_t timestamp_;
    bool aimassiston_;
    bool anonymousmode_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_events_2eproto;
};// -------------------------------------------------------------------

class LegendUpgradeSelected final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rtech.liveapi.LegendUpgradeSelected) */ {
 public:
  inline LegendUpgradeSelected() : LegendUpgradeSelected(nullptr) {}
  ~LegendUpgradeSelected() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR LegendUpgradeSelected(::google::protobuf::internal::ConstantInitialized);

  inline LegendUpgradeSelected(const LegendUpgradeSelected& from)
      : LegendUpgradeSelected(nullptr, from) {}
  LegendUpgradeSelected(LegendUpgradeSelected&& from) noexcept
    : LegendUpgradeSelected() {
    *this = ::std::move(from);
  }

  inline LegendUpgradeSelected& operator=(const LegendUpgradeSelected& from) {
    CopyFrom(from);
    return *this;
  }
  inline LegendUpgradeSelected& operator=(LegendUpgradeSelected&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LegendUpgradeSelected& default_instance() {
    return *internal_default_instance();
  }
  static inline const LegendUpgradeSelected* internal_default_instance() {
    return reinterpret_cast<const LegendUpgradeSelected*>(
               &_LegendUpgradeSelected_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  friend void swap(LegendUpgradeSelected& a, LegendUpgradeSelected& b) {
    a.Swap(&b);
  }
  inline void Swap(LegendUpgradeSelected* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LegendUpgradeSelected* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LegendUpgradeSelected* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LegendUpgradeSelected>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const LegendUpgradeSelected& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const LegendUpgradeSelected& from) {
    LegendUpgradeSelected::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(LegendUpgradeSelected* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "rtech.liveapi.LegendUpgradeSelected";
  }
  protected:
  explicit LegendUpgradeSelected(::google::protobuf::Arena* arena);
  LegendUpgradeSelected(::google::protobuf::Arena* arena, const LegendUpgradeSelected& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCategoryFieldNumber = 2,
    kUpgradeNameFieldNumber = 4,
    kUpgradeDescFieldNumber = 5,
    kPlayerFieldNumber = 3,
    kTimestampFieldNumber = 1,
    kLevelFieldNumber = 6,
  };
  // string category = 2;
  void clear_category() ;
  const std::string& category() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_category(Arg_&& arg, Args_... args);
  std::string* mutable_category();
  PROTOBUF_NODISCARD std::string* release_category();
  void set_allocated_category(std::string* value);

  private:
  const std::string& _internal_category() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_category(
      const std::string& value);
  std::string* _internal_mutable_category();

  public:
  // string upgradeName = 4;
  void clear_upgradename() ;
  const std::string& upgradename() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_upgradename(Arg_&& arg, Args_... args);
  std::string* mutable_upgradename();
  PROTOBUF_NODISCARD std::string* release_upgradename();
  void set_allocated_upgradename(std::string* value);

  private:
  const std::string& _internal_upgradename() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_upgradename(
      const std::string& value);
  std::string* _internal_mutable_upgradename();

  public:
  // string upgradeDesc = 5;
  void clear_upgradedesc() ;
  const std::string& upgradedesc() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_upgradedesc(Arg_&& arg, Args_... args);
  std::string* mutable_upgradedesc();
  PROTOBUF_NODISCARD std::string* release_upgradedesc();
  void set_allocated_upgradedesc(std::string* value);

  private:
  const std::string& _internal_upgradedesc() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_upgradedesc(
      const std::string& value);
  std::string* _internal_mutable_upgradedesc();

  public:
  // .rtech.liveapi.Player player = 3;
  bool has_player() const;
  void clear_player() ;
  const ::rtech::liveapi::Player& player() const;
  PROTOBUF_NODISCARD ::rtech::liveapi::Player* release_player();
  ::rtech::liveapi::Player* mutable_player();
  void set_allocated_player(::rtech::liveapi::Player* value);
  void unsafe_arena_set_allocated_player(::rtech::liveapi::Player* value);
  ::rtech::liveapi::Player* unsafe_arena_release_player();

  private:
  const ::rtech::liveapi::Player& _internal_player() const;
  ::rtech::liveapi::Player* _internal_mutable_player();

  public:
  // uint64 timestamp = 1;
  void clear_timestamp() ;
  ::uint64_t timestamp() const;
  void set_timestamp(::uint64_t value);

  private:
  ::uint64_t _internal_timestamp() const;
  void _internal_set_timestamp(::uint64_t value);

  public:
  // int32 level = 6;
  void clear_level() ;
  ::int32_t level() const;
  void set_level(::int32_t value);

  private:
  ::int32_t _internal_level() const;
  void _internal_set_level(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:rtech.liveapi.LegendUpgradeSelected)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 6, 1,
      74, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr category_;
    ::google::protobuf::internal::ArenaStringPtr upgradename_;
    ::google::protobuf::internal::ArenaStringPtr upgradedesc_;
    ::rtech::liveapi::Player* player_;
    ::uint64_t timestamp_;
    ::int32_t level_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_events_2eproto;
};// -------------------------------------------------------------------

class InventoryUse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rtech.liveapi.InventoryUse) */ {
 public:
  inline InventoryUse() : InventoryUse(nullptr) {}
  ~InventoryUse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR InventoryUse(::google::protobuf::internal::ConstantInitialized);

  inline InventoryUse(const InventoryUse& from)
      : InventoryUse(nullptr, from) {}
  InventoryUse(InventoryUse&& from) noexcept
    : InventoryUse() {
    *this = ::std::move(from);
  }

  inline InventoryUse& operator=(const InventoryUse& from) {
    CopyFrom(from);
    return *this;
  }
  inline InventoryUse& operator=(InventoryUse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InventoryUse& default_instance() {
    return *internal_default_instance();
  }
  static inline const InventoryUse* internal_default_instance() {
    return reinterpret_cast<const InventoryUse*>(
               &_InventoryUse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(InventoryUse& a, InventoryUse& b) {
    a.Swap(&b);
  }
  inline void Swap(InventoryUse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InventoryUse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InventoryUse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InventoryUse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const InventoryUse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const InventoryUse& from) {
    InventoryUse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(InventoryUse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "rtech.liveapi.InventoryUse";
  }
  protected:
  explicit InventoryUse(::google::protobuf::Arena* arena);
  InventoryUse(::google::protobuf::Arena* arena, const InventoryUse& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCategoryFieldNumber = 2,
    kItemFieldNumber = 4,
    kPlayerFieldNumber = 3,
    kTimestampFieldNumber = 1,
    kQuantityFieldNumber = 5,
  };
  // string category = 2;
  void clear_category() ;
  const std::string& category() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_category(Arg_&& arg, Args_... args);
  std::string* mutable_category();
  PROTOBUF_NODISCARD std::string* release_category();
  void set_allocated_category(std::string* value);

  private:
  const std::string& _internal_category() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_category(
      const std::string& value);
  std::string* _internal_mutable_category();

  public:
  // string item = 4;
  void clear_item() ;
  const std::string& item() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_item(Arg_&& arg, Args_... args);
  std::string* mutable_item();
  PROTOBUF_NODISCARD std::string* release_item();
  void set_allocated_item(std::string* value);

  private:
  const std::string& _internal_item() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_item(
      const std::string& value);
  std::string* _internal_mutable_item();

  public:
  // .rtech.liveapi.Player player = 3;
  bool has_player() const;
  void clear_player() ;
  const ::rtech::liveapi::Player& player() const;
  PROTOBUF_NODISCARD ::rtech::liveapi::Player* release_player();
  ::rtech::liveapi::Player* mutable_player();
  void set_allocated_player(::rtech::liveapi::Player* value);
  void unsafe_arena_set_allocated_player(::rtech::liveapi::Player* value);
  ::rtech::liveapi::Player* unsafe_arena_release_player();

  private:
  const ::rtech::liveapi::Player& _internal_player() const;
  ::rtech::liveapi::Player* _internal_mutable_player();

  public:
  // uint64 timestamp = 1;
  void clear_timestamp() ;
  ::uint64_t timestamp() const;
  void set_timestamp(::uint64_t value);

  private:
  ::uint64_t _internal_timestamp() const;
  void _internal_set_timestamp(::uint64_t value);

  public:
  // int32 quantity = 5;
  void clear_quantity() ;
  ::int32_t quantity() const;
  void set_quantity(::int32_t value);

  private:
  ::int32_t _internal_quantity() const;
  void _internal_set_quantity(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:rtech.liveapi.InventoryUse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 1,
      47, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr category_;
    ::google::protobuf::internal::ArenaStringPtr item_;
    ::rtech::liveapi::Player* player_;
    ::uint64_t timestamp_;
    ::int32_t quantity_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_events_2eproto;
};// -------------------------------------------------------------------

class InventoryPickUp final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rtech.liveapi.InventoryPickUp) */ {
 public:
  inline InventoryPickUp() : InventoryPickUp(nullptr) {}
  ~InventoryPickUp() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR InventoryPickUp(::google::protobuf::internal::ConstantInitialized);

  inline InventoryPickUp(const InventoryPickUp& from)
      : InventoryPickUp(nullptr, from) {}
  InventoryPickUp(InventoryPickUp&& from) noexcept
    : InventoryPickUp() {
    *this = ::std::move(from);
  }

  inline InventoryPickUp& operator=(const InventoryPickUp& from) {
    CopyFrom(from);
    return *this;
  }
  inline InventoryPickUp& operator=(InventoryPickUp&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InventoryPickUp& default_instance() {
    return *internal_default_instance();
  }
  static inline const InventoryPickUp* internal_default_instance() {
    return reinterpret_cast<const InventoryPickUp*>(
               &_InventoryPickUp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(InventoryPickUp& a, InventoryPickUp& b) {
    a.Swap(&b);
  }
  inline void Swap(InventoryPickUp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InventoryPickUp* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InventoryPickUp* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InventoryPickUp>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const InventoryPickUp& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const InventoryPickUp& from) {
    InventoryPickUp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(InventoryPickUp* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "rtech.liveapi.InventoryPickUp";
  }
  protected:
  explicit InventoryPickUp(::google::protobuf::Arena* arena);
  InventoryPickUp(::google::protobuf::Arena* arena, const InventoryPickUp& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCategoryFieldNumber = 2,
    kItemFieldNumber = 4,
    kPlayerFieldNumber = 3,
    kTimestampFieldNumber = 1,
    kQuantityFieldNumber = 5,
  };
  // string category = 2;
  void clear_category() ;
  const std::string& category() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_category(Arg_&& arg, Args_... args);
  std::string* mutable_category();
  PROTOBUF_NODISCARD std::string* release_category();
  void set_allocated_category(std::string* value);

  private:
  const std::string& _internal_category() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_category(
      const std::string& value);
  std::string* _internal_mutable_category();

  public:
  // string item = 4;
  void clear_item() ;
  const std::string& item() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_item(Arg_&& arg, Args_... args);
  std::string* mutable_item();
  PROTOBUF_NODISCARD std::string* release_item();
  void set_allocated_item(std::string* value);

  private:
  const std::string& _internal_item() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_item(
      const std::string& value);
  std::string* _internal_mutable_item();

  public:
  // .rtech.liveapi.Player player = 3;
  bool has_player() const;
  void clear_player() ;
  const ::rtech::liveapi::Player& player() const;
  PROTOBUF_NODISCARD ::rtech::liveapi::Player* release_player();
  ::rtech::liveapi::Player* mutable_player();
  void set_allocated_player(::rtech::liveapi::Player* value);
  void unsafe_arena_set_allocated_player(::rtech::liveapi::Player* value);
  ::rtech::liveapi::Player* unsafe_arena_release_player();

  private:
  const ::rtech::liveapi::Player& _internal_player() const;
  ::rtech::liveapi::Player* _internal_mutable_player();

  public:
  // uint64 timestamp = 1;
  void clear_timestamp() ;
  ::uint64_t timestamp() const;
  void set_timestamp(::uint64_t value);

  private:
  ::uint64_t _internal_timestamp() const;
  void _internal_set_timestamp(::uint64_t value);

  public:
  // int32 quantity = 5;
  void clear_quantity() ;
  ::int32_t quantity() const;
  void set_quantity(::int32_t value);

  private:
  ::int32_t _internal_quantity() const;
  void _internal_set_quantity(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:rtech.liveapi.InventoryPickUp)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 1,
      50, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr category_;
    ::google::protobuf::internal::ArenaStringPtr item_;
    ::rtech::liveapi::Player* player_;
    ::uint64_t timestamp_;
    ::int32_t quantity_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_events_2eproto;
};// -------------------------------------------------------------------

class InventoryDrop final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rtech.liveapi.InventoryDrop) */ {
 public:
  inline InventoryDrop() : InventoryDrop(nullptr) {}
  ~InventoryDrop() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR InventoryDrop(::google::protobuf::internal::ConstantInitialized);

  inline InventoryDrop(const InventoryDrop& from)
      : InventoryDrop(nullptr, from) {}
  InventoryDrop(InventoryDrop&& from) noexcept
    : InventoryDrop() {
    *this = ::std::move(from);
  }

  inline InventoryDrop& operator=(const InventoryDrop& from) {
    CopyFrom(from);
    return *this;
  }
  inline InventoryDrop& operator=(InventoryDrop&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InventoryDrop& default_instance() {
    return *internal_default_instance();
  }
  static inline const InventoryDrop* internal_default_instance() {
    return reinterpret_cast<const InventoryDrop*>(
               &_InventoryDrop_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(InventoryDrop& a, InventoryDrop& b) {
    a.Swap(&b);
  }
  inline void Swap(InventoryDrop* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InventoryDrop* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InventoryDrop* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InventoryDrop>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const InventoryDrop& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const InventoryDrop& from) {
    InventoryDrop::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(InventoryDrop* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "rtech.liveapi.InventoryDrop";
  }
  protected:
  explicit InventoryDrop(::google::protobuf::Arena* arena);
  InventoryDrop(::google::protobuf::Arena* arena, const InventoryDrop& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kExtraDataFieldNumber = 6,
    kCategoryFieldNumber = 2,
    kItemFieldNumber = 4,
    kPlayerFieldNumber = 3,
    kTimestampFieldNumber = 1,
    kQuantityFieldNumber = 5,
  };
  // repeated string extraData = 6;
  int extradata_size() const;
  private:
  int _internal_extradata_size() const;

  public:
  void clear_extradata() ;
  const std::string& extradata(int index) const;
  std::string* mutable_extradata(int index);
  void set_extradata(int index, const std::string& value);
  void set_extradata(int index, std::string&& value);
  void set_extradata(int index, const char* value);
  void set_extradata(int index, const char* value, std::size_t size);
  void set_extradata(int index, absl::string_view value);
  std::string* add_extradata();
  void add_extradata(const std::string& value);
  void add_extradata(std::string&& value);
  void add_extradata(const char* value);
  void add_extradata(const char* value, std::size_t size);
  void add_extradata(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& extradata() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_extradata();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_extradata() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_extradata();

  public:
  // string category = 2;
  void clear_category() ;
  const std::string& category() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_category(Arg_&& arg, Args_... args);
  std::string* mutable_category();
  PROTOBUF_NODISCARD std::string* release_category();
  void set_allocated_category(std::string* value);

  private:
  const std::string& _internal_category() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_category(
      const std::string& value);
  std::string* _internal_mutable_category();

  public:
  // string item = 4;
  void clear_item() ;
  const std::string& item() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_item(Arg_&& arg, Args_... args);
  std::string* mutable_item();
  PROTOBUF_NODISCARD std::string* release_item();
  void set_allocated_item(std::string* value);

  private:
  const std::string& _internal_item() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_item(
      const std::string& value);
  std::string* _internal_mutable_item();

  public:
  // .rtech.liveapi.Player player = 3;
  bool has_player() const;
  void clear_player() ;
  const ::rtech::liveapi::Player& player() const;
  PROTOBUF_NODISCARD ::rtech::liveapi::Player* release_player();
  ::rtech::liveapi::Player* mutable_player();
  void set_allocated_player(::rtech::liveapi::Player* value);
  void unsafe_arena_set_allocated_player(::rtech::liveapi::Player* value);
  ::rtech::liveapi::Player* unsafe_arena_release_player();

  private:
  const ::rtech::liveapi::Player& _internal_player() const;
  ::rtech::liveapi::Player* _internal_mutable_player();

  public:
  // uint64 timestamp = 1;
  void clear_timestamp() ;
  ::uint64_t timestamp() const;
  void set_timestamp(::uint64_t value);

  private:
  ::uint64_t _internal_timestamp() const;
  void _internal_set_timestamp(::uint64_t value);

  public:
  // int32 quantity = 5;
  void clear_quantity() ;
  ::int32_t quantity() const;
  void set_quantity(::int32_t value);

  private:
  ::int32_t _internal_quantity() const;
  void _internal_set_quantity(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:rtech.liveapi.InventoryDrop)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 6, 1,
      57, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField<std::string> extradata_;
    ::google::protobuf::internal::ArenaStringPtr category_;
    ::google::protobuf::internal::ArenaStringPtr item_;
    ::rtech::liveapi::Player* player_;
    ::uint64_t timestamp_;
    ::int32_t quantity_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_events_2eproto;
};// -------------------------------------------------------------------

class GrenadeThrown final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rtech.liveapi.GrenadeThrown) */ {
 public:
  inline GrenadeThrown() : GrenadeThrown(nullptr) {}
  ~GrenadeThrown() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GrenadeThrown(::google::protobuf::internal::ConstantInitialized);

  inline GrenadeThrown(const GrenadeThrown& from)
      : GrenadeThrown(nullptr, from) {}
  GrenadeThrown(GrenadeThrown&& from) noexcept
    : GrenadeThrown() {
    *this = ::std::move(from);
  }

  inline GrenadeThrown& operator=(const GrenadeThrown& from) {
    CopyFrom(from);
    return *this;
  }
  inline GrenadeThrown& operator=(GrenadeThrown&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GrenadeThrown& default_instance() {
    return *internal_default_instance();
  }
  static inline const GrenadeThrown* internal_default_instance() {
    return reinterpret_cast<const GrenadeThrown*>(
               &_GrenadeThrown_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    39;

  friend void swap(GrenadeThrown& a, GrenadeThrown& b) {
    a.Swap(&b);
  }
  inline void Swap(GrenadeThrown* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GrenadeThrown* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GrenadeThrown* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GrenadeThrown>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GrenadeThrown& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const GrenadeThrown& from) {
    GrenadeThrown::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GrenadeThrown* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "rtech.liveapi.GrenadeThrown";
  }
  protected:
  explicit GrenadeThrown(::google::protobuf::Arena* arena);
  GrenadeThrown(::google::protobuf::Arena* arena, const GrenadeThrown& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCategoryFieldNumber = 2,
    kLinkedEntityFieldNumber = 4,
    kPlayerFieldNumber = 3,
    kTimestampFieldNumber = 1,
  };
  // string category = 2;
  void clear_category() ;
  const std::string& category() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_category(Arg_&& arg, Args_... args);
  std::string* mutable_category();
  PROTOBUF_NODISCARD std::string* release_category();
  void set_allocated_category(std::string* value);

  private:
  const std::string& _internal_category() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_category(
      const std::string& value);
  std::string* _internal_mutable_category();

  public:
  // string linkedEntity = 4;
  void clear_linkedentity() ;
  const std::string& linkedentity() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_linkedentity(Arg_&& arg, Args_... args);
  std::string* mutable_linkedentity();
  PROTOBUF_NODISCARD std::string* release_linkedentity();
  void set_allocated_linkedentity(std::string* value);

  private:
  const std::string& _internal_linkedentity() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_linkedentity(
      const std::string& value);
  std::string* _internal_mutable_linkedentity();

  public:
  // .rtech.liveapi.Player player = 3;
  bool has_player() const;
  void clear_player() ;
  const ::rtech::liveapi::Player& player() const;
  PROTOBUF_NODISCARD ::rtech::liveapi::Player* release_player();
  ::rtech::liveapi::Player* mutable_player();
  void set_allocated_player(::rtech::liveapi::Player* value);
  void unsafe_arena_set_allocated_player(::rtech::liveapi::Player* value);
  ::rtech::liveapi::Player* unsafe_arena_release_player();

  private:
  const ::rtech::liveapi::Player& _internal_player() const;
  ::rtech::liveapi::Player* _internal_mutable_player();

  public:
  // uint64 timestamp = 1;
  void clear_timestamp() ;
  ::uint64_t timestamp() const;
  void set_timestamp(::uint64_t value);

  private:
  ::uint64_t _internal_timestamp() const;
  void _internal_set_timestamp(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:rtech.liveapi.GrenadeThrown)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 1,
      56, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr category_;
    ::google::protobuf::internal::ArenaStringPtr linkedentity_;
    ::rtech::liveapi::Player* player_;
    ::uint64_t timestamp_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_events_2eproto;
};// -------------------------------------------------------------------

class GibraltarShieldAbsorbed final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rtech.liveapi.GibraltarShieldAbsorbed) */ {
 public:
  inline GibraltarShieldAbsorbed() : GibraltarShieldAbsorbed(nullptr) {}
  ~GibraltarShieldAbsorbed() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GibraltarShieldAbsorbed(::google::protobuf::internal::ConstantInitialized);

  inline GibraltarShieldAbsorbed(const GibraltarShieldAbsorbed& from)
      : GibraltarShieldAbsorbed(nullptr, from) {}
  GibraltarShieldAbsorbed(GibraltarShieldAbsorbed&& from) noexcept
    : GibraltarShieldAbsorbed() {
    *this = ::std::move(from);
  }

  inline GibraltarShieldAbsorbed& operator=(const GibraltarShieldAbsorbed& from) {
    CopyFrom(from);
    return *this;
  }
  inline GibraltarShieldAbsorbed& operator=(GibraltarShieldAbsorbed&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GibraltarShieldAbsorbed& default_instance() {
    return *internal_default_instance();
  }
  static inline const GibraltarShieldAbsorbed* internal_default_instance() {
    return reinterpret_cast<const GibraltarShieldAbsorbed*>(
               &_GibraltarShieldAbsorbed_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(GibraltarShieldAbsorbed& a, GibraltarShieldAbsorbed& b) {
    a.Swap(&b);
  }
  inline void Swap(GibraltarShieldAbsorbed* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GibraltarShieldAbsorbed* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GibraltarShieldAbsorbed* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GibraltarShieldAbsorbed>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GibraltarShieldAbsorbed& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const GibraltarShieldAbsorbed& from) {
    GibraltarShieldAbsorbed::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GibraltarShieldAbsorbed* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "rtech.liveapi.GibraltarShieldAbsorbed";
  }
  protected:
  explicit GibraltarShieldAbsorbed(::google::protobuf::Arena* arena);
  GibraltarShieldAbsorbed(::google::protobuf::Arena* arena, const GibraltarShieldAbsorbed& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCategoryFieldNumber = 2,
    kAttackerFieldNumber = 3,
    kVictimFieldNumber = 4,
    kTimestampFieldNumber = 1,
    kDamageInflictedFieldNumber = 6,
  };
  // string category = 2;
  void clear_category() ;
  const std::string& category() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_category(Arg_&& arg, Args_... args);
  std::string* mutable_category();
  PROTOBUF_NODISCARD std::string* release_category();
  void set_allocated_category(std::string* value);

  private:
  const std::string& _internal_category() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_category(
      const std::string& value);
  std::string* _internal_mutable_category();

  public:
  // .rtech.liveapi.Player attacker = 3;
  bool has_attacker() const;
  void clear_attacker() ;
  const ::rtech::liveapi::Player& attacker() const;
  PROTOBUF_NODISCARD ::rtech::liveapi::Player* release_attacker();
  ::rtech::liveapi::Player* mutable_attacker();
  void set_allocated_attacker(::rtech::liveapi::Player* value);
  void unsafe_arena_set_allocated_attacker(::rtech::liveapi::Player* value);
  ::rtech::liveapi::Player* unsafe_arena_release_attacker();

  private:
  const ::rtech::liveapi::Player& _internal_attacker() const;
  ::rtech::liveapi::Player* _internal_mutable_attacker();

  public:
  // .rtech.liveapi.Player victim = 4;
  bool has_victim() const;
  void clear_victim() ;
  const ::rtech::liveapi::Player& victim() const;
  PROTOBUF_NODISCARD ::rtech::liveapi::Player* release_victim();
  ::rtech::liveapi::Player* mutable_victim();
  void set_allocated_victim(::rtech::liveapi::Player* value);
  void unsafe_arena_set_allocated_victim(::rtech::liveapi::Player* value);
  ::rtech::liveapi::Player* unsafe_arena_release_victim();

  private:
  const ::rtech::liveapi::Player& _internal_victim() const;
  ::rtech::liveapi::Player* _internal_mutable_victim();

  public:
  // uint64 timestamp = 1;
  void clear_timestamp() ;
  ::uint64_t timestamp() const;
  void set_timestamp(::uint64_t value);

  private:
  ::uint64_t _internal_timestamp() const;
  void _internal_set_timestamp(::uint64_t value);

  public:
  // uint32 damageInflicted = 6;
  void clear_damageinflicted() ;
  ::uint32_t damageinflicted() const;
  void set_damageinflicted(::uint32_t value);

  private:
  ::uint32_t _internal_damageinflicted() const;
  void _internal_set_damageinflicted(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:rtech.liveapi.GibraltarShieldAbsorbed)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 2,
      54, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr category_;
    ::rtech::liveapi::Player* attacker_;
    ::rtech::liveapi::Player* victim_;
    ::uint64_t timestamp_;
    ::uint32_t damageinflicted_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_events_2eproto;
};// -------------------------------------------------------------------

class CharacterSelected final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rtech.liveapi.CharacterSelected) */ {
 public:
  inline CharacterSelected() : CharacterSelected(nullptr) {}
  ~CharacterSelected() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CharacterSelected(::google::protobuf::internal::ConstantInitialized);

  inline CharacterSelected(const CharacterSelected& from)
      : CharacterSelected(nullptr, from) {}
  CharacterSelected(CharacterSelected&& from) noexcept
    : CharacterSelected() {
    *this = ::std::move(from);
  }

  inline CharacterSelected& operator=(const CharacterSelected& from) {
    CopyFrom(from);
    return *this;
  }
  inline CharacterSelected& operator=(CharacterSelected&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CharacterSelected& default_instance() {
    return *internal_default_instance();
  }
  static inline const CharacterSelected* internal_default_instance() {
    return reinterpret_cast<const CharacterSelected*>(
               &_CharacterSelected_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(CharacterSelected& a, CharacterSelected& b) {
    a.Swap(&b);
  }
  inline void Swap(CharacterSelected* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CharacterSelected* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CharacterSelected* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CharacterSelected>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CharacterSelected& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const CharacterSelected& from) {
    CharacterSelected::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CharacterSelected* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "rtech.liveapi.CharacterSelected";
  }
  protected:
  explicit CharacterSelected(::google::protobuf::Arena* arena);
  CharacterSelected(::google::protobuf::Arena* arena, const CharacterSelected& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCategoryFieldNumber = 2,
    kPlayerFieldNumber = 3,
    kTimestampFieldNumber = 1,
  };
  // string category = 2;
  void clear_category() ;
  const std::string& category() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_category(Arg_&& arg, Args_... args);
  std::string* mutable_category();
  PROTOBUF_NODISCARD std::string* release_category();
  void set_allocated_category(std::string* value);

  private:
  const std::string& _internal_category() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_category(
      const std::string& value);
  std::string* _internal_mutable_category();

  public:
  // .rtech.liveapi.Player player = 3;
  bool has_player() const;
  void clear_player() ;
  const ::rtech::liveapi::Player& player() const;
  PROTOBUF_NODISCARD ::rtech::liveapi::Player* release_player();
  ::rtech::liveapi::Player* mutable_player();
  void set_allocated_player(::rtech::liveapi::Player* value);
  void unsafe_arena_set_allocated_player(::rtech::liveapi::Player* value);
  ::rtech::liveapi::Player* unsafe_arena_release_player();

  private:
  const ::rtech::liveapi::Player& _internal_player() const;
  ::rtech::liveapi::Player* _internal_mutable_player();

  public:
  // uint64 timestamp = 1;
  void clear_timestamp() ;
  ::uint64_t timestamp() const;
  void set_timestamp(::uint64_t value);

  private:
  ::uint64_t _internal_timestamp() const;
  void _internal_set_timestamp(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:rtech.liveapi.CharacterSelected)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      48, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr category_;
    ::rtech::liveapi::Player* player_;
    ::uint64_t timestamp_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_events_2eproto;
};// -------------------------------------------------------------------

class BlackMarketAction final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rtech.liveapi.BlackMarketAction) */ {
 public:
  inline BlackMarketAction() : BlackMarketAction(nullptr) {}
  ~BlackMarketAction() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR BlackMarketAction(::google::protobuf::internal::ConstantInitialized);

  inline BlackMarketAction(const BlackMarketAction& from)
      : BlackMarketAction(nullptr, from) {}
  BlackMarketAction(BlackMarketAction&& from) noexcept
    : BlackMarketAction() {
    *this = ::std::move(from);
  }

  inline BlackMarketAction& operator=(const BlackMarketAction& from) {
    CopyFrom(from);
    return *this;
  }
  inline BlackMarketAction& operator=(BlackMarketAction&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BlackMarketAction& default_instance() {
    return *internal_default_instance();
  }
  static inline const BlackMarketAction* internal_default_instance() {
    return reinterpret_cast<const BlackMarketAction*>(
               &_BlackMarketAction_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    40;

  friend void swap(BlackMarketAction& a, BlackMarketAction& b) {
    a.Swap(&b);
  }
  inline void Swap(BlackMarketAction* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BlackMarketAction* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BlackMarketAction* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BlackMarketAction>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const BlackMarketAction& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const BlackMarketAction& from) {
    BlackMarketAction::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(BlackMarketAction* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "rtech.liveapi.BlackMarketAction";
  }
  protected:
  explicit BlackMarketAction(::google::protobuf::Arena* arena);
  BlackMarketAction(::google::protobuf::Arena* arena, const BlackMarketAction& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCategoryFieldNumber = 2,
    kItemFieldNumber = 4,
    kPlayerFieldNumber = 3,
    kTimestampFieldNumber = 1,
  };
  // string category = 2;
  void clear_category() ;
  const std::string& category() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_category(Arg_&& arg, Args_... args);
  std::string* mutable_category();
  PROTOBUF_NODISCARD std::string* release_category();
  void set_allocated_category(std::string* value);

  private:
  const std::string& _internal_category() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_category(
      const std::string& value);
  std::string* _internal_mutable_category();

  public:
  // string item = 4;
  void clear_item() ;
  const std::string& item() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_item(Arg_&& arg, Args_... args);
  std::string* mutable_item();
  PROTOBUF_NODISCARD std::string* release_item();
  void set_allocated_item(std::string* value);

  private:
  const std::string& _internal_item() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_item(
      const std::string& value);
  std::string* _internal_mutable_item();

  public:
  // .rtech.liveapi.Player player = 3;
  bool has_player() const;
  void clear_player() ;
  const ::rtech::liveapi::Player& player() const;
  PROTOBUF_NODISCARD ::rtech::liveapi::Player* release_player();
  ::rtech::liveapi::Player* mutable_player();
  void set_allocated_player(::rtech::liveapi::Player* value);
  void unsafe_arena_set_allocated_player(::rtech::liveapi::Player* value);
  ::rtech::liveapi::Player* unsafe_arena_release_player();

  private:
  const ::rtech::liveapi::Player& _internal_player() const;
  ::rtech::liveapi::Player* _internal_mutable_player();

  public:
  // uint64 timestamp = 1;
  void clear_timestamp() ;
  ::uint64_t timestamp() const;
  void set_timestamp(::uint64_t value);

  private:
  ::uint64_t _internal_timestamp() const;
  void _internal_set_timestamp(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:rtech.liveapi.BlackMarketAction)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 1,
      52, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr category_;
    ::google::protobuf::internal::ArenaStringPtr item_;
    ::rtech::liveapi::Player* player_;
    ::uint64_t timestamp_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_events_2eproto;
};// -------------------------------------------------------------------

class BannerCollected final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rtech.liveapi.BannerCollected) */ {
 public:
  inline BannerCollected() : BannerCollected(nullptr) {}
  ~BannerCollected() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR BannerCollected(::google::protobuf::internal::ConstantInitialized);

  inline BannerCollected(const BannerCollected& from)
      : BannerCollected(nullptr, from) {}
  BannerCollected(BannerCollected&& from) noexcept
    : BannerCollected() {
    *this = ::std::move(from);
  }

  inline BannerCollected& operator=(const BannerCollected& from) {
    CopyFrom(from);
    return *this;
  }
  inline BannerCollected& operator=(BannerCollected&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BannerCollected& default_instance() {
    return *internal_default_instance();
  }
  static inline const BannerCollected* internal_default_instance() {
    return reinterpret_cast<const BannerCollected*>(
               &_BannerCollected_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  friend void swap(BannerCollected& a, BannerCollected& b) {
    a.Swap(&b);
  }
  inline void Swap(BannerCollected* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BannerCollected* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BannerCollected* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BannerCollected>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const BannerCollected& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const BannerCollected& from) {
    BannerCollected::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(BannerCollected* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "rtech.liveapi.BannerCollected";
  }
  protected:
  explicit BannerCollected(::google::protobuf::Arena* arena);
  BannerCollected(::google::protobuf::Arena* arena, const BannerCollected& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCategoryFieldNumber = 2,
    kPlayerFieldNumber = 3,
    kCollectedFieldNumber = 4,
    kTimestampFieldNumber = 1,
  };
  // string category = 2;
  void clear_category() ;
  const std::string& category() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_category(Arg_&& arg, Args_... args);
  std::string* mutable_category();
  PROTOBUF_NODISCARD std::string* release_category();
  void set_allocated_category(std::string* value);

  private:
  const std::string& _internal_category() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_category(
      const std::string& value);
  std::string* _internal_mutable_category();

  public:
  // .rtech.liveapi.Player player = 3;
  bool has_player() const;
  void clear_player() ;
  const ::rtech::liveapi::Player& player() const;
  PROTOBUF_NODISCARD ::rtech::liveapi::Player* release_player();
  ::rtech::liveapi::Player* mutable_player();
  void set_allocated_player(::rtech::liveapi::Player* value);
  void unsafe_arena_set_allocated_player(::rtech::liveapi::Player* value);
  ::rtech::liveapi::Player* unsafe_arena_release_player();

  private:
  const ::rtech::liveapi::Player& _internal_player() const;
  ::rtech::liveapi::Player* _internal_mutable_player();

  public:
  // .rtech.liveapi.Player collected = 4;
  bool has_collected() const;
  void clear_collected() ;
  const ::rtech::liveapi::Player& collected() const;
  PROTOBUF_NODISCARD ::rtech::liveapi::Player* release_collected();
  ::rtech::liveapi::Player* mutable_collected();
  void set_allocated_collected(::rtech::liveapi::Player* value);
  void unsafe_arena_set_allocated_collected(::rtech::liveapi::Player* value);
  ::rtech::liveapi::Player* unsafe_arena_release_collected();

  private:
  const ::rtech::liveapi::Player& _internal_collected() const;
  ::rtech::liveapi::Player* _internal_mutable_collected();

  public:
  // uint64 timestamp = 1;
  void clear_timestamp() ;
  ::uint64_t timestamp() const;
  void set_timestamp(::uint64_t value);

  private:
  ::uint64_t _internal_timestamp() const;
  void _internal_set_timestamp(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:rtech.liveapi.BannerCollected)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 2,
      46, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr category_;
    ::rtech::liveapi::Player* player_;
    ::rtech::liveapi::Player* collected_;
    ::uint64_t timestamp_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_events_2eproto;
};// -------------------------------------------------------------------

class ArenasItemSelected final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rtech.liveapi.ArenasItemSelected) */ {
 public:
  inline ArenasItemSelected() : ArenasItemSelected(nullptr) {}
  ~ArenasItemSelected() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ArenasItemSelected(::google::protobuf::internal::ConstantInitialized);

  inline ArenasItemSelected(const ArenasItemSelected& from)
      : ArenasItemSelected(nullptr, from) {}
  ArenasItemSelected(ArenasItemSelected&& from) noexcept
    : ArenasItemSelected() {
    *this = ::std::move(from);
  }

  inline ArenasItemSelected& operator=(const ArenasItemSelected& from) {
    CopyFrom(from);
    return *this;
  }
  inline ArenasItemSelected& operator=(ArenasItemSelected&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ArenasItemSelected& default_instance() {
    return *internal_default_instance();
  }
  static inline const ArenasItemSelected* internal_default_instance() {
    return reinterpret_cast<const ArenasItemSelected*>(
               &_ArenasItemSelected_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(ArenasItemSelected& a, ArenasItemSelected& b) {
    a.Swap(&b);
  }
  inline void Swap(ArenasItemSelected* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ArenasItemSelected* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ArenasItemSelected* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ArenasItemSelected>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ArenasItemSelected& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ArenasItemSelected& from) {
    ArenasItemSelected::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ArenasItemSelected* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "rtech.liveapi.ArenasItemSelected";
  }
  protected:
  explicit ArenasItemSelected(::google::protobuf::Arena* arena);
  ArenasItemSelected(::google::protobuf::Arena* arena, const ArenasItemSelected& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCategoryFieldNumber = 2,
    kItemFieldNumber = 4,
    kPlayerFieldNumber = 3,
    kTimestampFieldNumber = 1,
    kQuantityFieldNumber = 5,
  };
  // string category = 2;
  void clear_category() ;
  const std::string& category() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_category(Arg_&& arg, Args_... args);
  std::string* mutable_category();
  PROTOBUF_NODISCARD std::string* release_category();
  void set_allocated_category(std::string* value);

  private:
  const std::string& _internal_category() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_category(
      const std::string& value);
  std::string* _internal_mutable_category();

  public:
  // string item = 4;
  void clear_item() ;
  const std::string& item() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_item(Arg_&& arg, Args_... args);
  std::string* mutable_item();
  PROTOBUF_NODISCARD std::string* release_item();
  void set_allocated_item(std::string* value);

  private:
  const std::string& _internal_item() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_item(
      const std::string& value);
  std::string* _internal_mutable_item();

  public:
  // .rtech.liveapi.Player player = 3;
  bool has_player() const;
  void clear_player() ;
  const ::rtech::liveapi::Player& player() const;
  PROTOBUF_NODISCARD ::rtech::liveapi::Player* release_player();
  ::rtech::liveapi::Player* mutable_player();
  void set_allocated_player(::rtech::liveapi::Player* value);
  void unsafe_arena_set_allocated_player(::rtech::liveapi::Player* value);
  ::rtech::liveapi::Player* unsafe_arena_release_player();

  private:
  const ::rtech::liveapi::Player& _internal_player() const;
  ::rtech::liveapi::Player* _internal_mutable_player();

  public:
  // uint64 timestamp = 1;
  void clear_timestamp() ;
  ::uint64_t timestamp() const;
  void set_timestamp(::uint64_t value);

  private:
  ::uint64_t _internal_timestamp() const;
  void _internal_set_timestamp(::uint64_t value);

  public:
  // int32 quantity = 5;
  void clear_quantity() ;
  ::int32_t quantity() const;
  void set_quantity(::int32_t value);

  private:
  ::int32_t _internal_quantity() const;
  void _internal_set_quantity(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:rtech.liveapi.ArenasItemSelected)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 1,
      53, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr category_;
    ::google::protobuf::internal::ArenaStringPtr item_;
    ::rtech::liveapi::Player* player_;
    ::uint64_t timestamp_;
    ::int32_t quantity_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_events_2eproto;
};// -------------------------------------------------------------------

class ArenasItemDeselected final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rtech.liveapi.ArenasItemDeselected) */ {
 public:
  inline ArenasItemDeselected() : ArenasItemDeselected(nullptr) {}
  ~ArenasItemDeselected() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ArenasItemDeselected(::google::protobuf::internal::ConstantInitialized);

  inline ArenasItemDeselected(const ArenasItemDeselected& from)
      : ArenasItemDeselected(nullptr, from) {}
  ArenasItemDeselected(ArenasItemDeselected&& from) noexcept
    : ArenasItemDeselected() {
    *this = ::std::move(from);
  }

  inline ArenasItemDeselected& operator=(const ArenasItemDeselected& from) {
    CopyFrom(from);
    return *this;
  }
  inline ArenasItemDeselected& operator=(ArenasItemDeselected&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ArenasItemDeselected& default_instance() {
    return *internal_default_instance();
  }
  static inline const ArenasItemDeselected* internal_default_instance() {
    return reinterpret_cast<const ArenasItemDeselected*>(
               &_ArenasItemDeselected_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(ArenasItemDeselected& a, ArenasItemDeselected& b) {
    a.Swap(&b);
  }
  inline void Swap(ArenasItemDeselected* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ArenasItemDeselected* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ArenasItemDeselected* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ArenasItemDeselected>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ArenasItemDeselected& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ArenasItemDeselected& from) {
    ArenasItemDeselected::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ArenasItemDeselected* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "rtech.liveapi.ArenasItemDeselected";
  }
  protected:
  explicit ArenasItemDeselected(::google::protobuf::Arena* arena);
  ArenasItemDeselected(::google::protobuf::Arena* arena, const ArenasItemDeselected& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCategoryFieldNumber = 2,
    kItemFieldNumber = 4,
    kPlayerFieldNumber = 3,
    kTimestampFieldNumber = 1,
    kQuantityFieldNumber = 5,
  };
  // string category = 2;
  void clear_category() ;
  const std::string& category() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_category(Arg_&& arg, Args_... args);
  std::string* mutable_category();
  PROTOBUF_NODISCARD std::string* release_category();
  void set_allocated_category(std::string* value);

  private:
  const std::string& _internal_category() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_category(
      const std::string& value);
  std::string* _internal_mutable_category();

  public:
  // string item = 4;
  void clear_item() ;
  const std::string& item() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_item(Arg_&& arg, Args_... args);
  std::string* mutable_item();
  PROTOBUF_NODISCARD std::string* release_item();
  void set_allocated_item(std::string* value);

  private:
  const std::string& _internal_item() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_item(
      const std::string& value);
  std::string* _internal_mutable_item();

  public:
  // .rtech.liveapi.Player player = 3;
  bool has_player() const;
  void clear_player() ;
  const ::rtech::liveapi::Player& player() const;
  PROTOBUF_NODISCARD ::rtech::liveapi::Player* release_player();
  ::rtech::liveapi::Player* mutable_player();
  void set_allocated_player(::rtech::liveapi::Player* value);
  void unsafe_arena_set_allocated_player(::rtech::liveapi::Player* value);
  ::rtech::liveapi::Player* unsafe_arena_release_player();

  private:
  const ::rtech::liveapi::Player& _internal_player() const;
  ::rtech::liveapi::Player* _internal_mutable_player();

  public:
  // uint64 timestamp = 1;
  void clear_timestamp() ;
  ::uint64_t timestamp() const;
  void set_timestamp(::uint64_t value);

  private:
  ::uint64_t _internal_timestamp() const;
  void _internal_set_timestamp(::uint64_t value);

  public:
  // int32 quantity = 5;
  void clear_quantity() ;
  ::int32_t quantity() const;
  void set_quantity(::int32_t value);

  private:
  ::int32_t _internal_quantity() const;
  void _internal_set_quantity(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:rtech.liveapi.ArenasItemDeselected)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 1,
      55, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr category_;
    ::google::protobuf::internal::ArenaStringPtr item_;
    ::rtech::liveapi::Player* player_;
    ::uint64_t timestamp_;
    ::int32_t quantity_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_events_2eproto;
};// -------------------------------------------------------------------

class AmmoUsed final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rtech.liveapi.AmmoUsed) */ {
 public:
  inline AmmoUsed() : AmmoUsed(nullptr) {}
  ~AmmoUsed() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AmmoUsed(::google::protobuf::internal::ConstantInitialized);

  inline AmmoUsed(const AmmoUsed& from)
      : AmmoUsed(nullptr, from) {}
  AmmoUsed(AmmoUsed&& from) noexcept
    : AmmoUsed() {
    *this = ::std::move(from);
  }

  inline AmmoUsed& operator=(const AmmoUsed& from) {
    CopyFrom(from);
    return *this;
  }
  inline AmmoUsed& operator=(AmmoUsed&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AmmoUsed& default_instance() {
    return *internal_default_instance();
  }
  static inline const AmmoUsed* internal_default_instance() {
    return reinterpret_cast<const AmmoUsed*>(
               &_AmmoUsed_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    43;

  friend void swap(AmmoUsed& a, AmmoUsed& b) {
    a.Swap(&b);
  }
  inline void Swap(AmmoUsed* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AmmoUsed* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AmmoUsed* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AmmoUsed>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AmmoUsed& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const AmmoUsed& from) {
    AmmoUsed::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AmmoUsed* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "rtech.liveapi.AmmoUsed";
  }
  protected:
  explicit AmmoUsed(::google::protobuf::Arena* arena);
  AmmoUsed(::google::protobuf::Arena* arena, const AmmoUsed& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCategoryFieldNumber = 2,
    kAmmoTypeFieldNumber = 4,
    kPlayerFieldNumber = 3,
    kTimestampFieldNumber = 1,
    kAmountUsedFieldNumber = 5,
    kOldAmmoCountFieldNumber = 6,
    kNewAmmoCountFieldNumber = 7,
  };
  // string category = 2;
  void clear_category() ;
  const std::string& category() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_category(Arg_&& arg, Args_... args);
  std::string* mutable_category();
  PROTOBUF_NODISCARD std::string* release_category();
  void set_allocated_category(std::string* value);

  private:
  const std::string& _internal_category() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_category(
      const std::string& value);
  std::string* _internal_mutable_category();

  public:
  // string ammoType = 4;
  void clear_ammotype() ;
  const std::string& ammotype() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_ammotype(Arg_&& arg, Args_... args);
  std::string* mutable_ammotype();
  PROTOBUF_NODISCARD std::string* release_ammotype();
  void set_allocated_ammotype(std::string* value);

  private:
  const std::string& _internal_ammotype() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ammotype(
      const std::string& value);
  std::string* _internal_mutable_ammotype();

  public:
  // .rtech.liveapi.Player player = 3;
  bool has_player() const;
  void clear_player() ;
  const ::rtech::liveapi::Player& player() const;
  PROTOBUF_NODISCARD ::rtech::liveapi::Player* release_player();
  ::rtech::liveapi::Player* mutable_player();
  void set_allocated_player(::rtech::liveapi::Player* value);
  void unsafe_arena_set_allocated_player(::rtech::liveapi::Player* value);
  ::rtech::liveapi::Player* unsafe_arena_release_player();

  private:
  const ::rtech::liveapi::Player& _internal_player() const;
  ::rtech::liveapi::Player* _internal_mutable_player();

  public:
  // uint64 timestamp = 1;
  void clear_timestamp() ;
  ::uint64_t timestamp() const;
  void set_timestamp(::uint64_t value);

  private:
  ::uint64_t _internal_timestamp() const;
  void _internal_set_timestamp(::uint64_t value);

  public:
  // uint32 amountUsed = 5;
  void clear_amountused() ;
  ::uint32_t amountused() const;
  void set_amountused(::uint32_t value);

  private:
  ::uint32_t _internal_amountused() const;
  void _internal_set_amountused(::uint32_t value);

  public:
  // uint32 oldAmmoCount = 6;
  void clear_oldammocount() ;
  ::uint32_t oldammocount() const;
  void set_oldammocount(::uint32_t value);

  private:
  ::uint32_t _internal_oldammocount() const;
  void _internal_set_oldammocount(::uint32_t value);

  public:
  // uint32 newAmmoCount = 7;
  void clear_newammocount() ;
  ::uint32_t newammocount() const;
  void set_newammocount(::uint32_t value);

  private:
  ::uint32_t _internal_newammocount() const;
  void _internal_set_newammocount(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:rtech.liveapi.AmmoUsed)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 7, 1,
      47, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr category_;
    ::google::protobuf::internal::ArenaStringPtr ammotype_;
    ::rtech::liveapi::Player* player_;
    ::uint64_t timestamp_;
    ::uint32_t amountused_;
    ::uint32_t oldammocount_;
    ::uint32_t newammocount_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_events_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// Vector3

// float x = 1;
inline void Vector3::clear_x() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.x_ = 0;
}
inline float Vector3::x() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.Vector3.x)
  return _internal_x();
}
inline void Vector3::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:rtech.liveapi.Vector3.x)
}
inline float Vector3::_internal_x() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.x_;
}
inline void Vector3::_internal_set_x(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.x_ = value;
}

// float y = 2;
inline void Vector3::clear_y() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.y_ = 0;
}
inline float Vector3::y() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.Vector3.y)
  return _internal_y();
}
inline void Vector3::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:rtech.liveapi.Vector3.y)
}
inline float Vector3::_internal_y() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.y_;
}
inline void Vector3::_internal_set_y(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.y_ = value;
}

// float z = 3;
inline void Vector3::clear_z() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.z_ = 0;
}
inline float Vector3::z() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.Vector3.z)
  return _internal_z();
}
inline void Vector3::set_z(float value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:rtech.liveapi.Vector3.z)
}
inline float Vector3::_internal_z() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.z_;
}
inline void Vector3::_internal_set_z(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.z_ = value;
}

// -------------------------------------------------------------------

// Player

// string name = 1;
inline void Player::clear_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Player::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rtech.liveapi.Player.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Player::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:rtech.liveapi.Player.name)
}
inline std::string* Player::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.Player.name)
  return _s;
}
inline const std::string& Player::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void Player::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(value, GetArena());
}
inline std::string* Player::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* Player::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:rtech.liveapi.Player.name)
  return _impl_.name_.Release();
}
inline void Player::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.Player.name)
}

// uint32 teamId = 2;
inline void Player::clear_teamid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.teamid_ = 0u;
}
inline ::uint32_t Player::teamid() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.Player.teamId)
  return _internal_teamid();
}
inline void Player::set_teamid(::uint32_t value) {
  _internal_set_teamid(value);
  // @@protoc_insertion_point(field_set:rtech.liveapi.Player.teamId)
}
inline ::uint32_t Player::_internal_teamid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.teamid_;
}
inline void Player::_internal_set_teamid(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.teamid_ = value;
}

// .rtech.liveapi.Vector3 pos = 3;
inline bool Player::has_pos() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.pos_ != nullptr);
  return value;
}
inline void Player::clear_pos() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.pos_ != nullptr) _impl_.pos_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::rtech::liveapi::Vector3& Player::_internal_pos() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::rtech::liveapi::Vector3* p = _impl_.pos_;
  return p != nullptr ? *p : reinterpret_cast<const ::rtech::liveapi::Vector3&>(::rtech::liveapi::_Vector3_default_instance_);
}
inline const ::rtech::liveapi::Vector3& Player::pos() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rtech.liveapi.Player.pos)
  return _internal_pos();
}
inline void Player::unsafe_arena_set_allocated_pos(::rtech::liveapi::Vector3* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.pos_);
  }
  _impl_.pos_ = reinterpret_cast<::rtech::liveapi::Vector3*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rtech.liveapi.Player.pos)
}
inline ::rtech::liveapi::Vector3* Player::release_pos() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::rtech::liveapi::Vector3* released = _impl_.pos_;
  _impl_.pos_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::rtech::liveapi::Vector3* Player::unsafe_arena_release_pos() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:rtech.liveapi.Player.pos)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::rtech::liveapi::Vector3* temp = _impl_.pos_;
  _impl_.pos_ = nullptr;
  return temp;
}
inline ::rtech::liveapi::Vector3* Player::_internal_mutable_pos() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.pos_ == nullptr) {
    auto* p = CreateMaybeMessage<::rtech::liveapi::Vector3>(GetArena());
    _impl_.pos_ = reinterpret_cast<::rtech::liveapi::Vector3*>(p);
  }
  return _impl_.pos_;
}
inline ::rtech::liveapi::Vector3* Player::mutable_pos() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::rtech::liveapi::Vector3* _msg = _internal_mutable_pos();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.Player.pos)
  return _msg;
}
inline void Player::set_allocated_pos(::rtech::liveapi::Vector3* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::rtech::liveapi::Vector3*>(_impl_.pos_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::rtech::liveapi::Vector3*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.pos_ = reinterpret_cast<::rtech::liveapi::Vector3*>(value);
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.Player.pos)
}

// .rtech.liveapi.Vector3 angles = 4;
inline bool Player::has_angles() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.angles_ != nullptr);
  return value;
}
inline void Player::clear_angles() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.angles_ != nullptr) _impl_.angles_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::rtech::liveapi::Vector3& Player::_internal_angles() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::rtech::liveapi::Vector3* p = _impl_.angles_;
  return p != nullptr ? *p : reinterpret_cast<const ::rtech::liveapi::Vector3&>(::rtech::liveapi::_Vector3_default_instance_);
}
inline const ::rtech::liveapi::Vector3& Player::angles() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rtech.liveapi.Player.angles)
  return _internal_angles();
}
inline void Player::unsafe_arena_set_allocated_angles(::rtech::liveapi::Vector3* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.angles_);
  }
  _impl_.angles_ = reinterpret_cast<::rtech::liveapi::Vector3*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rtech.liveapi.Player.angles)
}
inline ::rtech::liveapi::Vector3* Player::release_angles() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::rtech::liveapi::Vector3* released = _impl_.angles_;
  _impl_.angles_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::rtech::liveapi::Vector3* Player::unsafe_arena_release_angles() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:rtech.liveapi.Player.angles)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::rtech::liveapi::Vector3* temp = _impl_.angles_;
  _impl_.angles_ = nullptr;
  return temp;
}
inline ::rtech::liveapi::Vector3* Player::_internal_mutable_angles() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.angles_ == nullptr) {
    auto* p = CreateMaybeMessage<::rtech::liveapi::Vector3>(GetArena());
    _impl_.angles_ = reinterpret_cast<::rtech::liveapi::Vector3*>(p);
  }
  return _impl_.angles_;
}
inline ::rtech::liveapi::Vector3* Player::mutable_angles() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::rtech::liveapi::Vector3* _msg = _internal_mutable_angles();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.Player.angles)
  return _msg;
}
inline void Player::set_allocated_angles(::rtech::liveapi::Vector3* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::rtech::liveapi::Vector3*>(_impl_.angles_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::rtech::liveapi::Vector3*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.angles_ = reinterpret_cast<::rtech::liveapi::Vector3*>(value);
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.Player.angles)
}

// uint32 currentHealth = 5;
inline void Player::clear_currenthealth() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.currenthealth_ = 0u;
}
inline ::uint32_t Player::currenthealth() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.Player.currentHealth)
  return _internal_currenthealth();
}
inline void Player::set_currenthealth(::uint32_t value) {
  _internal_set_currenthealth(value);
  // @@protoc_insertion_point(field_set:rtech.liveapi.Player.currentHealth)
}
inline ::uint32_t Player::_internal_currenthealth() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.currenthealth_;
}
inline void Player::_internal_set_currenthealth(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.currenthealth_ = value;
}

// uint32 maxHealth = 6;
inline void Player::clear_maxhealth() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.maxhealth_ = 0u;
}
inline ::uint32_t Player::maxhealth() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.Player.maxHealth)
  return _internal_maxhealth();
}
inline void Player::set_maxhealth(::uint32_t value) {
  _internal_set_maxhealth(value);
  // @@protoc_insertion_point(field_set:rtech.liveapi.Player.maxHealth)
}
inline ::uint32_t Player::_internal_maxhealth() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.maxhealth_;
}
inline void Player::_internal_set_maxhealth(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.maxhealth_ = value;
}

// uint32 shieldHealth = 7;
inline void Player::clear_shieldhealth() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.shieldhealth_ = 0u;
}
inline ::uint32_t Player::shieldhealth() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.Player.shieldHealth)
  return _internal_shieldhealth();
}
inline void Player::set_shieldhealth(::uint32_t value) {
  _internal_set_shieldhealth(value);
  // @@protoc_insertion_point(field_set:rtech.liveapi.Player.shieldHealth)
}
inline ::uint32_t Player::_internal_shieldhealth() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.shieldhealth_;
}
inline void Player::_internal_set_shieldhealth(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.shieldhealth_ = value;
}

// uint32 shieldMaxHealth = 8;
inline void Player::clear_shieldmaxhealth() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.shieldmaxhealth_ = 0u;
}
inline ::uint32_t Player::shieldmaxhealth() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.Player.shieldMaxHealth)
  return _internal_shieldmaxhealth();
}
inline void Player::set_shieldmaxhealth(::uint32_t value) {
  _internal_set_shieldmaxhealth(value);
  // @@protoc_insertion_point(field_set:rtech.liveapi.Player.shieldMaxHealth)
}
inline ::uint32_t Player::_internal_shieldmaxhealth() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.shieldmaxhealth_;
}
inline void Player::_internal_set_shieldmaxhealth(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.shieldmaxhealth_ = value;
}

// string nucleusHash = 9;
inline void Player::clear_nucleushash() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.nucleushash_.ClearToEmpty();
}
inline const std::string& Player::nucleushash() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rtech.liveapi.Player.nucleusHash)
  return _internal_nucleushash();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Player::set_nucleushash(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.nucleushash_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:rtech.liveapi.Player.nucleusHash)
}
inline std::string* Player::mutable_nucleushash() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_nucleushash();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.Player.nucleusHash)
  return _s;
}
inline const std::string& Player::_internal_nucleushash() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.nucleushash_.Get();
}
inline void Player::_internal_set_nucleushash(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.nucleushash_.Set(value, GetArena());
}
inline std::string* Player::_internal_mutable_nucleushash() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.nucleushash_.Mutable( GetArena());
}
inline std::string* Player::release_nucleushash() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:rtech.liveapi.Player.nucleusHash)
  return _impl_.nucleushash_.Release();
}
inline void Player::set_allocated_nucleushash(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.nucleushash_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.nucleushash_.IsDefault()) {
          _impl_.nucleushash_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.Player.nucleusHash)
}

// string hardwareName = 10;
inline void Player::clear_hardwarename() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.hardwarename_.ClearToEmpty();
}
inline const std::string& Player::hardwarename() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rtech.liveapi.Player.hardwareName)
  return _internal_hardwarename();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Player::set_hardwarename(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.hardwarename_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:rtech.liveapi.Player.hardwareName)
}
inline std::string* Player::mutable_hardwarename() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_hardwarename();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.Player.hardwareName)
  return _s;
}
inline const std::string& Player::_internal_hardwarename() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.hardwarename_.Get();
}
inline void Player::_internal_set_hardwarename(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.hardwarename_.Set(value, GetArena());
}
inline std::string* Player::_internal_mutable_hardwarename() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.hardwarename_.Mutable( GetArena());
}
inline std::string* Player::release_hardwarename() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:rtech.liveapi.Player.hardwareName)
  return _impl_.hardwarename_.Release();
}
inline void Player::set_allocated_hardwarename(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.hardwarename_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.hardwarename_.IsDefault()) {
          _impl_.hardwarename_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.Player.hardwareName)
}

// string teamName = 11;
inline void Player::clear_teamname() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.teamname_.ClearToEmpty();
}
inline const std::string& Player::teamname() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rtech.liveapi.Player.teamName)
  return _internal_teamname();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Player::set_teamname(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.teamname_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:rtech.liveapi.Player.teamName)
}
inline std::string* Player::mutable_teamname() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_teamname();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.Player.teamName)
  return _s;
}
inline const std::string& Player::_internal_teamname() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.teamname_.Get();
}
inline void Player::_internal_set_teamname(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.teamname_.Set(value, GetArena());
}
inline std::string* Player::_internal_mutable_teamname() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.teamname_.Mutable( GetArena());
}
inline std::string* Player::release_teamname() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:rtech.liveapi.Player.teamName)
  return _impl_.teamname_.Release();
}
inline void Player::set_allocated_teamname(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.teamname_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.teamname_.IsDefault()) {
          _impl_.teamname_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.Player.teamName)
}

// uint32 squadIndex = 12;
inline void Player::clear_squadindex() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.squadindex_ = 0u;
}
inline ::uint32_t Player::squadindex() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.Player.squadIndex)
  return _internal_squadindex();
}
inline void Player::set_squadindex(::uint32_t value) {
  _internal_set_squadindex(value);
  // @@protoc_insertion_point(field_set:rtech.liveapi.Player.squadIndex)
}
inline ::uint32_t Player::_internal_squadindex() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.squadindex_;
}
inline void Player::_internal_set_squadindex(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.squadindex_ = value;
}

// string character = 13;
inline void Player::clear_character() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.character_.ClearToEmpty();
}
inline const std::string& Player::character() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rtech.liveapi.Player.character)
  return _internal_character();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Player::set_character(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.character_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:rtech.liveapi.Player.character)
}
inline std::string* Player::mutable_character() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_character();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.Player.character)
  return _s;
}
inline const std::string& Player::_internal_character() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.character_.Get();
}
inline void Player::_internal_set_character(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.character_.Set(value, GetArena());
}
inline std::string* Player::_internal_mutable_character() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.character_.Mutable( GetArena());
}
inline std::string* Player::release_character() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:rtech.liveapi.Player.character)
  return _impl_.character_.Release();
}
inline void Player::set_allocated_character(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.character_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.character_.IsDefault()) {
          _impl_.character_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.Player.character)
}

// string skin = 14;
inline void Player::clear_skin() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.skin_.ClearToEmpty();
}
inline const std::string& Player::skin() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rtech.liveapi.Player.skin)
  return _internal_skin();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Player::set_skin(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.skin_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:rtech.liveapi.Player.skin)
}
inline std::string* Player::mutable_skin() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_skin();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.Player.skin)
  return _s;
}
inline const std::string& Player::_internal_skin() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.skin_.Get();
}
inline void Player::_internal_set_skin(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.skin_.Set(value, GetArena());
}
inline std::string* Player::_internal_mutable_skin() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.skin_.Mutable( GetArena());
}
inline std::string* Player::release_skin() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:rtech.liveapi.Player.skin)
  return _impl_.skin_.Release();
}
inline void Player::set_allocated_skin(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.skin_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.skin_.IsDefault()) {
          _impl_.skin_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.Player.skin)
}

// -------------------------------------------------------------------

// CustomMatch_LobbyPlayer

// string name = 1;
inline void CustomMatch_LobbyPlayer::clear_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& CustomMatch_LobbyPlayer::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rtech.liveapi.CustomMatch_LobbyPlayer.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CustomMatch_LobbyPlayer::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:rtech.liveapi.CustomMatch_LobbyPlayer.name)
}
inline std::string* CustomMatch_LobbyPlayer::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.CustomMatch_LobbyPlayer.name)
  return _s;
}
inline const std::string& CustomMatch_LobbyPlayer::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void CustomMatch_LobbyPlayer::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(value, GetArena());
}
inline std::string* CustomMatch_LobbyPlayer::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* CustomMatch_LobbyPlayer::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:rtech.liveapi.CustomMatch_LobbyPlayer.name)
  return _impl_.name_.Release();
}
inline void CustomMatch_LobbyPlayer::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.CustomMatch_LobbyPlayer.name)
}

// uint32 teamId = 2;
inline void CustomMatch_LobbyPlayer::clear_teamid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.teamid_ = 0u;
}
inline ::uint32_t CustomMatch_LobbyPlayer::teamid() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.CustomMatch_LobbyPlayer.teamId)
  return _internal_teamid();
}
inline void CustomMatch_LobbyPlayer::set_teamid(::uint32_t value) {
  _internal_set_teamid(value);
  // @@protoc_insertion_point(field_set:rtech.liveapi.CustomMatch_LobbyPlayer.teamId)
}
inline ::uint32_t CustomMatch_LobbyPlayer::_internal_teamid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.teamid_;
}
inline void CustomMatch_LobbyPlayer::_internal_set_teamid(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.teamid_ = value;
}

// string nucleusHash = 3;
inline void CustomMatch_LobbyPlayer::clear_nucleushash() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.nucleushash_.ClearToEmpty();
}
inline const std::string& CustomMatch_LobbyPlayer::nucleushash() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rtech.liveapi.CustomMatch_LobbyPlayer.nucleusHash)
  return _internal_nucleushash();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CustomMatch_LobbyPlayer::set_nucleushash(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.nucleushash_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:rtech.liveapi.CustomMatch_LobbyPlayer.nucleusHash)
}
inline std::string* CustomMatch_LobbyPlayer::mutable_nucleushash() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_nucleushash();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.CustomMatch_LobbyPlayer.nucleusHash)
  return _s;
}
inline const std::string& CustomMatch_LobbyPlayer::_internal_nucleushash() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.nucleushash_.Get();
}
inline void CustomMatch_LobbyPlayer::_internal_set_nucleushash(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.nucleushash_.Set(value, GetArena());
}
inline std::string* CustomMatch_LobbyPlayer::_internal_mutable_nucleushash() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.nucleushash_.Mutable( GetArena());
}
inline std::string* CustomMatch_LobbyPlayer::release_nucleushash() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:rtech.liveapi.CustomMatch_LobbyPlayer.nucleusHash)
  return _impl_.nucleushash_.Release();
}
inline void CustomMatch_LobbyPlayer::set_allocated_nucleushash(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.nucleushash_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.nucleushash_.IsDefault()) {
          _impl_.nucleushash_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.CustomMatch_LobbyPlayer.nucleusHash)
}

// string hardwareName = 4;
inline void CustomMatch_LobbyPlayer::clear_hardwarename() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.hardwarename_.ClearToEmpty();
}
inline const std::string& CustomMatch_LobbyPlayer::hardwarename() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rtech.liveapi.CustomMatch_LobbyPlayer.hardwareName)
  return _internal_hardwarename();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CustomMatch_LobbyPlayer::set_hardwarename(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.hardwarename_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:rtech.liveapi.CustomMatch_LobbyPlayer.hardwareName)
}
inline std::string* CustomMatch_LobbyPlayer::mutable_hardwarename() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_hardwarename();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.CustomMatch_LobbyPlayer.hardwareName)
  return _s;
}
inline const std::string& CustomMatch_LobbyPlayer::_internal_hardwarename() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.hardwarename_.Get();
}
inline void CustomMatch_LobbyPlayer::_internal_set_hardwarename(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.hardwarename_.Set(value, GetArena());
}
inline std::string* CustomMatch_LobbyPlayer::_internal_mutable_hardwarename() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.hardwarename_.Mutable( GetArena());
}
inline std::string* CustomMatch_LobbyPlayer::release_hardwarename() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:rtech.liveapi.CustomMatch_LobbyPlayer.hardwareName)
  return _impl_.hardwarename_.Release();
}
inline void CustomMatch_LobbyPlayer::set_allocated_hardwarename(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.hardwarename_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.hardwarename_.IsDefault()) {
          _impl_.hardwarename_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.CustomMatch_LobbyPlayer.hardwareName)
}

// -------------------------------------------------------------------

// Datacenter

// uint64 timestamp = 1;
inline void Datacenter::clear_timestamp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.timestamp_ = ::uint64_t{0u};
}
inline ::uint64_t Datacenter::timestamp() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.Datacenter.timestamp)
  return _internal_timestamp();
}
inline void Datacenter::set_timestamp(::uint64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:rtech.liveapi.Datacenter.timestamp)
}
inline ::uint64_t Datacenter::_internal_timestamp() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.timestamp_;
}
inline void Datacenter::_internal_set_timestamp(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.timestamp_ = value;
}

// string category = 2;
inline void Datacenter::clear_category() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.category_.ClearToEmpty();
}
inline const std::string& Datacenter::category() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rtech.liveapi.Datacenter.category)
  return _internal_category();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Datacenter::set_category(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.category_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:rtech.liveapi.Datacenter.category)
}
inline std::string* Datacenter::mutable_category() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_category();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.Datacenter.category)
  return _s;
}
inline const std::string& Datacenter::_internal_category() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.category_.Get();
}
inline void Datacenter::_internal_set_category(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.category_.Set(value, GetArena());
}
inline std::string* Datacenter::_internal_mutable_category() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.category_.Mutable( GetArena());
}
inline std::string* Datacenter::release_category() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:rtech.liveapi.Datacenter.category)
  return _impl_.category_.Release();
}
inline void Datacenter::set_allocated_category(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.category_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.category_.IsDefault()) {
          _impl_.category_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.Datacenter.category)
}

// string name = 3;
inline void Datacenter::clear_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Datacenter::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rtech.liveapi.Datacenter.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Datacenter::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:rtech.liveapi.Datacenter.name)
}
inline std::string* Datacenter::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.Datacenter.name)
  return _s;
}
inline const std::string& Datacenter::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void Datacenter::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(value, GetArena());
}
inline std::string* Datacenter::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* Datacenter::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:rtech.liveapi.Datacenter.name)
  return _impl_.name_.Release();
}
inline void Datacenter::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.Datacenter.name)
}

// -------------------------------------------------------------------

// Version

// uint32 major_num = 1;
inline void Version::clear_major_num() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.major_num_ = 0u;
}
inline ::uint32_t Version::major_num() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.Version.major_num)
  return _internal_major_num();
}
inline void Version::set_major_num(::uint32_t value) {
  _internal_set_major_num(value);
  // @@protoc_insertion_point(field_set:rtech.liveapi.Version.major_num)
}
inline ::uint32_t Version::_internal_major_num() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.major_num_;
}
inline void Version::_internal_set_major_num(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.major_num_ = value;
}

// uint32 minor_num = 2;
inline void Version::clear_minor_num() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.minor_num_ = 0u;
}
inline ::uint32_t Version::minor_num() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.Version.minor_num)
  return _internal_minor_num();
}
inline void Version::set_minor_num(::uint32_t value) {
  _internal_set_minor_num(value);
  // @@protoc_insertion_point(field_set:rtech.liveapi.Version.minor_num)
}
inline ::uint32_t Version::_internal_minor_num() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.minor_num_;
}
inline void Version::_internal_set_minor_num(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.minor_num_ = value;
}

// uint32 build_stamp = 3;
inline void Version::clear_build_stamp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.build_stamp_ = 0u;
}
inline ::uint32_t Version::build_stamp() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.Version.build_stamp)
  return _internal_build_stamp();
}
inline void Version::set_build_stamp(::uint32_t value) {
  _internal_set_build_stamp(value);
  // @@protoc_insertion_point(field_set:rtech.liveapi.Version.build_stamp)
}
inline ::uint32_t Version::_internal_build_stamp() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.build_stamp_;
}
inline void Version::_internal_set_build_stamp(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.build_stamp_ = value;
}

// string revision = 4;
inline void Version::clear_revision() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.revision_.ClearToEmpty();
}
inline const std::string& Version::revision() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rtech.liveapi.Version.revision)
  return _internal_revision();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Version::set_revision(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.revision_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:rtech.liveapi.Version.revision)
}
inline std::string* Version::mutable_revision() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_revision();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.Version.revision)
  return _s;
}
inline const std::string& Version::_internal_revision() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.revision_.Get();
}
inline void Version::_internal_set_revision(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.revision_.Set(value, GetArena());
}
inline std::string* Version::_internal_mutable_revision() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.revision_.Mutable( GetArena());
}
inline std::string* Version::release_revision() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:rtech.liveapi.Version.revision)
  return _impl_.revision_.Release();
}
inline void Version::set_allocated_revision(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.revision_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.revision_.IsDefault()) {
          _impl_.revision_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.Version.revision)
}

// -------------------------------------------------------------------

// InventoryItem

// int32 quantity = 1;
inline void InventoryItem::clear_quantity() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.quantity_ = 0;
}
inline ::int32_t InventoryItem::quantity() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.InventoryItem.quantity)
  return _internal_quantity();
}
inline void InventoryItem::set_quantity(::int32_t value) {
  _internal_set_quantity(value);
  // @@protoc_insertion_point(field_set:rtech.liveapi.InventoryItem.quantity)
}
inline ::int32_t InventoryItem::_internal_quantity() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.quantity_;
}
inline void InventoryItem::_internal_set_quantity(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.quantity_ = value;
}

// string item = 2;
inline void InventoryItem::clear_item() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.item_.ClearToEmpty();
}
inline const std::string& InventoryItem::item() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rtech.liveapi.InventoryItem.item)
  return _internal_item();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void InventoryItem::set_item(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.item_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:rtech.liveapi.InventoryItem.item)
}
inline std::string* InventoryItem::mutable_item() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_item();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.InventoryItem.item)
  return _s;
}
inline const std::string& InventoryItem::_internal_item() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.item_.Get();
}
inline void InventoryItem::_internal_set_item(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.item_.Set(value, GetArena());
}
inline std::string* InventoryItem::_internal_mutable_item() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.item_.Mutable( GetArena());
}
inline std::string* InventoryItem::release_item() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:rtech.liveapi.InventoryItem.item)
  return _impl_.item_.Release();
}
inline void InventoryItem::set_allocated_item(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.item_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.item_.IsDefault()) {
          _impl_.item_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.InventoryItem.item)
}

// string extraData = 3;
inline void InventoryItem::clear_extradata() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.extradata_.ClearToEmpty();
}
inline const std::string& InventoryItem::extradata() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rtech.liveapi.InventoryItem.extraData)
  return _internal_extradata();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void InventoryItem::set_extradata(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.extradata_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:rtech.liveapi.InventoryItem.extraData)
}
inline std::string* InventoryItem::mutable_extradata() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_extradata();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.InventoryItem.extraData)
  return _s;
}
inline const std::string& InventoryItem::_internal_extradata() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.extradata_.Get();
}
inline void InventoryItem::_internal_set_extradata(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.extradata_.Set(value, GetArena());
}
inline std::string* InventoryItem::_internal_mutable_extradata() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.extradata_.Mutable( GetArena());
}
inline std::string* InventoryItem::release_extradata() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:rtech.liveapi.InventoryItem.extraData)
  return _impl_.extradata_.Release();
}
inline void InventoryItem::set_allocated_extradata(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.extradata_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.extradata_.IsDefault()) {
          _impl_.extradata_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.InventoryItem.extraData)
}

// -------------------------------------------------------------------

// LoadoutConfiguration

// repeated .rtech.liveapi.InventoryItem weapons = 1;
inline int LoadoutConfiguration::_internal_weapons_size() const {
  return _internal_weapons().size();
}
inline int LoadoutConfiguration::weapons_size() const {
  return _internal_weapons_size();
}
inline void LoadoutConfiguration::clear_weapons() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.weapons_.Clear();
}
inline ::rtech::liveapi::InventoryItem* LoadoutConfiguration::mutable_weapons(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.LoadoutConfiguration.weapons)
  return _internal_mutable_weapons()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::rtech::liveapi::InventoryItem>* LoadoutConfiguration::mutable_weapons()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:rtech.liveapi.LoadoutConfiguration.weapons)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_weapons();
}
inline const ::rtech::liveapi::InventoryItem& LoadoutConfiguration::weapons(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rtech.liveapi.LoadoutConfiguration.weapons)
  return _internal_weapons().Get(index);
}
inline ::rtech::liveapi::InventoryItem* LoadoutConfiguration::add_weapons() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::rtech::liveapi::InventoryItem* _add = _internal_mutable_weapons()->Add();
  // @@protoc_insertion_point(field_add:rtech.liveapi.LoadoutConfiguration.weapons)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::rtech::liveapi::InventoryItem>& LoadoutConfiguration::weapons() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:rtech.liveapi.LoadoutConfiguration.weapons)
  return _internal_weapons();
}
inline const ::google::protobuf::RepeatedPtrField<::rtech::liveapi::InventoryItem>&
LoadoutConfiguration::_internal_weapons() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.weapons_;
}
inline ::google::protobuf::RepeatedPtrField<::rtech::liveapi::InventoryItem>*
LoadoutConfiguration::_internal_mutable_weapons() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.weapons_;
}

// repeated .rtech.liveapi.InventoryItem equipment = 2;
inline int LoadoutConfiguration::_internal_equipment_size() const {
  return _internal_equipment().size();
}
inline int LoadoutConfiguration::equipment_size() const {
  return _internal_equipment_size();
}
inline void LoadoutConfiguration::clear_equipment() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.equipment_.Clear();
}
inline ::rtech::liveapi::InventoryItem* LoadoutConfiguration::mutable_equipment(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.LoadoutConfiguration.equipment)
  return _internal_mutable_equipment()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::rtech::liveapi::InventoryItem>* LoadoutConfiguration::mutable_equipment()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:rtech.liveapi.LoadoutConfiguration.equipment)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_equipment();
}
inline const ::rtech::liveapi::InventoryItem& LoadoutConfiguration::equipment(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rtech.liveapi.LoadoutConfiguration.equipment)
  return _internal_equipment().Get(index);
}
inline ::rtech::liveapi::InventoryItem* LoadoutConfiguration::add_equipment() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::rtech::liveapi::InventoryItem* _add = _internal_mutable_equipment()->Add();
  // @@protoc_insertion_point(field_add:rtech.liveapi.LoadoutConfiguration.equipment)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::rtech::liveapi::InventoryItem>& LoadoutConfiguration::equipment() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:rtech.liveapi.LoadoutConfiguration.equipment)
  return _internal_equipment();
}
inline const ::google::protobuf::RepeatedPtrField<::rtech::liveapi::InventoryItem>&
LoadoutConfiguration::_internal_equipment() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.equipment_;
}
inline ::google::protobuf::RepeatedPtrField<::rtech::liveapi::InventoryItem>*
LoadoutConfiguration::_internal_mutable_equipment() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.equipment_;
}

// -------------------------------------------------------------------

// Init

// uint64 timestamp = 1;
inline void Init::clear_timestamp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.timestamp_ = ::uint64_t{0u};
}
inline ::uint64_t Init::timestamp() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.Init.timestamp)
  return _internal_timestamp();
}
inline void Init::set_timestamp(::uint64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:rtech.liveapi.Init.timestamp)
}
inline ::uint64_t Init::_internal_timestamp() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.timestamp_;
}
inline void Init::_internal_set_timestamp(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.timestamp_ = value;
}

// string category = 2;
inline void Init::clear_category() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.category_.ClearToEmpty();
}
inline const std::string& Init::category() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rtech.liveapi.Init.category)
  return _internal_category();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Init::set_category(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.category_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:rtech.liveapi.Init.category)
}
inline std::string* Init::mutable_category() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_category();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.Init.category)
  return _s;
}
inline const std::string& Init::_internal_category() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.category_.Get();
}
inline void Init::_internal_set_category(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.category_.Set(value, GetArena());
}
inline std::string* Init::_internal_mutable_category() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.category_.Mutable( GetArena());
}
inline std::string* Init::release_category() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:rtech.liveapi.Init.category)
  return _impl_.category_.Release();
}
inline void Init::set_allocated_category(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.category_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.category_.IsDefault()) {
          _impl_.category_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.Init.category)
}

// string gameVersion = 3;
inline void Init::clear_gameversion() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.gameversion_.ClearToEmpty();
}
inline const std::string& Init::gameversion() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rtech.liveapi.Init.gameVersion)
  return _internal_gameversion();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Init::set_gameversion(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.gameversion_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:rtech.liveapi.Init.gameVersion)
}
inline std::string* Init::mutable_gameversion() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_gameversion();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.Init.gameVersion)
  return _s;
}
inline const std::string& Init::_internal_gameversion() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.gameversion_.Get();
}
inline void Init::_internal_set_gameversion(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.gameversion_.Set(value, GetArena());
}
inline std::string* Init::_internal_mutable_gameversion() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.gameversion_.Mutable( GetArena());
}
inline std::string* Init::release_gameversion() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:rtech.liveapi.Init.gameVersion)
  return _impl_.gameversion_.Release();
}
inline void Init::set_allocated_gameversion(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.gameversion_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.gameversion_.IsDefault()) {
          _impl_.gameversion_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.Init.gameVersion)
}

// .rtech.liveapi.Version apiVersion = 4;
inline bool Init::has_apiversion() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.apiversion_ != nullptr);
  return value;
}
inline void Init::clear_apiversion() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.apiversion_ != nullptr) _impl_.apiversion_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::rtech::liveapi::Version& Init::_internal_apiversion() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::rtech::liveapi::Version* p = _impl_.apiversion_;
  return p != nullptr ? *p : reinterpret_cast<const ::rtech::liveapi::Version&>(::rtech::liveapi::_Version_default_instance_);
}
inline const ::rtech::liveapi::Version& Init::apiversion() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rtech.liveapi.Init.apiVersion)
  return _internal_apiversion();
}
inline void Init::unsafe_arena_set_allocated_apiversion(::rtech::liveapi::Version* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.apiversion_);
  }
  _impl_.apiversion_ = reinterpret_cast<::rtech::liveapi::Version*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rtech.liveapi.Init.apiVersion)
}
inline ::rtech::liveapi::Version* Init::release_apiversion() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::rtech::liveapi::Version* released = _impl_.apiversion_;
  _impl_.apiversion_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::rtech::liveapi::Version* Init::unsafe_arena_release_apiversion() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:rtech.liveapi.Init.apiVersion)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::rtech::liveapi::Version* temp = _impl_.apiversion_;
  _impl_.apiversion_ = nullptr;
  return temp;
}
inline ::rtech::liveapi::Version* Init::_internal_mutable_apiversion() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.apiversion_ == nullptr) {
    auto* p = CreateMaybeMessage<::rtech::liveapi::Version>(GetArena());
    _impl_.apiversion_ = reinterpret_cast<::rtech::liveapi::Version*>(p);
  }
  return _impl_.apiversion_;
}
inline ::rtech::liveapi::Version* Init::mutable_apiversion() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::rtech::liveapi::Version* _msg = _internal_mutable_apiversion();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.Init.apiVersion)
  return _msg;
}
inline void Init::set_allocated_apiversion(::rtech::liveapi::Version* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::rtech::liveapi::Version*>(_impl_.apiversion_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::rtech::liveapi::Version*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.apiversion_ = reinterpret_cast<::rtech::liveapi::Version*>(value);
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.Init.apiVersion)
}

// string platform = 5;
inline void Init::clear_platform() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.platform_.ClearToEmpty();
}
inline const std::string& Init::platform() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rtech.liveapi.Init.platform)
  return _internal_platform();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Init::set_platform(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.platform_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:rtech.liveapi.Init.platform)
}
inline std::string* Init::mutable_platform() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_platform();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.Init.platform)
  return _s;
}
inline const std::string& Init::_internal_platform() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.platform_.Get();
}
inline void Init::_internal_set_platform(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.platform_.Set(value, GetArena());
}
inline std::string* Init::_internal_mutable_platform() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.platform_.Mutable( GetArena());
}
inline std::string* Init::release_platform() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:rtech.liveapi.Init.platform)
  return _impl_.platform_.Release();
}
inline void Init::set_allocated_platform(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.platform_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.platform_.IsDefault()) {
          _impl_.platform_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.Init.platform)
}

// string name = 6;
inline void Init::clear_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Init::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rtech.liveapi.Init.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Init::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:rtech.liveapi.Init.name)
}
inline std::string* Init::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.Init.name)
  return _s;
}
inline const std::string& Init::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void Init::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(value, GetArena());
}
inline std::string* Init::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* Init::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:rtech.liveapi.Init.name)
  return _impl_.name_.Release();
}
inline void Init::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.Init.name)
}

// -------------------------------------------------------------------

// CustomMatch_LobbyPlayers

// string playerToken = 1;
inline void CustomMatch_LobbyPlayers::clear_playertoken() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.playertoken_.ClearToEmpty();
}
inline const std::string& CustomMatch_LobbyPlayers::playertoken() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rtech.liveapi.CustomMatch_LobbyPlayers.playerToken)
  return _internal_playertoken();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CustomMatch_LobbyPlayers::set_playertoken(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.playertoken_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:rtech.liveapi.CustomMatch_LobbyPlayers.playerToken)
}
inline std::string* CustomMatch_LobbyPlayers::mutable_playertoken() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_playertoken();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.CustomMatch_LobbyPlayers.playerToken)
  return _s;
}
inline const std::string& CustomMatch_LobbyPlayers::_internal_playertoken() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.playertoken_.Get();
}
inline void CustomMatch_LobbyPlayers::_internal_set_playertoken(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.playertoken_.Set(value, GetArena());
}
inline std::string* CustomMatch_LobbyPlayers::_internal_mutable_playertoken() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.playertoken_.Mutable( GetArena());
}
inline std::string* CustomMatch_LobbyPlayers::release_playertoken() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:rtech.liveapi.CustomMatch_LobbyPlayers.playerToken)
  return _impl_.playertoken_.Release();
}
inline void CustomMatch_LobbyPlayers::set_allocated_playertoken(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.playertoken_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.playertoken_.IsDefault()) {
          _impl_.playertoken_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.CustomMatch_LobbyPlayers.playerToken)
}

// repeated .rtech.liveapi.CustomMatch_LobbyPlayer players = 2;
inline int CustomMatch_LobbyPlayers::_internal_players_size() const {
  return _internal_players().size();
}
inline int CustomMatch_LobbyPlayers::players_size() const {
  return _internal_players_size();
}
inline void CustomMatch_LobbyPlayers::clear_players() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.players_.Clear();
}
inline ::rtech::liveapi::CustomMatch_LobbyPlayer* CustomMatch_LobbyPlayers::mutable_players(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.CustomMatch_LobbyPlayers.players)
  return _internal_mutable_players()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::rtech::liveapi::CustomMatch_LobbyPlayer>* CustomMatch_LobbyPlayers::mutable_players()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:rtech.liveapi.CustomMatch_LobbyPlayers.players)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_players();
}
inline const ::rtech::liveapi::CustomMatch_LobbyPlayer& CustomMatch_LobbyPlayers::players(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rtech.liveapi.CustomMatch_LobbyPlayers.players)
  return _internal_players().Get(index);
}
inline ::rtech::liveapi::CustomMatch_LobbyPlayer* CustomMatch_LobbyPlayers::add_players() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::rtech::liveapi::CustomMatch_LobbyPlayer* _add = _internal_mutable_players()->Add();
  // @@protoc_insertion_point(field_add:rtech.liveapi.CustomMatch_LobbyPlayers.players)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::rtech::liveapi::CustomMatch_LobbyPlayer>& CustomMatch_LobbyPlayers::players() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:rtech.liveapi.CustomMatch_LobbyPlayers.players)
  return _internal_players();
}
inline const ::google::protobuf::RepeatedPtrField<::rtech::liveapi::CustomMatch_LobbyPlayer>&
CustomMatch_LobbyPlayers::_internal_players() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.players_;
}
inline ::google::protobuf::RepeatedPtrField<::rtech::liveapi::CustomMatch_LobbyPlayer>*
CustomMatch_LobbyPlayers::_internal_mutable_players() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.players_;
}

// -------------------------------------------------------------------

// ObserverSwitched

// uint64 timestamp = 1;
inline void ObserverSwitched::clear_timestamp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.timestamp_ = ::uint64_t{0u};
}
inline ::uint64_t ObserverSwitched::timestamp() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.ObserverSwitched.timestamp)
  return _internal_timestamp();
}
inline void ObserverSwitched::set_timestamp(::uint64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:rtech.liveapi.ObserverSwitched.timestamp)
}
inline ::uint64_t ObserverSwitched::_internal_timestamp() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.timestamp_;
}
inline void ObserverSwitched::_internal_set_timestamp(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.timestamp_ = value;
}

// string category = 2;
inline void ObserverSwitched::clear_category() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.category_.ClearToEmpty();
}
inline const std::string& ObserverSwitched::category() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rtech.liveapi.ObserverSwitched.category)
  return _internal_category();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ObserverSwitched::set_category(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.category_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:rtech.liveapi.ObserverSwitched.category)
}
inline std::string* ObserverSwitched::mutable_category() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_category();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.ObserverSwitched.category)
  return _s;
}
inline const std::string& ObserverSwitched::_internal_category() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.category_.Get();
}
inline void ObserverSwitched::_internal_set_category(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.category_.Set(value, GetArena());
}
inline std::string* ObserverSwitched::_internal_mutable_category() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.category_.Mutable( GetArena());
}
inline std::string* ObserverSwitched::release_category() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:rtech.liveapi.ObserverSwitched.category)
  return _impl_.category_.Release();
}
inline void ObserverSwitched::set_allocated_category(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.category_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.category_.IsDefault()) {
          _impl_.category_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.ObserverSwitched.category)
}

// .rtech.liveapi.Player observer = 3;
inline bool ObserverSwitched::has_observer() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.observer_ != nullptr);
  return value;
}
inline void ObserverSwitched::clear_observer() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.observer_ != nullptr) _impl_.observer_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::rtech::liveapi::Player& ObserverSwitched::_internal_observer() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::rtech::liveapi::Player* p = _impl_.observer_;
  return p != nullptr ? *p : reinterpret_cast<const ::rtech::liveapi::Player&>(::rtech::liveapi::_Player_default_instance_);
}
inline const ::rtech::liveapi::Player& ObserverSwitched::observer() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rtech.liveapi.ObserverSwitched.observer)
  return _internal_observer();
}
inline void ObserverSwitched::unsafe_arena_set_allocated_observer(::rtech::liveapi::Player* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.observer_);
  }
  _impl_.observer_ = reinterpret_cast<::rtech::liveapi::Player*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rtech.liveapi.ObserverSwitched.observer)
}
inline ::rtech::liveapi::Player* ObserverSwitched::release_observer() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::rtech::liveapi::Player* released = _impl_.observer_;
  _impl_.observer_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::rtech::liveapi::Player* ObserverSwitched::unsafe_arena_release_observer() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:rtech.liveapi.ObserverSwitched.observer)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::rtech::liveapi::Player* temp = _impl_.observer_;
  _impl_.observer_ = nullptr;
  return temp;
}
inline ::rtech::liveapi::Player* ObserverSwitched::_internal_mutable_observer() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.observer_ == nullptr) {
    auto* p = CreateMaybeMessage<::rtech::liveapi::Player>(GetArena());
    _impl_.observer_ = reinterpret_cast<::rtech::liveapi::Player*>(p);
  }
  return _impl_.observer_;
}
inline ::rtech::liveapi::Player* ObserverSwitched::mutable_observer() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::rtech::liveapi::Player* _msg = _internal_mutable_observer();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.ObserverSwitched.observer)
  return _msg;
}
inline void ObserverSwitched::set_allocated_observer(::rtech::liveapi::Player* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::rtech::liveapi::Player*>(_impl_.observer_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::rtech::liveapi::Player*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.observer_ = reinterpret_cast<::rtech::liveapi::Player*>(value);
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.ObserverSwitched.observer)
}

// .rtech.liveapi.Player target = 4;
inline bool ObserverSwitched::has_target() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.target_ != nullptr);
  return value;
}
inline void ObserverSwitched::clear_target() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.target_ != nullptr) _impl_.target_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::rtech::liveapi::Player& ObserverSwitched::_internal_target() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::rtech::liveapi::Player* p = _impl_.target_;
  return p != nullptr ? *p : reinterpret_cast<const ::rtech::liveapi::Player&>(::rtech::liveapi::_Player_default_instance_);
}
inline const ::rtech::liveapi::Player& ObserverSwitched::target() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rtech.liveapi.ObserverSwitched.target)
  return _internal_target();
}
inline void ObserverSwitched::unsafe_arena_set_allocated_target(::rtech::liveapi::Player* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.target_);
  }
  _impl_.target_ = reinterpret_cast<::rtech::liveapi::Player*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rtech.liveapi.ObserverSwitched.target)
}
inline ::rtech::liveapi::Player* ObserverSwitched::release_target() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::rtech::liveapi::Player* released = _impl_.target_;
  _impl_.target_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::rtech::liveapi::Player* ObserverSwitched::unsafe_arena_release_target() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:rtech.liveapi.ObserverSwitched.target)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::rtech::liveapi::Player* temp = _impl_.target_;
  _impl_.target_ = nullptr;
  return temp;
}
inline ::rtech::liveapi::Player* ObserverSwitched::_internal_mutable_target() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.target_ == nullptr) {
    auto* p = CreateMaybeMessage<::rtech::liveapi::Player>(GetArena());
    _impl_.target_ = reinterpret_cast<::rtech::liveapi::Player*>(p);
  }
  return _impl_.target_;
}
inline ::rtech::liveapi::Player* ObserverSwitched::mutable_target() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::rtech::liveapi::Player* _msg = _internal_mutable_target();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.ObserverSwitched.target)
  return _msg;
}
inline void ObserverSwitched::set_allocated_target(::rtech::liveapi::Player* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::rtech::liveapi::Player*>(_impl_.target_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::rtech::liveapi::Player*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.target_ = reinterpret_cast<::rtech::liveapi::Player*>(value);
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.ObserverSwitched.target)
}

// repeated .rtech.liveapi.Player targetTeam = 5;
inline int ObserverSwitched::_internal_targetteam_size() const {
  return _internal_targetteam().size();
}
inline int ObserverSwitched::targetteam_size() const {
  return _internal_targetteam_size();
}
inline void ObserverSwitched::clear_targetteam() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.targetteam_.Clear();
}
inline ::rtech::liveapi::Player* ObserverSwitched::mutable_targetteam(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.ObserverSwitched.targetTeam)
  return _internal_mutable_targetteam()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::rtech::liveapi::Player>* ObserverSwitched::mutable_targetteam()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:rtech.liveapi.ObserverSwitched.targetTeam)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_targetteam();
}
inline const ::rtech::liveapi::Player& ObserverSwitched::targetteam(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rtech.liveapi.ObserverSwitched.targetTeam)
  return _internal_targetteam().Get(index);
}
inline ::rtech::liveapi::Player* ObserverSwitched::add_targetteam() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::rtech::liveapi::Player* _add = _internal_mutable_targetteam()->Add();
  // @@protoc_insertion_point(field_add:rtech.liveapi.ObserverSwitched.targetTeam)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::rtech::liveapi::Player>& ObserverSwitched::targetteam() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:rtech.liveapi.ObserverSwitched.targetTeam)
  return _internal_targetteam();
}
inline const ::google::protobuf::RepeatedPtrField<::rtech::liveapi::Player>&
ObserverSwitched::_internal_targetteam() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.targetteam_;
}
inline ::google::protobuf::RepeatedPtrField<::rtech::liveapi::Player>*
ObserverSwitched::_internal_mutable_targetteam() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.targetteam_;
}

// -------------------------------------------------------------------

// ObserverAnnotation

// uint64 timestamp = 1;
inline void ObserverAnnotation::clear_timestamp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.timestamp_ = ::uint64_t{0u};
}
inline ::uint64_t ObserverAnnotation::timestamp() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.ObserverAnnotation.timestamp)
  return _internal_timestamp();
}
inline void ObserverAnnotation::set_timestamp(::uint64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:rtech.liveapi.ObserverAnnotation.timestamp)
}
inline ::uint64_t ObserverAnnotation::_internal_timestamp() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.timestamp_;
}
inline void ObserverAnnotation::_internal_set_timestamp(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.timestamp_ = value;
}

// string category = 2;
inline void ObserverAnnotation::clear_category() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.category_.ClearToEmpty();
}
inline const std::string& ObserverAnnotation::category() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rtech.liveapi.ObserverAnnotation.category)
  return _internal_category();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ObserverAnnotation::set_category(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.category_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:rtech.liveapi.ObserverAnnotation.category)
}
inline std::string* ObserverAnnotation::mutable_category() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_category();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.ObserverAnnotation.category)
  return _s;
}
inline const std::string& ObserverAnnotation::_internal_category() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.category_.Get();
}
inline void ObserverAnnotation::_internal_set_category(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.category_.Set(value, GetArena());
}
inline std::string* ObserverAnnotation::_internal_mutable_category() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.category_.Mutable( GetArena());
}
inline std::string* ObserverAnnotation::release_category() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:rtech.liveapi.ObserverAnnotation.category)
  return _impl_.category_.Release();
}
inline void ObserverAnnotation::set_allocated_category(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.category_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.category_.IsDefault()) {
          _impl_.category_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.ObserverAnnotation.category)
}

// int32 annotationSerial = 3;
inline void ObserverAnnotation::clear_annotationserial() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.annotationserial_ = 0;
}
inline ::int32_t ObserverAnnotation::annotationserial() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.ObserverAnnotation.annotationSerial)
  return _internal_annotationserial();
}
inline void ObserverAnnotation::set_annotationserial(::int32_t value) {
  _internal_set_annotationserial(value);
  // @@protoc_insertion_point(field_set:rtech.liveapi.ObserverAnnotation.annotationSerial)
}
inline ::int32_t ObserverAnnotation::_internal_annotationserial() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.annotationserial_;
}
inline void ObserverAnnotation::_internal_set_annotationserial(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.annotationserial_ = value;
}

// -------------------------------------------------------------------

// MatchSetup

// uint64 timestamp = 1;
inline void MatchSetup::clear_timestamp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.timestamp_ = ::uint64_t{0u};
}
inline ::uint64_t MatchSetup::timestamp() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.MatchSetup.timestamp)
  return _internal_timestamp();
}
inline void MatchSetup::set_timestamp(::uint64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:rtech.liveapi.MatchSetup.timestamp)
}
inline ::uint64_t MatchSetup::_internal_timestamp() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.timestamp_;
}
inline void MatchSetup::_internal_set_timestamp(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.timestamp_ = value;
}

// string category = 2;
inline void MatchSetup::clear_category() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.category_.ClearToEmpty();
}
inline const std::string& MatchSetup::category() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rtech.liveapi.MatchSetup.category)
  return _internal_category();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MatchSetup::set_category(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.category_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:rtech.liveapi.MatchSetup.category)
}
inline std::string* MatchSetup::mutable_category() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_category();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.MatchSetup.category)
  return _s;
}
inline const std::string& MatchSetup::_internal_category() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.category_.Get();
}
inline void MatchSetup::_internal_set_category(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.category_.Set(value, GetArena());
}
inline std::string* MatchSetup::_internal_mutable_category() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.category_.Mutable( GetArena());
}
inline std::string* MatchSetup::release_category() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:rtech.liveapi.MatchSetup.category)
  return _impl_.category_.Release();
}
inline void MatchSetup::set_allocated_category(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.category_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.category_.IsDefault()) {
          _impl_.category_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.MatchSetup.category)
}

// string map = 3;
inline void MatchSetup::clear_map() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.map_.ClearToEmpty();
}
inline const std::string& MatchSetup::map() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rtech.liveapi.MatchSetup.map)
  return _internal_map();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MatchSetup::set_map(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.map_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:rtech.liveapi.MatchSetup.map)
}
inline std::string* MatchSetup::mutable_map() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_map();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.MatchSetup.map)
  return _s;
}
inline const std::string& MatchSetup::_internal_map() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.map_.Get();
}
inline void MatchSetup::_internal_set_map(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.map_.Set(value, GetArena());
}
inline std::string* MatchSetup::_internal_mutable_map() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.map_.Mutable( GetArena());
}
inline std::string* MatchSetup::release_map() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:rtech.liveapi.MatchSetup.map)
  return _impl_.map_.Release();
}
inline void MatchSetup::set_allocated_map(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.map_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.map_.IsDefault()) {
          _impl_.map_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.MatchSetup.map)
}

// string playlistName = 4;
inline void MatchSetup::clear_playlistname() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.playlistname_.ClearToEmpty();
}
inline const std::string& MatchSetup::playlistname() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rtech.liveapi.MatchSetup.playlistName)
  return _internal_playlistname();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MatchSetup::set_playlistname(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.playlistname_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:rtech.liveapi.MatchSetup.playlistName)
}
inline std::string* MatchSetup::mutable_playlistname() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_playlistname();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.MatchSetup.playlistName)
  return _s;
}
inline const std::string& MatchSetup::_internal_playlistname() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.playlistname_.Get();
}
inline void MatchSetup::_internal_set_playlistname(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.playlistname_.Set(value, GetArena());
}
inline std::string* MatchSetup::_internal_mutable_playlistname() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.playlistname_.Mutable( GetArena());
}
inline std::string* MatchSetup::release_playlistname() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:rtech.liveapi.MatchSetup.playlistName)
  return _impl_.playlistname_.Release();
}
inline void MatchSetup::set_allocated_playlistname(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.playlistname_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.playlistname_.IsDefault()) {
          _impl_.playlistname_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.MatchSetup.playlistName)
}

// string playlistDesc = 5;
inline void MatchSetup::clear_playlistdesc() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.playlistdesc_.ClearToEmpty();
}
inline const std::string& MatchSetup::playlistdesc() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rtech.liveapi.MatchSetup.playlistDesc)
  return _internal_playlistdesc();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MatchSetup::set_playlistdesc(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.playlistdesc_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:rtech.liveapi.MatchSetup.playlistDesc)
}
inline std::string* MatchSetup::mutable_playlistdesc() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_playlistdesc();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.MatchSetup.playlistDesc)
  return _s;
}
inline const std::string& MatchSetup::_internal_playlistdesc() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.playlistdesc_.Get();
}
inline void MatchSetup::_internal_set_playlistdesc(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.playlistdesc_.Set(value, GetArena());
}
inline std::string* MatchSetup::_internal_mutable_playlistdesc() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.playlistdesc_.Mutable( GetArena());
}
inline std::string* MatchSetup::release_playlistdesc() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:rtech.liveapi.MatchSetup.playlistDesc)
  return _impl_.playlistdesc_.Release();
}
inline void MatchSetup::set_allocated_playlistdesc(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.playlistdesc_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.playlistdesc_.IsDefault()) {
          _impl_.playlistdesc_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.MatchSetup.playlistDesc)
}

// .rtech.liveapi.Datacenter datacenter = 6;
inline bool MatchSetup::has_datacenter() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.datacenter_ != nullptr);
  return value;
}
inline void MatchSetup::clear_datacenter() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.datacenter_ != nullptr) _impl_.datacenter_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::rtech::liveapi::Datacenter& MatchSetup::_internal_datacenter() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::rtech::liveapi::Datacenter* p = _impl_.datacenter_;
  return p != nullptr ? *p : reinterpret_cast<const ::rtech::liveapi::Datacenter&>(::rtech::liveapi::_Datacenter_default_instance_);
}
inline const ::rtech::liveapi::Datacenter& MatchSetup::datacenter() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rtech.liveapi.MatchSetup.datacenter)
  return _internal_datacenter();
}
inline void MatchSetup::unsafe_arena_set_allocated_datacenter(::rtech::liveapi::Datacenter* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.datacenter_);
  }
  _impl_.datacenter_ = reinterpret_cast<::rtech::liveapi::Datacenter*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rtech.liveapi.MatchSetup.datacenter)
}
inline ::rtech::liveapi::Datacenter* MatchSetup::release_datacenter() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::rtech::liveapi::Datacenter* released = _impl_.datacenter_;
  _impl_.datacenter_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::rtech::liveapi::Datacenter* MatchSetup::unsafe_arena_release_datacenter() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:rtech.liveapi.MatchSetup.datacenter)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::rtech::liveapi::Datacenter* temp = _impl_.datacenter_;
  _impl_.datacenter_ = nullptr;
  return temp;
}
inline ::rtech::liveapi::Datacenter* MatchSetup::_internal_mutable_datacenter() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.datacenter_ == nullptr) {
    auto* p = CreateMaybeMessage<::rtech::liveapi::Datacenter>(GetArena());
    _impl_.datacenter_ = reinterpret_cast<::rtech::liveapi::Datacenter*>(p);
  }
  return _impl_.datacenter_;
}
inline ::rtech::liveapi::Datacenter* MatchSetup::mutable_datacenter() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::rtech::liveapi::Datacenter* _msg = _internal_mutable_datacenter();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.MatchSetup.datacenter)
  return _msg;
}
inline void MatchSetup::set_allocated_datacenter(::rtech::liveapi::Datacenter* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::rtech::liveapi::Datacenter*>(_impl_.datacenter_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::rtech::liveapi::Datacenter*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.datacenter_ = reinterpret_cast<::rtech::liveapi::Datacenter*>(value);
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.MatchSetup.datacenter)
}

// bool aimAssistOn = 7;
inline void MatchSetup::clear_aimassiston() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.aimassiston_ = false;
}
inline bool MatchSetup::aimassiston() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.MatchSetup.aimAssistOn)
  return _internal_aimassiston();
}
inline void MatchSetup::set_aimassiston(bool value) {
  _internal_set_aimassiston(value);
  // @@protoc_insertion_point(field_set:rtech.liveapi.MatchSetup.aimAssistOn)
}
inline bool MatchSetup::_internal_aimassiston() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.aimassiston_;
}
inline void MatchSetup::_internal_set_aimassiston(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.aimassiston_ = value;
}

// bool anonymousMode = 8;
inline void MatchSetup::clear_anonymousmode() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.anonymousmode_ = false;
}
inline bool MatchSetup::anonymousmode() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.MatchSetup.anonymousMode)
  return _internal_anonymousmode();
}
inline void MatchSetup::set_anonymousmode(bool value) {
  _internal_set_anonymousmode(value);
  // @@protoc_insertion_point(field_set:rtech.liveapi.MatchSetup.anonymousMode)
}
inline bool MatchSetup::_internal_anonymousmode() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.anonymousmode_;
}
inline void MatchSetup::_internal_set_anonymousmode(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.anonymousmode_ = value;
}

// string serverId = 9;
inline void MatchSetup::clear_serverid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.serverid_.ClearToEmpty();
}
inline const std::string& MatchSetup::serverid() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rtech.liveapi.MatchSetup.serverId)
  return _internal_serverid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MatchSetup::set_serverid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.serverid_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:rtech.liveapi.MatchSetup.serverId)
}
inline std::string* MatchSetup::mutable_serverid() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_serverid();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.MatchSetup.serverId)
  return _s;
}
inline const std::string& MatchSetup::_internal_serverid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.serverid_.Get();
}
inline void MatchSetup::_internal_set_serverid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.serverid_.Set(value, GetArena());
}
inline std::string* MatchSetup::_internal_mutable_serverid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.serverid_.Mutable( GetArena());
}
inline std::string* MatchSetup::release_serverid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:rtech.liveapi.MatchSetup.serverId)
  return _impl_.serverid_.Release();
}
inline void MatchSetup::set_allocated_serverid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.serverid_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.serverid_.IsDefault()) {
          _impl_.serverid_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.MatchSetup.serverId)
}

// .rtech.liveapi.LoadoutConfiguration startingLoadout = 10;
inline bool MatchSetup::has_startingloadout() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.startingloadout_ != nullptr);
  return value;
}
inline void MatchSetup::clear_startingloadout() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.startingloadout_ != nullptr) _impl_.startingloadout_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::rtech::liveapi::LoadoutConfiguration& MatchSetup::_internal_startingloadout() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::rtech::liveapi::LoadoutConfiguration* p = _impl_.startingloadout_;
  return p != nullptr ? *p : reinterpret_cast<const ::rtech::liveapi::LoadoutConfiguration&>(::rtech::liveapi::_LoadoutConfiguration_default_instance_);
}
inline const ::rtech::liveapi::LoadoutConfiguration& MatchSetup::startingloadout() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rtech.liveapi.MatchSetup.startingLoadout)
  return _internal_startingloadout();
}
inline void MatchSetup::unsafe_arena_set_allocated_startingloadout(::rtech::liveapi::LoadoutConfiguration* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.startingloadout_);
  }
  _impl_.startingloadout_ = reinterpret_cast<::rtech::liveapi::LoadoutConfiguration*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rtech.liveapi.MatchSetup.startingLoadout)
}
inline ::rtech::liveapi::LoadoutConfiguration* MatchSetup::release_startingloadout() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::rtech::liveapi::LoadoutConfiguration* released = _impl_.startingloadout_;
  _impl_.startingloadout_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::rtech::liveapi::LoadoutConfiguration* MatchSetup::unsafe_arena_release_startingloadout() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:rtech.liveapi.MatchSetup.startingLoadout)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::rtech::liveapi::LoadoutConfiguration* temp = _impl_.startingloadout_;
  _impl_.startingloadout_ = nullptr;
  return temp;
}
inline ::rtech::liveapi::LoadoutConfiguration* MatchSetup::_internal_mutable_startingloadout() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.startingloadout_ == nullptr) {
    auto* p = CreateMaybeMessage<::rtech::liveapi::LoadoutConfiguration>(GetArena());
    _impl_.startingloadout_ = reinterpret_cast<::rtech::liveapi::LoadoutConfiguration*>(p);
  }
  return _impl_.startingloadout_;
}
inline ::rtech::liveapi::LoadoutConfiguration* MatchSetup::mutable_startingloadout() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::rtech::liveapi::LoadoutConfiguration* _msg = _internal_mutable_startingloadout();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.MatchSetup.startingLoadout)
  return _msg;
}
inline void MatchSetup::set_allocated_startingloadout(::rtech::liveapi::LoadoutConfiguration* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::rtech::liveapi::LoadoutConfiguration*>(_impl_.startingloadout_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::rtech::liveapi::LoadoutConfiguration*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.startingloadout_ = reinterpret_cast<::rtech::liveapi::LoadoutConfiguration*>(value);
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.MatchSetup.startingLoadout)
}

// -------------------------------------------------------------------

// GameStateChanged

// uint64 timestamp = 1;
inline void GameStateChanged::clear_timestamp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.timestamp_ = ::uint64_t{0u};
}
inline ::uint64_t GameStateChanged::timestamp() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.GameStateChanged.timestamp)
  return _internal_timestamp();
}
inline void GameStateChanged::set_timestamp(::uint64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:rtech.liveapi.GameStateChanged.timestamp)
}
inline ::uint64_t GameStateChanged::_internal_timestamp() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.timestamp_;
}
inline void GameStateChanged::_internal_set_timestamp(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.timestamp_ = value;
}

// string category = 2;
inline void GameStateChanged::clear_category() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.category_.ClearToEmpty();
}
inline const std::string& GameStateChanged::category() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rtech.liveapi.GameStateChanged.category)
  return _internal_category();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GameStateChanged::set_category(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.category_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:rtech.liveapi.GameStateChanged.category)
}
inline std::string* GameStateChanged::mutable_category() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_category();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.GameStateChanged.category)
  return _s;
}
inline const std::string& GameStateChanged::_internal_category() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.category_.Get();
}
inline void GameStateChanged::_internal_set_category(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.category_.Set(value, GetArena());
}
inline std::string* GameStateChanged::_internal_mutable_category() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.category_.Mutable( GetArena());
}
inline std::string* GameStateChanged::release_category() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:rtech.liveapi.GameStateChanged.category)
  return _impl_.category_.Release();
}
inline void GameStateChanged::set_allocated_category(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.category_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.category_.IsDefault()) {
          _impl_.category_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.GameStateChanged.category)
}

// string state = 3;
inline void GameStateChanged::clear_state() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.state_.ClearToEmpty();
}
inline const std::string& GameStateChanged::state() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rtech.liveapi.GameStateChanged.state)
  return _internal_state();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GameStateChanged::set_state(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.state_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:rtech.liveapi.GameStateChanged.state)
}
inline std::string* GameStateChanged::mutable_state() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_state();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.GameStateChanged.state)
  return _s;
}
inline const std::string& GameStateChanged::_internal_state() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.state_.Get();
}
inline void GameStateChanged::_internal_set_state(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.state_.Set(value, GetArena());
}
inline std::string* GameStateChanged::_internal_mutable_state() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.state_.Mutable( GetArena());
}
inline std::string* GameStateChanged::release_state() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:rtech.liveapi.GameStateChanged.state)
  return _impl_.state_.Release();
}
inline void GameStateChanged::set_allocated_state(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.state_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.state_.IsDefault()) {
          _impl_.state_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.GameStateChanged.state)
}

// -------------------------------------------------------------------

// CharacterSelected

// uint64 timestamp = 1;
inline void CharacterSelected::clear_timestamp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.timestamp_ = ::uint64_t{0u};
}
inline ::uint64_t CharacterSelected::timestamp() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.CharacterSelected.timestamp)
  return _internal_timestamp();
}
inline void CharacterSelected::set_timestamp(::uint64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:rtech.liveapi.CharacterSelected.timestamp)
}
inline ::uint64_t CharacterSelected::_internal_timestamp() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.timestamp_;
}
inline void CharacterSelected::_internal_set_timestamp(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.timestamp_ = value;
}

// string category = 2;
inline void CharacterSelected::clear_category() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.category_.ClearToEmpty();
}
inline const std::string& CharacterSelected::category() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rtech.liveapi.CharacterSelected.category)
  return _internal_category();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CharacterSelected::set_category(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.category_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:rtech.liveapi.CharacterSelected.category)
}
inline std::string* CharacterSelected::mutable_category() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_category();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.CharacterSelected.category)
  return _s;
}
inline const std::string& CharacterSelected::_internal_category() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.category_.Get();
}
inline void CharacterSelected::_internal_set_category(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.category_.Set(value, GetArena());
}
inline std::string* CharacterSelected::_internal_mutable_category() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.category_.Mutable( GetArena());
}
inline std::string* CharacterSelected::release_category() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:rtech.liveapi.CharacterSelected.category)
  return _impl_.category_.Release();
}
inline void CharacterSelected::set_allocated_category(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.category_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.category_.IsDefault()) {
          _impl_.category_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.CharacterSelected.category)
}

// .rtech.liveapi.Player player = 3;
inline bool CharacterSelected::has_player() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.player_ != nullptr);
  return value;
}
inline void CharacterSelected::clear_player() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.player_ != nullptr) _impl_.player_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::rtech::liveapi::Player& CharacterSelected::_internal_player() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::rtech::liveapi::Player* p = _impl_.player_;
  return p != nullptr ? *p : reinterpret_cast<const ::rtech::liveapi::Player&>(::rtech::liveapi::_Player_default_instance_);
}
inline const ::rtech::liveapi::Player& CharacterSelected::player() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rtech.liveapi.CharacterSelected.player)
  return _internal_player();
}
inline void CharacterSelected::unsafe_arena_set_allocated_player(::rtech::liveapi::Player* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.player_);
  }
  _impl_.player_ = reinterpret_cast<::rtech::liveapi::Player*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rtech.liveapi.CharacterSelected.player)
}
inline ::rtech::liveapi::Player* CharacterSelected::release_player() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::rtech::liveapi::Player* released = _impl_.player_;
  _impl_.player_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::rtech::liveapi::Player* CharacterSelected::unsafe_arena_release_player() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:rtech.liveapi.CharacterSelected.player)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::rtech::liveapi::Player* temp = _impl_.player_;
  _impl_.player_ = nullptr;
  return temp;
}
inline ::rtech::liveapi::Player* CharacterSelected::_internal_mutable_player() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.player_ == nullptr) {
    auto* p = CreateMaybeMessage<::rtech::liveapi::Player>(GetArena());
    _impl_.player_ = reinterpret_cast<::rtech::liveapi::Player*>(p);
  }
  return _impl_.player_;
}
inline ::rtech::liveapi::Player* CharacterSelected::mutable_player() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::rtech::liveapi::Player* _msg = _internal_mutable_player();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.CharacterSelected.player)
  return _msg;
}
inline void CharacterSelected::set_allocated_player(::rtech::liveapi::Player* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::rtech::liveapi::Player*>(_impl_.player_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::rtech::liveapi::Player*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.player_ = reinterpret_cast<::rtech::liveapi::Player*>(value);
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.CharacterSelected.player)
}

// -------------------------------------------------------------------

// MatchStateEnd

// uint64 timestamp = 1;
inline void MatchStateEnd::clear_timestamp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.timestamp_ = ::uint64_t{0u};
}
inline ::uint64_t MatchStateEnd::timestamp() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.MatchStateEnd.timestamp)
  return _internal_timestamp();
}
inline void MatchStateEnd::set_timestamp(::uint64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:rtech.liveapi.MatchStateEnd.timestamp)
}
inline ::uint64_t MatchStateEnd::_internal_timestamp() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.timestamp_;
}
inline void MatchStateEnd::_internal_set_timestamp(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.timestamp_ = value;
}

// string category = 2;
inline void MatchStateEnd::clear_category() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.category_.ClearToEmpty();
}
inline const std::string& MatchStateEnd::category() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rtech.liveapi.MatchStateEnd.category)
  return _internal_category();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MatchStateEnd::set_category(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.category_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:rtech.liveapi.MatchStateEnd.category)
}
inline std::string* MatchStateEnd::mutable_category() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_category();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.MatchStateEnd.category)
  return _s;
}
inline const std::string& MatchStateEnd::_internal_category() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.category_.Get();
}
inline void MatchStateEnd::_internal_set_category(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.category_.Set(value, GetArena());
}
inline std::string* MatchStateEnd::_internal_mutable_category() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.category_.Mutable( GetArena());
}
inline std::string* MatchStateEnd::release_category() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:rtech.liveapi.MatchStateEnd.category)
  return _impl_.category_.Release();
}
inline void MatchStateEnd::set_allocated_category(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.category_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.category_.IsDefault()) {
          _impl_.category_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.MatchStateEnd.category)
}

// string state = 3;
inline void MatchStateEnd::clear_state() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.state_.ClearToEmpty();
}
inline const std::string& MatchStateEnd::state() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rtech.liveapi.MatchStateEnd.state)
  return _internal_state();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MatchStateEnd::set_state(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.state_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:rtech.liveapi.MatchStateEnd.state)
}
inline std::string* MatchStateEnd::mutable_state() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_state();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.MatchStateEnd.state)
  return _s;
}
inline const std::string& MatchStateEnd::_internal_state() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.state_.Get();
}
inline void MatchStateEnd::_internal_set_state(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.state_.Set(value, GetArena());
}
inline std::string* MatchStateEnd::_internal_mutable_state() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.state_.Mutable( GetArena());
}
inline std::string* MatchStateEnd::release_state() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:rtech.liveapi.MatchStateEnd.state)
  return _impl_.state_.Release();
}
inline void MatchStateEnd::set_allocated_state(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.state_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.state_.IsDefault()) {
          _impl_.state_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.MatchStateEnd.state)
}

// repeated .rtech.liveapi.Player winners = 4;
inline int MatchStateEnd::_internal_winners_size() const {
  return _internal_winners().size();
}
inline int MatchStateEnd::winners_size() const {
  return _internal_winners_size();
}
inline void MatchStateEnd::clear_winners() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.winners_.Clear();
}
inline ::rtech::liveapi::Player* MatchStateEnd::mutable_winners(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.MatchStateEnd.winners)
  return _internal_mutable_winners()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::rtech::liveapi::Player>* MatchStateEnd::mutable_winners()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:rtech.liveapi.MatchStateEnd.winners)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_winners();
}
inline const ::rtech::liveapi::Player& MatchStateEnd::winners(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rtech.liveapi.MatchStateEnd.winners)
  return _internal_winners().Get(index);
}
inline ::rtech::liveapi::Player* MatchStateEnd::add_winners() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::rtech::liveapi::Player* _add = _internal_mutable_winners()->Add();
  // @@protoc_insertion_point(field_add:rtech.liveapi.MatchStateEnd.winners)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::rtech::liveapi::Player>& MatchStateEnd::winners() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:rtech.liveapi.MatchStateEnd.winners)
  return _internal_winners();
}
inline const ::google::protobuf::RepeatedPtrField<::rtech::liveapi::Player>&
MatchStateEnd::_internal_winners() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.winners_;
}
inline ::google::protobuf::RepeatedPtrField<::rtech::liveapi::Player>*
MatchStateEnd::_internal_mutable_winners() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.winners_;
}

// -------------------------------------------------------------------

// RingStartClosing

// uint64 timestamp = 1;
inline void RingStartClosing::clear_timestamp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.timestamp_ = ::uint64_t{0u};
}
inline ::uint64_t RingStartClosing::timestamp() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.RingStartClosing.timestamp)
  return _internal_timestamp();
}
inline void RingStartClosing::set_timestamp(::uint64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:rtech.liveapi.RingStartClosing.timestamp)
}
inline ::uint64_t RingStartClosing::_internal_timestamp() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.timestamp_;
}
inline void RingStartClosing::_internal_set_timestamp(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.timestamp_ = value;
}

// string category = 2;
inline void RingStartClosing::clear_category() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.category_.ClearToEmpty();
}
inline const std::string& RingStartClosing::category() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rtech.liveapi.RingStartClosing.category)
  return _internal_category();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RingStartClosing::set_category(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.category_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:rtech.liveapi.RingStartClosing.category)
}
inline std::string* RingStartClosing::mutable_category() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_category();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.RingStartClosing.category)
  return _s;
}
inline const std::string& RingStartClosing::_internal_category() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.category_.Get();
}
inline void RingStartClosing::_internal_set_category(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.category_.Set(value, GetArena());
}
inline std::string* RingStartClosing::_internal_mutable_category() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.category_.Mutable( GetArena());
}
inline std::string* RingStartClosing::release_category() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:rtech.liveapi.RingStartClosing.category)
  return _impl_.category_.Release();
}
inline void RingStartClosing::set_allocated_category(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.category_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.category_.IsDefault()) {
          _impl_.category_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.RingStartClosing.category)
}

// uint32 stage = 3;
inline void RingStartClosing::clear_stage() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.stage_ = 0u;
}
inline ::uint32_t RingStartClosing::stage() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.RingStartClosing.stage)
  return _internal_stage();
}
inline void RingStartClosing::set_stage(::uint32_t value) {
  _internal_set_stage(value);
  // @@protoc_insertion_point(field_set:rtech.liveapi.RingStartClosing.stage)
}
inline ::uint32_t RingStartClosing::_internal_stage() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.stage_;
}
inline void RingStartClosing::_internal_set_stage(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.stage_ = value;
}

// .rtech.liveapi.Vector3 center = 4;
inline bool RingStartClosing::has_center() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.center_ != nullptr);
  return value;
}
inline void RingStartClosing::clear_center() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.center_ != nullptr) _impl_.center_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::rtech::liveapi::Vector3& RingStartClosing::_internal_center() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::rtech::liveapi::Vector3* p = _impl_.center_;
  return p != nullptr ? *p : reinterpret_cast<const ::rtech::liveapi::Vector3&>(::rtech::liveapi::_Vector3_default_instance_);
}
inline const ::rtech::liveapi::Vector3& RingStartClosing::center() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rtech.liveapi.RingStartClosing.center)
  return _internal_center();
}
inline void RingStartClosing::unsafe_arena_set_allocated_center(::rtech::liveapi::Vector3* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.center_);
  }
  _impl_.center_ = reinterpret_cast<::rtech::liveapi::Vector3*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rtech.liveapi.RingStartClosing.center)
}
inline ::rtech::liveapi::Vector3* RingStartClosing::release_center() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::rtech::liveapi::Vector3* released = _impl_.center_;
  _impl_.center_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::rtech::liveapi::Vector3* RingStartClosing::unsafe_arena_release_center() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:rtech.liveapi.RingStartClosing.center)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::rtech::liveapi::Vector3* temp = _impl_.center_;
  _impl_.center_ = nullptr;
  return temp;
}
inline ::rtech::liveapi::Vector3* RingStartClosing::_internal_mutable_center() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.center_ == nullptr) {
    auto* p = CreateMaybeMessage<::rtech::liveapi::Vector3>(GetArena());
    _impl_.center_ = reinterpret_cast<::rtech::liveapi::Vector3*>(p);
  }
  return _impl_.center_;
}
inline ::rtech::liveapi::Vector3* RingStartClosing::mutable_center() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::rtech::liveapi::Vector3* _msg = _internal_mutable_center();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.RingStartClosing.center)
  return _msg;
}
inline void RingStartClosing::set_allocated_center(::rtech::liveapi::Vector3* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::rtech::liveapi::Vector3*>(_impl_.center_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::rtech::liveapi::Vector3*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.center_ = reinterpret_cast<::rtech::liveapi::Vector3*>(value);
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.RingStartClosing.center)
}

// float currentRadius = 5;
inline void RingStartClosing::clear_currentradius() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.currentradius_ = 0;
}
inline float RingStartClosing::currentradius() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.RingStartClosing.currentRadius)
  return _internal_currentradius();
}
inline void RingStartClosing::set_currentradius(float value) {
  _internal_set_currentradius(value);
  // @@protoc_insertion_point(field_set:rtech.liveapi.RingStartClosing.currentRadius)
}
inline float RingStartClosing::_internal_currentradius() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.currentradius_;
}
inline void RingStartClosing::_internal_set_currentradius(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.currentradius_ = value;
}

// float endRadius = 6;
inline void RingStartClosing::clear_endradius() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.endradius_ = 0;
}
inline float RingStartClosing::endradius() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.RingStartClosing.endRadius)
  return _internal_endradius();
}
inline void RingStartClosing::set_endradius(float value) {
  _internal_set_endradius(value);
  // @@protoc_insertion_point(field_set:rtech.liveapi.RingStartClosing.endRadius)
}
inline float RingStartClosing::_internal_endradius() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.endradius_;
}
inline void RingStartClosing::_internal_set_endradius(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.endradius_ = value;
}

// float shrinkDuration = 7;
inline void RingStartClosing::clear_shrinkduration() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.shrinkduration_ = 0;
}
inline float RingStartClosing::shrinkduration() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.RingStartClosing.shrinkDuration)
  return _internal_shrinkduration();
}
inline void RingStartClosing::set_shrinkduration(float value) {
  _internal_set_shrinkduration(value);
  // @@protoc_insertion_point(field_set:rtech.liveapi.RingStartClosing.shrinkDuration)
}
inline float RingStartClosing::_internal_shrinkduration() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.shrinkduration_;
}
inline void RingStartClosing::_internal_set_shrinkduration(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.shrinkduration_ = value;
}

// -------------------------------------------------------------------

// RingFinishedClosing

// uint64 timestamp = 1;
inline void RingFinishedClosing::clear_timestamp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.timestamp_ = ::uint64_t{0u};
}
inline ::uint64_t RingFinishedClosing::timestamp() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.RingFinishedClosing.timestamp)
  return _internal_timestamp();
}
inline void RingFinishedClosing::set_timestamp(::uint64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:rtech.liveapi.RingFinishedClosing.timestamp)
}
inline ::uint64_t RingFinishedClosing::_internal_timestamp() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.timestamp_;
}
inline void RingFinishedClosing::_internal_set_timestamp(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.timestamp_ = value;
}

// string category = 2;
inline void RingFinishedClosing::clear_category() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.category_.ClearToEmpty();
}
inline const std::string& RingFinishedClosing::category() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rtech.liveapi.RingFinishedClosing.category)
  return _internal_category();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RingFinishedClosing::set_category(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.category_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:rtech.liveapi.RingFinishedClosing.category)
}
inline std::string* RingFinishedClosing::mutable_category() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_category();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.RingFinishedClosing.category)
  return _s;
}
inline const std::string& RingFinishedClosing::_internal_category() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.category_.Get();
}
inline void RingFinishedClosing::_internal_set_category(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.category_.Set(value, GetArena());
}
inline std::string* RingFinishedClosing::_internal_mutable_category() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.category_.Mutable( GetArena());
}
inline std::string* RingFinishedClosing::release_category() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:rtech.liveapi.RingFinishedClosing.category)
  return _impl_.category_.Release();
}
inline void RingFinishedClosing::set_allocated_category(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.category_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.category_.IsDefault()) {
          _impl_.category_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.RingFinishedClosing.category)
}

// uint32 stage = 3;
inline void RingFinishedClosing::clear_stage() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.stage_ = 0u;
}
inline ::uint32_t RingFinishedClosing::stage() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.RingFinishedClosing.stage)
  return _internal_stage();
}
inline void RingFinishedClosing::set_stage(::uint32_t value) {
  _internal_set_stage(value);
  // @@protoc_insertion_point(field_set:rtech.liveapi.RingFinishedClosing.stage)
}
inline ::uint32_t RingFinishedClosing::_internal_stage() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.stage_;
}
inline void RingFinishedClosing::_internal_set_stage(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.stage_ = value;
}

// .rtech.liveapi.Vector3 center = 4;
inline bool RingFinishedClosing::has_center() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.center_ != nullptr);
  return value;
}
inline void RingFinishedClosing::clear_center() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.center_ != nullptr) _impl_.center_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::rtech::liveapi::Vector3& RingFinishedClosing::_internal_center() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::rtech::liveapi::Vector3* p = _impl_.center_;
  return p != nullptr ? *p : reinterpret_cast<const ::rtech::liveapi::Vector3&>(::rtech::liveapi::_Vector3_default_instance_);
}
inline const ::rtech::liveapi::Vector3& RingFinishedClosing::center() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rtech.liveapi.RingFinishedClosing.center)
  return _internal_center();
}
inline void RingFinishedClosing::unsafe_arena_set_allocated_center(::rtech::liveapi::Vector3* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.center_);
  }
  _impl_.center_ = reinterpret_cast<::rtech::liveapi::Vector3*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rtech.liveapi.RingFinishedClosing.center)
}
inline ::rtech::liveapi::Vector3* RingFinishedClosing::release_center() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::rtech::liveapi::Vector3* released = _impl_.center_;
  _impl_.center_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::rtech::liveapi::Vector3* RingFinishedClosing::unsafe_arena_release_center() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:rtech.liveapi.RingFinishedClosing.center)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::rtech::liveapi::Vector3* temp = _impl_.center_;
  _impl_.center_ = nullptr;
  return temp;
}
inline ::rtech::liveapi::Vector3* RingFinishedClosing::_internal_mutable_center() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.center_ == nullptr) {
    auto* p = CreateMaybeMessage<::rtech::liveapi::Vector3>(GetArena());
    _impl_.center_ = reinterpret_cast<::rtech::liveapi::Vector3*>(p);
  }
  return _impl_.center_;
}
inline ::rtech::liveapi::Vector3* RingFinishedClosing::mutable_center() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::rtech::liveapi::Vector3* _msg = _internal_mutable_center();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.RingFinishedClosing.center)
  return _msg;
}
inline void RingFinishedClosing::set_allocated_center(::rtech::liveapi::Vector3* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::rtech::liveapi::Vector3*>(_impl_.center_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::rtech::liveapi::Vector3*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.center_ = reinterpret_cast<::rtech::liveapi::Vector3*>(value);
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.RingFinishedClosing.center)
}

// float currentRadius = 5;
inline void RingFinishedClosing::clear_currentradius() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.currentradius_ = 0;
}
inline float RingFinishedClosing::currentradius() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.RingFinishedClosing.currentRadius)
  return _internal_currentradius();
}
inline void RingFinishedClosing::set_currentradius(float value) {
  _internal_set_currentradius(value);
  // @@protoc_insertion_point(field_set:rtech.liveapi.RingFinishedClosing.currentRadius)
}
inline float RingFinishedClosing::_internal_currentradius() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.currentradius_;
}
inline void RingFinishedClosing::_internal_set_currentradius(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.currentradius_ = value;
}

// float shrinkDuration = 7;
inline void RingFinishedClosing::clear_shrinkduration() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.shrinkduration_ = 0;
}
inline float RingFinishedClosing::shrinkduration() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.RingFinishedClosing.shrinkDuration)
  return _internal_shrinkduration();
}
inline void RingFinishedClosing::set_shrinkduration(float value) {
  _internal_set_shrinkduration(value);
  // @@protoc_insertion_point(field_set:rtech.liveapi.RingFinishedClosing.shrinkDuration)
}
inline float RingFinishedClosing::_internal_shrinkduration() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.shrinkduration_;
}
inline void RingFinishedClosing::_internal_set_shrinkduration(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.shrinkduration_ = value;
}

// -------------------------------------------------------------------

// PlayerConnected

// uint64 timestamp = 1;
inline void PlayerConnected::clear_timestamp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.timestamp_ = ::uint64_t{0u};
}
inline ::uint64_t PlayerConnected::timestamp() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.PlayerConnected.timestamp)
  return _internal_timestamp();
}
inline void PlayerConnected::set_timestamp(::uint64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:rtech.liveapi.PlayerConnected.timestamp)
}
inline ::uint64_t PlayerConnected::_internal_timestamp() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.timestamp_;
}
inline void PlayerConnected::_internal_set_timestamp(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.timestamp_ = value;
}

// string category = 2;
inline void PlayerConnected::clear_category() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.category_.ClearToEmpty();
}
inline const std::string& PlayerConnected::category() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rtech.liveapi.PlayerConnected.category)
  return _internal_category();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PlayerConnected::set_category(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.category_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:rtech.liveapi.PlayerConnected.category)
}
inline std::string* PlayerConnected::mutable_category() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_category();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.PlayerConnected.category)
  return _s;
}
inline const std::string& PlayerConnected::_internal_category() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.category_.Get();
}
inline void PlayerConnected::_internal_set_category(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.category_.Set(value, GetArena());
}
inline std::string* PlayerConnected::_internal_mutable_category() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.category_.Mutable( GetArena());
}
inline std::string* PlayerConnected::release_category() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:rtech.liveapi.PlayerConnected.category)
  return _impl_.category_.Release();
}
inline void PlayerConnected::set_allocated_category(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.category_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.category_.IsDefault()) {
          _impl_.category_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.PlayerConnected.category)
}

// .rtech.liveapi.Player player = 3;
inline bool PlayerConnected::has_player() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.player_ != nullptr);
  return value;
}
inline void PlayerConnected::clear_player() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.player_ != nullptr) _impl_.player_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::rtech::liveapi::Player& PlayerConnected::_internal_player() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::rtech::liveapi::Player* p = _impl_.player_;
  return p != nullptr ? *p : reinterpret_cast<const ::rtech::liveapi::Player&>(::rtech::liveapi::_Player_default_instance_);
}
inline const ::rtech::liveapi::Player& PlayerConnected::player() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rtech.liveapi.PlayerConnected.player)
  return _internal_player();
}
inline void PlayerConnected::unsafe_arena_set_allocated_player(::rtech::liveapi::Player* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.player_);
  }
  _impl_.player_ = reinterpret_cast<::rtech::liveapi::Player*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rtech.liveapi.PlayerConnected.player)
}
inline ::rtech::liveapi::Player* PlayerConnected::release_player() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::rtech::liveapi::Player* released = _impl_.player_;
  _impl_.player_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::rtech::liveapi::Player* PlayerConnected::unsafe_arena_release_player() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:rtech.liveapi.PlayerConnected.player)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::rtech::liveapi::Player* temp = _impl_.player_;
  _impl_.player_ = nullptr;
  return temp;
}
inline ::rtech::liveapi::Player* PlayerConnected::_internal_mutable_player() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.player_ == nullptr) {
    auto* p = CreateMaybeMessage<::rtech::liveapi::Player>(GetArena());
    _impl_.player_ = reinterpret_cast<::rtech::liveapi::Player*>(p);
  }
  return _impl_.player_;
}
inline ::rtech::liveapi::Player* PlayerConnected::mutable_player() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::rtech::liveapi::Player* _msg = _internal_mutable_player();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.PlayerConnected.player)
  return _msg;
}
inline void PlayerConnected::set_allocated_player(::rtech::liveapi::Player* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::rtech::liveapi::Player*>(_impl_.player_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::rtech::liveapi::Player*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.player_ = reinterpret_cast<::rtech::liveapi::Player*>(value);
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.PlayerConnected.player)
}

// -------------------------------------------------------------------

// PlayerDisconnected

// uint64 timestamp = 1;
inline void PlayerDisconnected::clear_timestamp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.timestamp_ = ::uint64_t{0u};
}
inline ::uint64_t PlayerDisconnected::timestamp() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.PlayerDisconnected.timestamp)
  return _internal_timestamp();
}
inline void PlayerDisconnected::set_timestamp(::uint64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:rtech.liveapi.PlayerDisconnected.timestamp)
}
inline ::uint64_t PlayerDisconnected::_internal_timestamp() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.timestamp_;
}
inline void PlayerDisconnected::_internal_set_timestamp(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.timestamp_ = value;
}

// string category = 2;
inline void PlayerDisconnected::clear_category() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.category_.ClearToEmpty();
}
inline const std::string& PlayerDisconnected::category() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rtech.liveapi.PlayerDisconnected.category)
  return _internal_category();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PlayerDisconnected::set_category(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.category_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:rtech.liveapi.PlayerDisconnected.category)
}
inline std::string* PlayerDisconnected::mutable_category() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_category();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.PlayerDisconnected.category)
  return _s;
}
inline const std::string& PlayerDisconnected::_internal_category() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.category_.Get();
}
inline void PlayerDisconnected::_internal_set_category(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.category_.Set(value, GetArena());
}
inline std::string* PlayerDisconnected::_internal_mutable_category() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.category_.Mutable( GetArena());
}
inline std::string* PlayerDisconnected::release_category() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:rtech.liveapi.PlayerDisconnected.category)
  return _impl_.category_.Release();
}
inline void PlayerDisconnected::set_allocated_category(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.category_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.category_.IsDefault()) {
          _impl_.category_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.PlayerDisconnected.category)
}

// .rtech.liveapi.Player player = 3;
inline bool PlayerDisconnected::has_player() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.player_ != nullptr);
  return value;
}
inline void PlayerDisconnected::clear_player() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.player_ != nullptr) _impl_.player_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::rtech::liveapi::Player& PlayerDisconnected::_internal_player() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::rtech::liveapi::Player* p = _impl_.player_;
  return p != nullptr ? *p : reinterpret_cast<const ::rtech::liveapi::Player&>(::rtech::liveapi::_Player_default_instance_);
}
inline const ::rtech::liveapi::Player& PlayerDisconnected::player() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rtech.liveapi.PlayerDisconnected.player)
  return _internal_player();
}
inline void PlayerDisconnected::unsafe_arena_set_allocated_player(::rtech::liveapi::Player* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.player_);
  }
  _impl_.player_ = reinterpret_cast<::rtech::liveapi::Player*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rtech.liveapi.PlayerDisconnected.player)
}
inline ::rtech::liveapi::Player* PlayerDisconnected::release_player() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::rtech::liveapi::Player* released = _impl_.player_;
  _impl_.player_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::rtech::liveapi::Player* PlayerDisconnected::unsafe_arena_release_player() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:rtech.liveapi.PlayerDisconnected.player)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::rtech::liveapi::Player* temp = _impl_.player_;
  _impl_.player_ = nullptr;
  return temp;
}
inline ::rtech::liveapi::Player* PlayerDisconnected::_internal_mutable_player() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.player_ == nullptr) {
    auto* p = CreateMaybeMessage<::rtech::liveapi::Player>(GetArena());
    _impl_.player_ = reinterpret_cast<::rtech::liveapi::Player*>(p);
  }
  return _impl_.player_;
}
inline ::rtech::liveapi::Player* PlayerDisconnected::mutable_player() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::rtech::liveapi::Player* _msg = _internal_mutable_player();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.PlayerDisconnected.player)
  return _msg;
}
inline void PlayerDisconnected::set_allocated_player(::rtech::liveapi::Player* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::rtech::liveapi::Player*>(_impl_.player_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::rtech::liveapi::Player*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.player_ = reinterpret_cast<::rtech::liveapi::Player*>(value);
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.PlayerDisconnected.player)
}

// bool canReconnect = 4;
inline void PlayerDisconnected::clear_canreconnect() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.canreconnect_ = false;
}
inline bool PlayerDisconnected::canreconnect() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.PlayerDisconnected.canReconnect)
  return _internal_canreconnect();
}
inline void PlayerDisconnected::set_canreconnect(bool value) {
  _internal_set_canreconnect(value);
  // @@protoc_insertion_point(field_set:rtech.liveapi.PlayerDisconnected.canReconnect)
}
inline bool PlayerDisconnected::_internal_canreconnect() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.canreconnect_;
}
inline void PlayerDisconnected::_internal_set_canreconnect(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.canreconnect_ = value;
}

// bool isAlive = 5;
inline void PlayerDisconnected::clear_isalive() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.isalive_ = false;
}
inline bool PlayerDisconnected::isalive() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.PlayerDisconnected.isAlive)
  return _internal_isalive();
}
inline void PlayerDisconnected::set_isalive(bool value) {
  _internal_set_isalive(value);
  // @@protoc_insertion_point(field_set:rtech.liveapi.PlayerDisconnected.isAlive)
}
inline bool PlayerDisconnected::_internal_isalive() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.isalive_;
}
inline void PlayerDisconnected::_internal_set_isalive(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.isalive_ = value;
}

// -------------------------------------------------------------------

// PlayerStatChanged

// uint64 timestamp = 1;
inline void PlayerStatChanged::clear_timestamp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.timestamp_ = ::uint64_t{0u};
}
inline ::uint64_t PlayerStatChanged::timestamp() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.PlayerStatChanged.timestamp)
  return _internal_timestamp();
}
inline void PlayerStatChanged::set_timestamp(::uint64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:rtech.liveapi.PlayerStatChanged.timestamp)
}
inline ::uint64_t PlayerStatChanged::_internal_timestamp() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.timestamp_;
}
inline void PlayerStatChanged::_internal_set_timestamp(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.timestamp_ = value;
}

// string category = 2;
inline void PlayerStatChanged::clear_category() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.category_.ClearToEmpty();
}
inline const std::string& PlayerStatChanged::category() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rtech.liveapi.PlayerStatChanged.category)
  return _internal_category();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PlayerStatChanged::set_category(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.category_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:rtech.liveapi.PlayerStatChanged.category)
}
inline std::string* PlayerStatChanged::mutable_category() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_category();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.PlayerStatChanged.category)
  return _s;
}
inline const std::string& PlayerStatChanged::_internal_category() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.category_.Get();
}
inline void PlayerStatChanged::_internal_set_category(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.category_.Set(value, GetArena());
}
inline std::string* PlayerStatChanged::_internal_mutable_category() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.category_.Mutable( GetArena());
}
inline std::string* PlayerStatChanged::release_category() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:rtech.liveapi.PlayerStatChanged.category)
  return _impl_.category_.Release();
}
inline void PlayerStatChanged::set_allocated_category(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.category_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.category_.IsDefault()) {
          _impl_.category_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.PlayerStatChanged.category)
}

// .rtech.liveapi.Player player = 3;
inline bool PlayerStatChanged::has_player() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.player_ != nullptr);
  return value;
}
inline void PlayerStatChanged::clear_player() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.player_ != nullptr) _impl_.player_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::rtech::liveapi::Player& PlayerStatChanged::_internal_player() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::rtech::liveapi::Player* p = _impl_.player_;
  return p != nullptr ? *p : reinterpret_cast<const ::rtech::liveapi::Player&>(::rtech::liveapi::_Player_default_instance_);
}
inline const ::rtech::liveapi::Player& PlayerStatChanged::player() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rtech.liveapi.PlayerStatChanged.player)
  return _internal_player();
}
inline void PlayerStatChanged::unsafe_arena_set_allocated_player(::rtech::liveapi::Player* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.player_);
  }
  _impl_.player_ = reinterpret_cast<::rtech::liveapi::Player*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rtech.liveapi.PlayerStatChanged.player)
}
inline ::rtech::liveapi::Player* PlayerStatChanged::release_player() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::rtech::liveapi::Player* released = _impl_.player_;
  _impl_.player_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::rtech::liveapi::Player* PlayerStatChanged::unsafe_arena_release_player() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:rtech.liveapi.PlayerStatChanged.player)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::rtech::liveapi::Player* temp = _impl_.player_;
  _impl_.player_ = nullptr;
  return temp;
}
inline ::rtech::liveapi::Player* PlayerStatChanged::_internal_mutable_player() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.player_ == nullptr) {
    auto* p = CreateMaybeMessage<::rtech::liveapi::Player>(GetArena());
    _impl_.player_ = reinterpret_cast<::rtech::liveapi::Player*>(p);
  }
  return _impl_.player_;
}
inline ::rtech::liveapi::Player* PlayerStatChanged::mutable_player() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::rtech::liveapi::Player* _msg = _internal_mutable_player();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.PlayerStatChanged.player)
  return _msg;
}
inline void PlayerStatChanged::set_allocated_player(::rtech::liveapi::Player* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::rtech::liveapi::Player*>(_impl_.player_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::rtech::liveapi::Player*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.player_ = reinterpret_cast<::rtech::liveapi::Player*>(value);
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.PlayerStatChanged.player)
}

// string statName = 4;
inline void PlayerStatChanged::clear_statname() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.statname_.ClearToEmpty();
}
inline const std::string& PlayerStatChanged::statname() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rtech.liveapi.PlayerStatChanged.statName)
  return _internal_statname();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PlayerStatChanged::set_statname(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.statname_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:rtech.liveapi.PlayerStatChanged.statName)
}
inline std::string* PlayerStatChanged::mutable_statname() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_statname();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.PlayerStatChanged.statName)
  return _s;
}
inline const std::string& PlayerStatChanged::_internal_statname() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.statname_.Get();
}
inline void PlayerStatChanged::_internal_set_statname(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.statname_.Set(value, GetArena());
}
inline std::string* PlayerStatChanged::_internal_mutable_statname() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.statname_.Mutable( GetArena());
}
inline std::string* PlayerStatChanged::release_statname() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:rtech.liveapi.PlayerStatChanged.statName)
  return _impl_.statname_.Release();
}
inline void PlayerStatChanged::set_allocated_statname(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.statname_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.statname_.IsDefault()) {
          _impl_.statname_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.PlayerStatChanged.statName)
}

// uint32 newValue = 5;
inline void PlayerStatChanged::clear_newvalue() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.newvalue_ = 0u;
}
inline ::uint32_t PlayerStatChanged::newvalue() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.PlayerStatChanged.newValue)
  return _internal_newvalue();
}
inline void PlayerStatChanged::set_newvalue(::uint32_t value) {
  _internal_set_newvalue(value);
  // @@protoc_insertion_point(field_set:rtech.liveapi.PlayerStatChanged.newValue)
}
inline ::uint32_t PlayerStatChanged::_internal_newvalue() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.newvalue_;
}
inline void PlayerStatChanged::_internal_set_newvalue(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.newvalue_ = value;
}

// -------------------------------------------------------------------

// PlayerUpgradeTierChanged

// uint64 timestamp = 1;
inline void PlayerUpgradeTierChanged::clear_timestamp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.timestamp_ = ::uint64_t{0u};
}
inline ::uint64_t PlayerUpgradeTierChanged::timestamp() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.PlayerUpgradeTierChanged.timestamp)
  return _internal_timestamp();
}
inline void PlayerUpgradeTierChanged::set_timestamp(::uint64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:rtech.liveapi.PlayerUpgradeTierChanged.timestamp)
}
inline ::uint64_t PlayerUpgradeTierChanged::_internal_timestamp() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.timestamp_;
}
inline void PlayerUpgradeTierChanged::_internal_set_timestamp(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.timestamp_ = value;
}

// string category = 2;
inline void PlayerUpgradeTierChanged::clear_category() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.category_.ClearToEmpty();
}
inline const std::string& PlayerUpgradeTierChanged::category() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rtech.liveapi.PlayerUpgradeTierChanged.category)
  return _internal_category();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PlayerUpgradeTierChanged::set_category(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.category_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:rtech.liveapi.PlayerUpgradeTierChanged.category)
}
inline std::string* PlayerUpgradeTierChanged::mutable_category() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_category();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.PlayerUpgradeTierChanged.category)
  return _s;
}
inline const std::string& PlayerUpgradeTierChanged::_internal_category() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.category_.Get();
}
inline void PlayerUpgradeTierChanged::_internal_set_category(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.category_.Set(value, GetArena());
}
inline std::string* PlayerUpgradeTierChanged::_internal_mutable_category() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.category_.Mutable( GetArena());
}
inline std::string* PlayerUpgradeTierChanged::release_category() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:rtech.liveapi.PlayerUpgradeTierChanged.category)
  return _impl_.category_.Release();
}
inline void PlayerUpgradeTierChanged::set_allocated_category(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.category_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.category_.IsDefault()) {
          _impl_.category_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.PlayerUpgradeTierChanged.category)
}

// .rtech.liveapi.Player player = 3;
inline bool PlayerUpgradeTierChanged::has_player() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.player_ != nullptr);
  return value;
}
inline void PlayerUpgradeTierChanged::clear_player() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.player_ != nullptr) _impl_.player_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::rtech::liveapi::Player& PlayerUpgradeTierChanged::_internal_player() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::rtech::liveapi::Player* p = _impl_.player_;
  return p != nullptr ? *p : reinterpret_cast<const ::rtech::liveapi::Player&>(::rtech::liveapi::_Player_default_instance_);
}
inline const ::rtech::liveapi::Player& PlayerUpgradeTierChanged::player() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rtech.liveapi.PlayerUpgradeTierChanged.player)
  return _internal_player();
}
inline void PlayerUpgradeTierChanged::unsafe_arena_set_allocated_player(::rtech::liveapi::Player* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.player_);
  }
  _impl_.player_ = reinterpret_cast<::rtech::liveapi::Player*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rtech.liveapi.PlayerUpgradeTierChanged.player)
}
inline ::rtech::liveapi::Player* PlayerUpgradeTierChanged::release_player() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::rtech::liveapi::Player* released = _impl_.player_;
  _impl_.player_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::rtech::liveapi::Player* PlayerUpgradeTierChanged::unsafe_arena_release_player() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:rtech.liveapi.PlayerUpgradeTierChanged.player)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::rtech::liveapi::Player* temp = _impl_.player_;
  _impl_.player_ = nullptr;
  return temp;
}
inline ::rtech::liveapi::Player* PlayerUpgradeTierChanged::_internal_mutable_player() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.player_ == nullptr) {
    auto* p = CreateMaybeMessage<::rtech::liveapi::Player>(GetArena());
    _impl_.player_ = reinterpret_cast<::rtech::liveapi::Player*>(p);
  }
  return _impl_.player_;
}
inline ::rtech::liveapi::Player* PlayerUpgradeTierChanged::mutable_player() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::rtech::liveapi::Player* _msg = _internal_mutable_player();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.PlayerUpgradeTierChanged.player)
  return _msg;
}
inline void PlayerUpgradeTierChanged::set_allocated_player(::rtech::liveapi::Player* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::rtech::liveapi::Player*>(_impl_.player_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::rtech::liveapi::Player*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.player_ = reinterpret_cast<::rtech::liveapi::Player*>(value);
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.PlayerUpgradeTierChanged.player)
}

// int32 level = 4;
inline void PlayerUpgradeTierChanged::clear_level() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.level_ = 0;
}
inline ::int32_t PlayerUpgradeTierChanged::level() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.PlayerUpgradeTierChanged.level)
  return _internal_level();
}
inline void PlayerUpgradeTierChanged::set_level(::int32_t value) {
  _internal_set_level(value);
  // @@protoc_insertion_point(field_set:rtech.liveapi.PlayerUpgradeTierChanged.level)
}
inline ::int32_t PlayerUpgradeTierChanged::_internal_level() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.level_;
}
inline void PlayerUpgradeTierChanged::_internal_set_level(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.level_ = value;
}

// -------------------------------------------------------------------

// PlayerDamaged

// uint64 timestamp = 1;
inline void PlayerDamaged::clear_timestamp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.timestamp_ = ::uint64_t{0u};
}
inline ::uint64_t PlayerDamaged::timestamp() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.PlayerDamaged.timestamp)
  return _internal_timestamp();
}
inline void PlayerDamaged::set_timestamp(::uint64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:rtech.liveapi.PlayerDamaged.timestamp)
}
inline ::uint64_t PlayerDamaged::_internal_timestamp() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.timestamp_;
}
inline void PlayerDamaged::_internal_set_timestamp(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.timestamp_ = value;
}

// string category = 2;
inline void PlayerDamaged::clear_category() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.category_.ClearToEmpty();
}
inline const std::string& PlayerDamaged::category() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rtech.liveapi.PlayerDamaged.category)
  return _internal_category();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PlayerDamaged::set_category(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.category_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:rtech.liveapi.PlayerDamaged.category)
}
inline std::string* PlayerDamaged::mutable_category() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_category();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.PlayerDamaged.category)
  return _s;
}
inline const std::string& PlayerDamaged::_internal_category() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.category_.Get();
}
inline void PlayerDamaged::_internal_set_category(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.category_.Set(value, GetArena());
}
inline std::string* PlayerDamaged::_internal_mutable_category() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.category_.Mutable( GetArena());
}
inline std::string* PlayerDamaged::release_category() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:rtech.liveapi.PlayerDamaged.category)
  return _impl_.category_.Release();
}
inline void PlayerDamaged::set_allocated_category(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.category_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.category_.IsDefault()) {
          _impl_.category_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.PlayerDamaged.category)
}

// .rtech.liveapi.Player attacker = 3;
inline bool PlayerDamaged::has_attacker() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.attacker_ != nullptr);
  return value;
}
inline void PlayerDamaged::clear_attacker() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.attacker_ != nullptr) _impl_.attacker_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::rtech::liveapi::Player& PlayerDamaged::_internal_attacker() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::rtech::liveapi::Player* p = _impl_.attacker_;
  return p != nullptr ? *p : reinterpret_cast<const ::rtech::liveapi::Player&>(::rtech::liveapi::_Player_default_instance_);
}
inline const ::rtech::liveapi::Player& PlayerDamaged::attacker() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rtech.liveapi.PlayerDamaged.attacker)
  return _internal_attacker();
}
inline void PlayerDamaged::unsafe_arena_set_allocated_attacker(::rtech::liveapi::Player* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.attacker_);
  }
  _impl_.attacker_ = reinterpret_cast<::rtech::liveapi::Player*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rtech.liveapi.PlayerDamaged.attacker)
}
inline ::rtech::liveapi::Player* PlayerDamaged::release_attacker() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::rtech::liveapi::Player* released = _impl_.attacker_;
  _impl_.attacker_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::rtech::liveapi::Player* PlayerDamaged::unsafe_arena_release_attacker() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:rtech.liveapi.PlayerDamaged.attacker)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::rtech::liveapi::Player* temp = _impl_.attacker_;
  _impl_.attacker_ = nullptr;
  return temp;
}
inline ::rtech::liveapi::Player* PlayerDamaged::_internal_mutable_attacker() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.attacker_ == nullptr) {
    auto* p = CreateMaybeMessage<::rtech::liveapi::Player>(GetArena());
    _impl_.attacker_ = reinterpret_cast<::rtech::liveapi::Player*>(p);
  }
  return _impl_.attacker_;
}
inline ::rtech::liveapi::Player* PlayerDamaged::mutable_attacker() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::rtech::liveapi::Player* _msg = _internal_mutable_attacker();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.PlayerDamaged.attacker)
  return _msg;
}
inline void PlayerDamaged::set_allocated_attacker(::rtech::liveapi::Player* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::rtech::liveapi::Player*>(_impl_.attacker_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::rtech::liveapi::Player*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.attacker_ = reinterpret_cast<::rtech::liveapi::Player*>(value);
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.PlayerDamaged.attacker)
}

// .rtech.liveapi.Player victim = 4;
inline bool PlayerDamaged::has_victim() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.victim_ != nullptr);
  return value;
}
inline void PlayerDamaged::clear_victim() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.victim_ != nullptr) _impl_.victim_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::rtech::liveapi::Player& PlayerDamaged::_internal_victim() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::rtech::liveapi::Player* p = _impl_.victim_;
  return p != nullptr ? *p : reinterpret_cast<const ::rtech::liveapi::Player&>(::rtech::liveapi::_Player_default_instance_);
}
inline const ::rtech::liveapi::Player& PlayerDamaged::victim() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rtech.liveapi.PlayerDamaged.victim)
  return _internal_victim();
}
inline void PlayerDamaged::unsafe_arena_set_allocated_victim(::rtech::liveapi::Player* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.victim_);
  }
  _impl_.victim_ = reinterpret_cast<::rtech::liveapi::Player*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rtech.liveapi.PlayerDamaged.victim)
}
inline ::rtech::liveapi::Player* PlayerDamaged::release_victim() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::rtech::liveapi::Player* released = _impl_.victim_;
  _impl_.victim_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::rtech::liveapi::Player* PlayerDamaged::unsafe_arena_release_victim() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:rtech.liveapi.PlayerDamaged.victim)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::rtech::liveapi::Player* temp = _impl_.victim_;
  _impl_.victim_ = nullptr;
  return temp;
}
inline ::rtech::liveapi::Player* PlayerDamaged::_internal_mutable_victim() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.victim_ == nullptr) {
    auto* p = CreateMaybeMessage<::rtech::liveapi::Player>(GetArena());
    _impl_.victim_ = reinterpret_cast<::rtech::liveapi::Player*>(p);
  }
  return _impl_.victim_;
}
inline ::rtech::liveapi::Player* PlayerDamaged::mutable_victim() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::rtech::liveapi::Player* _msg = _internal_mutable_victim();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.PlayerDamaged.victim)
  return _msg;
}
inline void PlayerDamaged::set_allocated_victim(::rtech::liveapi::Player* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::rtech::liveapi::Player*>(_impl_.victim_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::rtech::liveapi::Player*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.victim_ = reinterpret_cast<::rtech::liveapi::Player*>(value);
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.PlayerDamaged.victim)
}

// string weapon = 5;
inline void PlayerDamaged::clear_weapon() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.weapon_.ClearToEmpty();
}
inline const std::string& PlayerDamaged::weapon() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rtech.liveapi.PlayerDamaged.weapon)
  return _internal_weapon();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PlayerDamaged::set_weapon(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.weapon_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:rtech.liveapi.PlayerDamaged.weapon)
}
inline std::string* PlayerDamaged::mutable_weapon() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_weapon();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.PlayerDamaged.weapon)
  return _s;
}
inline const std::string& PlayerDamaged::_internal_weapon() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.weapon_.Get();
}
inline void PlayerDamaged::_internal_set_weapon(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.weapon_.Set(value, GetArena());
}
inline std::string* PlayerDamaged::_internal_mutable_weapon() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.weapon_.Mutable( GetArena());
}
inline std::string* PlayerDamaged::release_weapon() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:rtech.liveapi.PlayerDamaged.weapon)
  return _impl_.weapon_.Release();
}
inline void PlayerDamaged::set_allocated_weapon(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.weapon_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.weapon_.IsDefault()) {
          _impl_.weapon_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.PlayerDamaged.weapon)
}

// uint32 damageInflicted = 6;
inline void PlayerDamaged::clear_damageinflicted() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.damageinflicted_ = 0u;
}
inline ::uint32_t PlayerDamaged::damageinflicted() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.PlayerDamaged.damageInflicted)
  return _internal_damageinflicted();
}
inline void PlayerDamaged::set_damageinflicted(::uint32_t value) {
  _internal_set_damageinflicted(value);
  // @@protoc_insertion_point(field_set:rtech.liveapi.PlayerDamaged.damageInflicted)
}
inline ::uint32_t PlayerDamaged::_internal_damageinflicted() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.damageinflicted_;
}
inline void PlayerDamaged::_internal_set_damageinflicted(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.damageinflicted_ = value;
}

// -------------------------------------------------------------------

// PlayerKilled

// uint64 timestamp = 1;
inline void PlayerKilled::clear_timestamp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.timestamp_ = ::uint64_t{0u};
}
inline ::uint64_t PlayerKilled::timestamp() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.PlayerKilled.timestamp)
  return _internal_timestamp();
}
inline void PlayerKilled::set_timestamp(::uint64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:rtech.liveapi.PlayerKilled.timestamp)
}
inline ::uint64_t PlayerKilled::_internal_timestamp() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.timestamp_;
}
inline void PlayerKilled::_internal_set_timestamp(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.timestamp_ = value;
}

// string category = 2;
inline void PlayerKilled::clear_category() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.category_.ClearToEmpty();
}
inline const std::string& PlayerKilled::category() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rtech.liveapi.PlayerKilled.category)
  return _internal_category();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PlayerKilled::set_category(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.category_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:rtech.liveapi.PlayerKilled.category)
}
inline std::string* PlayerKilled::mutable_category() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_category();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.PlayerKilled.category)
  return _s;
}
inline const std::string& PlayerKilled::_internal_category() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.category_.Get();
}
inline void PlayerKilled::_internal_set_category(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.category_.Set(value, GetArena());
}
inline std::string* PlayerKilled::_internal_mutable_category() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.category_.Mutable( GetArena());
}
inline std::string* PlayerKilled::release_category() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:rtech.liveapi.PlayerKilled.category)
  return _impl_.category_.Release();
}
inline void PlayerKilled::set_allocated_category(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.category_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.category_.IsDefault()) {
          _impl_.category_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.PlayerKilled.category)
}

// .rtech.liveapi.Player attacker = 3;
inline bool PlayerKilled::has_attacker() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.attacker_ != nullptr);
  return value;
}
inline void PlayerKilled::clear_attacker() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.attacker_ != nullptr) _impl_.attacker_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::rtech::liveapi::Player& PlayerKilled::_internal_attacker() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::rtech::liveapi::Player* p = _impl_.attacker_;
  return p != nullptr ? *p : reinterpret_cast<const ::rtech::liveapi::Player&>(::rtech::liveapi::_Player_default_instance_);
}
inline const ::rtech::liveapi::Player& PlayerKilled::attacker() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rtech.liveapi.PlayerKilled.attacker)
  return _internal_attacker();
}
inline void PlayerKilled::unsafe_arena_set_allocated_attacker(::rtech::liveapi::Player* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.attacker_);
  }
  _impl_.attacker_ = reinterpret_cast<::rtech::liveapi::Player*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rtech.liveapi.PlayerKilled.attacker)
}
inline ::rtech::liveapi::Player* PlayerKilled::release_attacker() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::rtech::liveapi::Player* released = _impl_.attacker_;
  _impl_.attacker_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::rtech::liveapi::Player* PlayerKilled::unsafe_arena_release_attacker() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:rtech.liveapi.PlayerKilled.attacker)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::rtech::liveapi::Player* temp = _impl_.attacker_;
  _impl_.attacker_ = nullptr;
  return temp;
}
inline ::rtech::liveapi::Player* PlayerKilled::_internal_mutable_attacker() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.attacker_ == nullptr) {
    auto* p = CreateMaybeMessage<::rtech::liveapi::Player>(GetArena());
    _impl_.attacker_ = reinterpret_cast<::rtech::liveapi::Player*>(p);
  }
  return _impl_.attacker_;
}
inline ::rtech::liveapi::Player* PlayerKilled::mutable_attacker() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::rtech::liveapi::Player* _msg = _internal_mutable_attacker();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.PlayerKilled.attacker)
  return _msg;
}
inline void PlayerKilled::set_allocated_attacker(::rtech::liveapi::Player* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::rtech::liveapi::Player*>(_impl_.attacker_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::rtech::liveapi::Player*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.attacker_ = reinterpret_cast<::rtech::liveapi::Player*>(value);
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.PlayerKilled.attacker)
}

// .rtech.liveapi.Player victim = 4;
inline bool PlayerKilled::has_victim() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.victim_ != nullptr);
  return value;
}
inline void PlayerKilled::clear_victim() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.victim_ != nullptr) _impl_.victim_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::rtech::liveapi::Player& PlayerKilled::_internal_victim() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::rtech::liveapi::Player* p = _impl_.victim_;
  return p != nullptr ? *p : reinterpret_cast<const ::rtech::liveapi::Player&>(::rtech::liveapi::_Player_default_instance_);
}
inline const ::rtech::liveapi::Player& PlayerKilled::victim() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rtech.liveapi.PlayerKilled.victim)
  return _internal_victim();
}
inline void PlayerKilled::unsafe_arena_set_allocated_victim(::rtech::liveapi::Player* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.victim_);
  }
  _impl_.victim_ = reinterpret_cast<::rtech::liveapi::Player*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rtech.liveapi.PlayerKilled.victim)
}
inline ::rtech::liveapi::Player* PlayerKilled::release_victim() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::rtech::liveapi::Player* released = _impl_.victim_;
  _impl_.victim_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::rtech::liveapi::Player* PlayerKilled::unsafe_arena_release_victim() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:rtech.liveapi.PlayerKilled.victim)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::rtech::liveapi::Player* temp = _impl_.victim_;
  _impl_.victim_ = nullptr;
  return temp;
}
inline ::rtech::liveapi::Player* PlayerKilled::_internal_mutable_victim() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.victim_ == nullptr) {
    auto* p = CreateMaybeMessage<::rtech::liveapi::Player>(GetArena());
    _impl_.victim_ = reinterpret_cast<::rtech::liveapi::Player*>(p);
  }
  return _impl_.victim_;
}
inline ::rtech::liveapi::Player* PlayerKilled::mutable_victim() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::rtech::liveapi::Player* _msg = _internal_mutable_victim();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.PlayerKilled.victim)
  return _msg;
}
inline void PlayerKilled::set_allocated_victim(::rtech::liveapi::Player* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::rtech::liveapi::Player*>(_impl_.victim_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::rtech::liveapi::Player*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.victim_ = reinterpret_cast<::rtech::liveapi::Player*>(value);
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.PlayerKilled.victim)
}

// string weapon = 6;
inline void PlayerKilled::clear_weapon() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.weapon_.ClearToEmpty();
}
inline const std::string& PlayerKilled::weapon() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rtech.liveapi.PlayerKilled.weapon)
  return _internal_weapon();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PlayerKilled::set_weapon(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.weapon_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:rtech.liveapi.PlayerKilled.weapon)
}
inline std::string* PlayerKilled::mutable_weapon() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_weapon();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.PlayerKilled.weapon)
  return _s;
}
inline const std::string& PlayerKilled::_internal_weapon() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.weapon_.Get();
}
inline void PlayerKilled::_internal_set_weapon(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.weapon_.Set(value, GetArena());
}
inline std::string* PlayerKilled::_internal_mutable_weapon() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.weapon_.Mutable( GetArena());
}
inline std::string* PlayerKilled::release_weapon() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:rtech.liveapi.PlayerKilled.weapon)
  return _impl_.weapon_.Release();
}
inline void PlayerKilled::set_allocated_weapon(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.weapon_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.weapon_.IsDefault()) {
          _impl_.weapon_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.PlayerKilled.weapon)
}

// -------------------------------------------------------------------

// PlayerDowned

// uint64 timestamp = 1;
inline void PlayerDowned::clear_timestamp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.timestamp_ = ::uint64_t{0u};
}
inline ::uint64_t PlayerDowned::timestamp() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.PlayerDowned.timestamp)
  return _internal_timestamp();
}
inline void PlayerDowned::set_timestamp(::uint64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:rtech.liveapi.PlayerDowned.timestamp)
}
inline ::uint64_t PlayerDowned::_internal_timestamp() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.timestamp_;
}
inline void PlayerDowned::_internal_set_timestamp(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.timestamp_ = value;
}

// string category = 2;
inline void PlayerDowned::clear_category() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.category_.ClearToEmpty();
}
inline const std::string& PlayerDowned::category() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rtech.liveapi.PlayerDowned.category)
  return _internal_category();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PlayerDowned::set_category(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.category_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:rtech.liveapi.PlayerDowned.category)
}
inline std::string* PlayerDowned::mutable_category() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_category();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.PlayerDowned.category)
  return _s;
}
inline const std::string& PlayerDowned::_internal_category() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.category_.Get();
}
inline void PlayerDowned::_internal_set_category(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.category_.Set(value, GetArena());
}
inline std::string* PlayerDowned::_internal_mutable_category() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.category_.Mutable( GetArena());
}
inline std::string* PlayerDowned::release_category() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:rtech.liveapi.PlayerDowned.category)
  return _impl_.category_.Release();
}
inline void PlayerDowned::set_allocated_category(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.category_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.category_.IsDefault()) {
          _impl_.category_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.PlayerDowned.category)
}

// .rtech.liveapi.Player attacker = 3;
inline bool PlayerDowned::has_attacker() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.attacker_ != nullptr);
  return value;
}
inline void PlayerDowned::clear_attacker() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.attacker_ != nullptr) _impl_.attacker_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::rtech::liveapi::Player& PlayerDowned::_internal_attacker() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::rtech::liveapi::Player* p = _impl_.attacker_;
  return p != nullptr ? *p : reinterpret_cast<const ::rtech::liveapi::Player&>(::rtech::liveapi::_Player_default_instance_);
}
inline const ::rtech::liveapi::Player& PlayerDowned::attacker() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rtech.liveapi.PlayerDowned.attacker)
  return _internal_attacker();
}
inline void PlayerDowned::unsafe_arena_set_allocated_attacker(::rtech::liveapi::Player* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.attacker_);
  }
  _impl_.attacker_ = reinterpret_cast<::rtech::liveapi::Player*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rtech.liveapi.PlayerDowned.attacker)
}
inline ::rtech::liveapi::Player* PlayerDowned::release_attacker() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::rtech::liveapi::Player* released = _impl_.attacker_;
  _impl_.attacker_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::rtech::liveapi::Player* PlayerDowned::unsafe_arena_release_attacker() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:rtech.liveapi.PlayerDowned.attacker)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::rtech::liveapi::Player* temp = _impl_.attacker_;
  _impl_.attacker_ = nullptr;
  return temp;
}
inline ::rtech::liveapi::Player* PlayerDowned::_internal_mutable_attacker() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.attacker_ == nullptr) {
    auto* p = CreateMaybeMessage<::rtech::liveapi::Player>(GetArena());
    _impl_.attacker_ = reinterpret_cast<::rtech::liveapi::Player*>(p);
  }
  return _impl_.attacker_;
}
inline ::rtech::liveapi::Player* PlayerDowned::mutable_attacker() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::rtech::liveapi::Player* _msg = _internal_mutable_attacker();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.PlayerDowned.attacker)
  return _msg;
}
inline void PlayerDowned::set_allocated_attacker(::rtech::liveapi::Player* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::rtech::liveapi::Player*>(_impl_.attacker_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::rtech::liveapi::Player*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.attacker_ = reinterpret_cast<::rtech::liveapi::Player*>(value);
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.PlayerDowned.attacker)
}

// .rtech.liveapi.Player victim = 4;
inline bool PlayerDowned::has_victim() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.victim_ != nullptr);
  return value;
}
inline void PlayerDowned::clear_victim() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.victim_ != nullptr) _impl_.victim_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::rtech::liveapi::Player& PlayerDowned::_internal_victim() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::rtech::liveapi::Player* p = _impl_.victim_;
  return p != nullptr ? *p : reinterpret_cast<const ::rtech::liveapi::Player&>(::rtech::liveapi::_Player_default_instance_);
}
inline const ::rtech::liveapi::Player& PlayerDowned::victim() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rtech.liveapi.PlayerDowned.victim)
  return _internal_victim();
}
inline void PlayerDowned::unsafe_arena_set_allocated_victim(::rtech::liveapi::Player* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.victim_);
  }
  _impl_.victim_ = reinterpret_cast<::rtech::liveapi::Player*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rtech.liveapi.PlayerDowned.victim)
}
inline ::rtech::liveapi::Player* PlayerDowned::release_victim() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::rtech::liveapi::Player* released = _impl_.victim_;
  _impl_.victim_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::rtech::liveapi::Player* PlayerDowned::unsafe_arena_release_victim() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:rtech.liveapi.PlayerDowned.victim)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::rtech::liveapi::Player* temp = _impl_.victim_;
  _impl_.victim_ = nullptr;
  return temp;
}
inline ::rtech::liveapi::Player* PlayerDowned::_internal_mutable_victim() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.victim_ == nullptr) {
    auto* p = CreateMaybeMessage<::rtech::liveapi::Player>(GetArena());
    _impl_.victim_ = reinterpret_cast<::rtech::liveapi::Player*>(p);
  }
  return _impl_.victim_;
}
inline ::rtech::liveapi::Player* PlayerDowned::mutable_victim() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::rtech::liveapi::Player* _msg = _internal_mutable_victim();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.PlayerDowned.victim)
  return _msg;
}
inline void PlayerDowned::set_allocated_victim(::rtech::liveapi::Player* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::rtech::liveapi::Player*>(_impl_.victim_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::rtech::liveapi::Player*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.victim_ = reinterpret_cast<::rtech::liveapi::Player*>(value);
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.PlayerDowned.victim)
}

// string weapon = 5;
inline void PlayerDowned::clear_weapon() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.weapon_.ClearToEmpty();
}
inline const std::string& PlayerDowned::weapon() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rtech.liveapi.PlayerDowned.weapon)
  return _internal_weapon();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PlayerDowned::set_weapon(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.weapon_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:rtech.liveapi.PlayerDowned.weapon)
}
inline std::string* PlayerDowned::mutable_weapon() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_weapon();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.PlayerDowned.weapon)
  return _s;
}
inline const std::string& PlayerDowned::_internal_weapon() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.weapon_.Get();
}
inline void PlayerDowned::_internal_set_weapon(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.weapon_.Set(value, GetArena());
}
inline std::string* PlayerDowned::_internal_mutable_weapon() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.weapon_.Mutable( GetArena());
}
inline std::string* PlayerDowned::release_weapon() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:rtech.liveapi.PlayerDowned.weapon)
  return _impl_.weapon_.Release();
}
inline void PlayerDowned::set_allocated_weapon(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.weapon_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.weapon_.IsDefault()) {
          _impl_.weapon_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.PlayerDowned.weapon)
}

// -------------------------------------------------------------------

// PlayerAssist

// uint64 timestamp = 1;
inline void PlayerAssist::clear_timestamp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.timestamp_ = ::uint64_t{0u};
}
inline ::uint64_t PlayerAssist::timestamp() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.PlayerAssist.timestamp)
  return _internal_timestamp();
}
inline void PlayerAssist::set_timestamp(::uint64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:rtech.liveapi.PlayerAssist.timestamp)
}
inline ::uint64_t PlayerAssist::_internal_timestamp() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.timestamp_;
}
inline void PlayerAssist::_internal_set_timestamp(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.timestamp_ = value;
}

// string category = 2;
inline void PlayerAssist::clear_category() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.category_.ClearToEmpty();
}
inline const std::string& PlayerAssist::category() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rtech.liveapi.PlayerAssist.category)
  return _internal_category();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PlayerAssist::set_category(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.category_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:rtech.liveapi.PlayerAssist.category)
}
inline std::string* PlayerAssist::mutable_category() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_category();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.PlayerAssist.category)
  return _s;
}
inline const std::string& PlayerAssist::_internal_category() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.category_.Get();
}
inline void PlayerAssist::_internal_set_category(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.category_.Set(value, GetArena());
}
inline std::string* PlayerAssist::_internal_mutable_category() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.category_.Mutable( GetArena());
}
inline std::string* PlayerAssist::release_category() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:rtech.liveapi.PlayerAssist.category)
  return _impl_.category_.Release();
}
inline void PlayerAssist::set_allocated_category(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.category_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.category_.IsDefault()) {
          _impl_.category_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.PlayerAssist.category)
}

// .rtech.liveapi.Player assistant = 3;
inline bool PlayerAssist::has_assistant() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.assistant_ != nullptr);
  return value;
}
inline void PlayerAssist::clear_assistant() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.assistant_ != nullptr) _impl_.assistant_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::rtech::liveapi::Player& PlayerAssist::_internal_assistant() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::rtech::liveapi::Player* p = _impl_.assistant_;
  return p != nullptr ? *p : reinterpret_cast<const ::rtech::liveapi::Player&>(::rtech::liveapi::_Player_default_instance_);
}
inline const ::rtech::liveapi::Player& PlayerAssist::assistant() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rtech.liveapi.PlayerAssist.assistant)
  return _internal_assistant();
}
inline void PlayerAssist::unsafe_arena_set_allocated_assistant(::rtech::liveapi::Player* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.assistant_);
  }
  _impl_.assistant_ = reinterpret_cast<::rtech::liveapi::Player*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rtech.liveapi.PlayerAssist.assistant)
}
inline ::rtech::liveapi::Player* PlayerAssist::release_assistant() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::rtech::liveapi::Player* released = _impl_.assistant_;
  _impl_.assistant_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::rtech::liveapi::Player* PlayerAssist::unsafe_arena_release_assistant() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:rtech.liveapi.PlayerAssist.assistant)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::rtech::liveapi::Player* temp = _impl_.assistant_;
  _impl_.assistant_ = nullptr;
  return temp;
}
inline ::rtech::liveapi::Player* PlayerAssist::_internal_mutable_assistant() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.assistant_ == nullptr) {
    auto* p = CreateMaybeMessage<::rtech::liveapi::Player>(GetArena());
    _impl_.assistant_ = reinterpret_cast<::rtech::liveapi::Player*>(p);
  }
  return _impl_.assistant_;
}
inline ::rtech::liveapi::Player* PlayerAssist::mutable_assistant() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::rtech::liveapi::Player* _msg = _internal_mutable_assistant();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.PlayerAssist.assistant)
  return _msg;
}
inline void PlayerAssist::set_allocated_assistant(::rtech::liveapi::Player* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::rtech::liveapi::Player*>(_impl_.assistant_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::rtech::liveapi::Player*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.assistant_ = reinterpret_cast<::rtech::liveapi::Player*>(value);
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.PlayerAssist.assistant)
}

// .rtech.liveapi.Player victim = 4;
inline bool PlayerAssist::has_victim() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.victim_ != nullptr);
  return value;
}
inline void PlayerAssist::clear_victim() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.victim_ != nullptr) _impl_.victim_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::rtech::liveapi::Player& PlayerAssist::_internal_victim() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::rtech::liveapi::Player* p = _impl_.victim_;
  return p != nullptr ? *p : reinterpret_cast<const ::rtech::liveapi::Player&>(::rtech::liveapi::_Player_default_instance_);
}
inline const ::rtech::liveapi::Player& PlayerAssist::victim() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rtech.liveapi.PlayerAssist.victim)
  return _internal_victim();
}
inline void PlayerAssist::unsafe_arena_set_allocated_victim(::rtech::liveapi::Player* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.victim_);
  }
  _impl_.victim_ = reinterpret_cast<::rtech::liveapi::Player*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rtech.liveapi.PlayerAssist.victim)
}
inline ::rtech::liveapi::Player* PlayerAssist::release_victim() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::rtech::liveapi::Player* released = _impl_.victim_;
  _impl_.victim_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::rtech::liveapi::Player* PlayerAssist::unsafe_arena_release_victim() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:rtech.liveapi.PlayerAssist.victim)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::rtech::liveapi::Player* temp = _impl_.victim_;
  _impl_.victim_ = nullptr;
  return temp;
}
inline ::rtech::liveapi::Player* PlayerAssist::_internal_mutable_victim() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.victim_ == nullptr) {
    auto* p = CreateMaybeMessage<::rtech::liveapi::Player>(GetArena());
    _impl_.victim_ = reinterpret_cast<::rtech::liveapi::Player*>(p);
  }
  return _impl_.victim_;
}
inline ::rtech::liveapi::Player* PlayerAssist::mutable_victim() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::rtech::liveapi::Player* _msg = _internal_mutable_victim();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.PlayerAssist.victim)
  return _msg;
}
inline void PlayerAssist::set_allocated_victim(::rtech::liveapi::Player* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::rtech::liveapi::Player*>(_impl_.victim_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::rtech::liveapi::Player*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.victim_ = reinterpret_cast<::rtech::liveapi::Player*>(value);
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.PlayerAssist.victim)
}

// string weapon = 5;
inline void PlayerAssist::clear_weapon() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.weapon_.ClearToEmpty();
}
inline const std::string& PlayerAssist::weapon() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rtech.liveapi.PlayerAssist.weapon)
  return _internal_weapon();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PlayerAssist::set_weapon(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.weapon_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:rtech.liveapi.PlayerAssist.weapon)
}
inline std::string* PlayerAssist::mutable_weapon() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_weapon();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.PlayerAssist.weapon)
  return _s;
}
inline const std::string& PlayerAssist::_internal_weapon() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.weapon_.Get();
}
inline void PlayerAssist::_internal_set_weapon(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.weapon_.Set(value, GetArena());
}
inline std::string* PlayerAssist::_internal_mutable_weapon() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.weapon_.Mutable( GetArena());
}
inline std::string* PlayerAssist::release_weapon() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:rtech.liveapi.PlayerAssist.weapon)
  return _impl_.weapon_.Release();
}
inline void PlayerAssist::set_allocated_weapon(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.weapon_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.weapon_.IsDefault()) {
          _impl_.weapon_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.PlayerAssist.weapon)
}

// -------------------------------------------------------------------

// SquadEliminated

// uint64 timestamp = 1;
inline void SquadEliminated::clear_timestamp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.timestamp_ = ::uint64_t{0u};
}
inline ::uint64_t SquadEliminated::timestamp() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.SquadEliminated.timestamp)
  return _internal_timestamp();
}
inline void SquadEliminated::set_timestamp(::uint64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:rtech.liveapi.SquadEliminated.timestamp)
}
inline ::uint64_t SquadEliminated::_internal_timestamp() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.timestamp_;
}
inline void SquadEliminated::_internal_set_timestamp(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.timestamp_ = value;
}

// string category = 2;
inline void SquadEliminated::clear_category() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.category_.ClearToEmpty();
}
inline const std::string& SquadEliminated::category() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rtech.liveapi.SquadEliminated.category)
  return _internal_category();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SquadEliminated::set_category(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.category_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:rtech.liveapi.SquadEliminated.category)
}
inline std::string* SquadEliminated::mutable_category() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_category();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.SquadEliminated.category)
  return _s;
}
inline const std::string& SquadEliminated::_internal_category() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.category_.Get();
}
inline void SquadEliminated::_internal_set_category(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.category_.Set(value, GetArena());
}
inline std::string* SquadEliminated::_internal_mutable_category() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.category_.Mutable( GetArena());
}
inline std::string* SquadEliminated::release_category() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:rtech.liveapi.SquadEliminated.category)
  return _impl_.category_.Release();
}
inline void SquadEliminated::set_allocated_category(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.category_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.category_.IsDefault()) {
          _impl_.category_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.SquadEliminated.category)
}

// repeated .rtech.liveapi.Player players = 3;
inline int SquadEliminated::_internal_players_size() const {
  return _internal_players().size();
}
inline int SquadEliminated::players_size() const {
  return _internal_players_size();
}
inline void SquadEliminated::clear_players() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.players_.Clear();
}
inline ::rtech::liveapi::Player* SquadEliminated::mutable_players(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.SquadEliminated.players)
  return _internal_mutable_players()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::rtech::liveapi::Player>* SquadEliminated::mutable_players()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:rtech.liveapi.SquadEliminated.players)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_players();
}
inline const ::rtech::liveapi::Player& SquadEliminated::players(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rtech.liveapi.SquadEliminated.players)
  return _internal_players().Get(index);
}
inline ::rtech::liveapi::Player* SquadEliminated::add_players() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::rtech::liveapi::Player* _add = _internal_mutable_players()->Add();
  // @@protoc_insertion_point(field_add:rtech.liveapi.SquadEliminated.players)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::rtech::liveapi::Player>& SquadEliminated::players() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:rtech.liveapi.SquadEliminated.players)
  return _internal_players();
}
inline const ::google::protobuf::RepeatedPtrField<::rtech::liveapi::Player>&
SquadEliminated::_internal_players() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.players_;
}
inline ::google::protobuf::RepeatedPtrField<::rtech::liveapi::Player>*
SquadEliminated::_internal_mutable_players() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.players_;
}

// -------------------------------------------------------------------

// GibraltarShieldAbsorbed

// uint64 timestamp = 1;
inline void GibraltarShieldAbsorbed::clear_timestamp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.timestamp_ = ::uint64_t{0u};
}
inline ::uint64_t GibraltarShieldAbsorbed::timestamp() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.GibraltarShieldAbsorbed.timestamp)
  return _internal_timestamp();
}
inline void GibraltarShieldAbsorbed::set_timestamp(::uint64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:rtech.liveapi.GibraltarShieldAbsorbed.timestamp)
}
inline ::uint64_t GibraltarShieldAbsorbed::_internal_timestamp() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.timestamp_;
}
inline void GibraltarShieldAbsorbed::_internal_set_timestamp(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.timestamp_ = value;
}

// string category = 2;
inline void GibraltarShieldAbsorbed::clear_category() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.category_.ClearToEmpty();
}
inline const std::string& GibraltarShieldAbsorbed::category() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rtech.liveapi.GibraltarShieldAbsorbed.category)
  return _internal_category();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GibraltarShieldAbsorbed::set_category(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.category_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:rtech.liveapi.GibraltarShieldAbsorbed.category)
}
inline std::string* GibraltarShieldAbsorbed::mutable_category() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_category();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.GibraltarShieldAbsorbed.category)
  return _s;
}
inline const std::string& GibraltarShieldAbsorbed::_internal_category() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.category_.Get();
}
inline void GibraltarShieldAbsorbed::_internal_set_category(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.category_.Set(value, GetArena());
}
inline std::string* GibraltarShieldAbsorbed::_internal_mutable_category() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.category_.Mutable( GetArena());
}
inline std::string* GibraltarShieldAbsorbed::release_category() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:rtech.liveapi.GibraltarShieldAbsorbed.category)
  return _impl_.category_.Release();
}
inline void GibraltarShieldAbsorbed::set_allocated_category(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.category_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.category_.IsDefault()) {
          _impl_.category_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.GibraltarShieldAbsorbed.category)
}

// .rtech.liveapi.Player attacker = 3;
inline bool GibraltarShieldAbsorbed::has_attacker() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.attacker_ != nullptr);
  return value;
}
inline void GibraltarShieldAbsorbed::clear_attacker() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.attacker_ != nullptr) _impl_.attacker_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::rtech::liveapi::Player& GibraltarShieldAbsorbed::_internal_attacker() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::rtech::liveapi::Player* p = _impl_.attacker_;
  return p != nullptr ? *p : reinterpret_cast<const ::rtech::liveapi::Player&>(::rtech::liveapi::_Player_default_instance_);
}
inline const ::rtech::liveapi::Player& GibraltarShieldAbsorbed::attacker() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rtech.liveapi.GibraltarShieldAbsorbed.attacker)
  return _internal_attacker();
}
inline void GibraltarShieldAbsorbed::unsafe_arena_set_allocated_attacker(::rtech::liveapi::Player* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.attacker_);
  }
  _impl_.attacker_ = reinterpret_cast<::rtech::liveapi::Player*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rtech.liveapi.GibraltarShieldAbsorbed.attacker)
}
inline ::rtech::liveapi::Player* GibraltarShieldAbsorbed::release_attacker() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::rtech::liveapi::Player* released = _impl_.attacker_;
  _impl_.attacker_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::rtech::liveapi::Player* GibraltarShieldAbsorbed::unsafe_arena_release_attacker() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:rtech.liveapi.GibraltarShieldAbsorbed.attacker)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::rtech::liveapi::Player* temp = _impl_.attacker_;
  _impl_.attacker_ = nullptr;
  return temp;
}
inline ::rtech::liveapi::Player* GibraltarShieldAbsorbed::_internal_mutable_attacker() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.attacker_ == nullptr) {
    auto* p = CreateMaybeMessage<::rtech::liveapi::Player>(GetArena());
    _impl_.attacker_ = reinterpret_cast<::rtech::liveapi::Player*>(p);
  }
  return _impl_.attacker_;
}
inline ::rtech::liveapi::Player* GibraltarShieldAbsorbed::mutable_attacker() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::rtech::liveapi::Player* _msg = _internal_mutable_attacker();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.GibraltarShieldAbsorbed.attacker)
  return _msg;
}
inline void GibraltarShieldAbsorbed::set_allocated_attacker(::rtech::liveapi::Player* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::rtech::liveapi::Player*>(_impl_.attacker_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::rtech::liveapi::Player*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.attacker_ = reinterpret_cast<::rtech::liveapi::Player*>(value);
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.GibraltarShieldAbsorbed.attacker)
}

// .rtech.liveapi.Player victim = 4;
inline bool GibraltarShieldAbsorbed::has_victim() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.victim_ != nullptr);
  return value;
}
inline void GibraltarShieldAbsorbed::clear_victim() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.victim_ != nullptr) _impl_.victim_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::rtech::liveapi::Player& GibraltarShieldAbsorbed::_internal_victim() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::rtech::liveapi::Player* p = _impl_.victim_;
  return p != nullptr ? *p : reinterpret_cast<const ::rtech::liveapi::Player&>(::rtech::liveapi::_Player_default_instance_);
}
inline const ::rtech::liveapi::Player& GibraltarShieldAbsorbed::victim() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rtech.liveapi.GibraltarShieldAbsorbed.victim)
  return _internal_victim();
}
inline void GibraltarShieldAbsorbed::unsafe_arena_set_allocated_victim(::rtech::liveapi::Player* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.victim_);
  }
  _impl_.victim_ = reinterpret_cast<::rtech::liveapi::Player*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rtech.liveapi.GibraltarShieldAbsorbed.victim)
}
inline ::rtech::liveapi::Player* GibraltarShieldAbsorbed::release_victim() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::rtech::liveapi::Player* released = _impl_.victim_;
  _impl_.victim_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::rtech::liveapi::Player* GibraltarShieldAbsorbed::unsafe_arena_release_victim() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:rtech.liveapi.GibraltarShieldAbsorbed.victim)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::rtech::liveapi::Player* temp = _impl_.victim_;
  _impl_.victim_ = nullptr;
  return temp;
}
inline ::rtech::liveapi::Player* GibraltarShieldAbsorbed::_internal_mutable_victim() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.victim_ == nullptr) {
    auto* p = CreateMaybeMessage<::rtech::liveapi::Player>(GetArena());
    _impl_.victim_ = reinterpret_cast<::rtech::liveapi::Player*>(p);
  }
  return _impl_.victim_;
}
inline ::rtech::liveapi::Player* GibraltarShieldAbsorbed::mutable_victim() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::rtech::liveapi::Player* _msg = _internal_mutable_victim();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.GibraltarShieldAbsorbed.victim)
  return _msg;
}
inline void GibraltarShieldAbsorbed::set_allocated_victim(::rtech::liveapi::Player* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::rtech::liveapi::Player*>(_impl_.victim_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::rtech::liveapi::Player*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.victim_ = reinterpret_cast<::rtech::liveapi::Player*>(value);
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.GibraltarShieldAbsorbed.victim)
}

// uint32 damageInflicted = 6;
inline void GibraltarShieldAbsorbed::clear_damageinflicted() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.damageinflicted_ = 0u;
}
inline ::uint32_t GibraltarShieldAbsorbed::damageinflicted() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.GibraltarShieldAbsorbed.damageInflicted)
  return _internal_damageinflicted();
}
inline void GibraltarShieldAbsorbed::set_damageinflicted(::uint32_t value) {
  _internal_set_damageinflicted(value);
  // @@protoc_insertion_point(field_set:rtech.liveapi.GibraltarShieldAbsorbed.damageInflicted)
}
inline ::uint32_t GibraltarShieldAbsorbed::_internal_damageinflicted() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.damageinflicted_;
}
inline void GibraltarShieldAbsorbed::_internal_set_damageinflicted(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.damageinflicted_ = value;
}

// -------------------------------------------------------------------

// RevenantForgedShadowDamaged

// uint64 timestamp = 1;
inline void RevenantForgedShadowDamaged::clear_timestamp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.timestamp_ = ::uint64_t{0u};
}
inline ::uint64_t RevenantForgedShadowDamaged::timestamp() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.RevenantForgedShadowDamaged.timestamp)
  return _internal_timestamp();
}
inline void RevenantForgedShadowDamaged::set_timestamp(::uint64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:rtech.liveapi.RevenantForgedShadowDamaged.timestamp)
}
inline ::uint64_t RevenantForgedShadowDamaged::_internal_timestamp() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.timestamp_;
}
inline void RevenantForgedShadowDamaged::_internal_set_timestamp(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.timestamp_ = value;
}

// string category = 2;
inline void RevenantForgedShadowDamaged::clear_category() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.category_.ClearToEmpty();
}
inline const std::string& RevenantForgedShadowDamaged::category() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rtech.liveapi.RevenantForgedShadowDamaged.category)
  return _internal_category();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RevenantForgedShadowDamaged::set_category(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.category_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:rtech.liveapi.RevenantForgedShadowDamaged.category)
}
inline std::string* RevenantForgedShadowDamaged::mutable_category() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_category();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.RevenantForgedShadowDamaged.category)
  return _s;
}
inline const std::string& RevenantForgedShadowDamaged::_internal_category() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.category_.Get();
}
inline void RevenantForgedShadowDamaged::_internal_set_category(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.category_.Set(value, GetArena());
}
inline std::string* RevenantForgedShadowDamaged::_internal_mutable_category() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.category_.Mutable( GetArena());
}
inline std::string* RevenantForgedShadowDamaged::release_category() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:rtech.liveapi.RevenantForgedShadowDamaged.category)
  return _impl_.category_.Release();
}
inline void RevenantForgedShadowDamaged::set_allocated_category(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.category_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.category_.IsDefault()) {
          _impl_.category_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.RevenantForgedShadowDamaged.category)
}

// .rtech.liveapi.Player attacker = 3;
inline bool RevenantForgedShadowDamaged::has_attacker() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.attacker_ != nullptr);
  return value;
}
inline void RevenantForgedShadowDamaged::clear_attacker() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.attacker_ != nullptr) _impl_.attacker_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::rtech::liveapi::Player& RevenantForgedShadowDamaged::_internal_attacker() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::rtech::liveapi::Player* p = _impl_.attacker_;
  return p != nullptr ? *p : reinterpret_cast<const ::rtech::liveapi::Player&>(::rtech::liveapi::_Player_default_instance_);
}
inline const ::rtech::liveapi::Player& RevenantForgedShadowDamaged::attacker() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rtech.liveapi.RevenantForgedShadowDamaged.attacker)
  return _internal_attacker();
}
inline void RevenantForgedShadowDamaged::unsafe_arena_set_allocated_attacker(::rtech::liveapi::Player* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.attacker_);
  }
  _impl_.attacker_ = reinterpret_cast<::rtech::liveapi::Player*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rtech.liveapi.RevenantForgedShadowDamaged.attacker)
}
inline ::rtech::liveapi::Player* RevenantForgedShadowDamaged::release_attacker() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::rtech::liveapi::Player* released = _impl_.attacker_;
  _impl_.attacker_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::rtech::liveapi::Player* RevenantForgedShadowDamaged::unsafe_arena_release_attacker() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:rtech.liveapi.RevenantForgedShadowDamaged.attacker)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::rtech::liveapi::Player* temp = _impl_.attacker_;
  _impl_.attacker_ = nullptr;
  return temp;
}
inline ::rtech::liveapi::Player* RevenantForgedShadowDamaged::_internal_mutable_attacker() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.attacker_ == nullptr) {
    auto* p = CreateMaybeMessage<::rtech::liveapi::Player>(GetArena());
    _impl_.attacker_ = reinterpret_cast<::rtech::liveapi::Player*>(p);
  }
  return _impl_.attacker_;
}
inline ::rtech::liveapi::Player* RevenantForgedShadowDamaged::mutable_attacker() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::rtech::liveapi::Player* _msg = _internal_mutable_attacker();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.RevenantForgedShadowDamaged.attacker)
  return _msg;
}
inline void RevenantForgedShadowDamaged::set_allocated_attacker(::rtech::liveapi::Player* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::rtech::liveapi::Player*>(_impl_.attacker_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::rtech::liveapi::Player*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.attacker_ = reinterpret_cast<::rtech::liveapi::Player*>(value);
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.RevenantForgedShadowDamaged.attacker)
}

// .rtech.liveapi.Player victim = 4;
inline bool RevenantForgedShadowDamaged::has_victim() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.victim_ != nullptr);
  return value;
}
inline void RevenantForgedShadowDamaged::clear_victim() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.victim_ != nullptr) _impl_.victim_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::rtech::liveapi::Player& RevenantForgedShadowDamaged::_internal_victim() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::rtech::liveapi::Player* p = _impl_.victim_;
  return p != nullptr ? *p : reinterpret_cast<const ::rtech::liveapi::Player&>(::rtech::liveapi::_Player_default_instance_);
}
inline const ::rtech::liveapi::Player& RevenantForgedShadowDamaged::victim() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rtech.liveapi.RevenantForgedShadowDamaged.victim)
  return _internal_victim();
}
inline void RevenantForgedShadowDamaged::unsafe_arena_set_allocated_victim(::rtech::liveapi::Player* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.victim_);
  }
  _impl_.victim_ = reinterpret_cast<::rtech::liveapi::Player*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rtech.liveapi.RevenantForgedShadowDamaged.victim)
}
inline ::rtech::liveapi::Player* RevenantForgedShadowDamaged::release_victim() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::rtech::liveapi::Player* released = _impl_.victim_;
  _impl_.victim_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::rtech::liveapi::Player* RevenantForgedShadowDamaged::unsafe_arena_release_victim() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:rtech.liveapi.RevenantForgedShadowDamaged.victim)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::rtech::liveapi::Player* temp = _impl_.victim_;
  _impl_.victim_ = nullptr;
  return temp;
}
inline ::rtech::liveapi::Player* RevenantForgedShadowDamaged::_internal_mutable_victim() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.victim_ == nullptr) {
    auto* p = CreateMaybeMessage<::rtech::liveapi::Player>(GetArena());
    _impl_.victim_ = reinterpret_cast<::rtech::liveapi::Player*>(p);
  }
  return _impl_.victim_;
}
inline ::rtech::liveapi::Player* RevenantForgedShadowDamaged::mutable_victim() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::rtech::liveapi::Player* _msg = _internal_mutable_victim();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.RevenantForgedShadowDamaged.victim)
  return _msg;
}
inline void RevenantForgedShadowDamaged::set_allocated_victim(::rtech::liveapi::Player* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::rtech::liveapi::Player*>(_impl_.victim_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::rtech::liveapi::Player*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.victim_ = reinterpret_cast<::rtech::liveapi::Player*>(value);
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.RevenantForgedShadowDamaged.victim)
}

// uint32 damageInflicted = 6;
inline void RevenantForgedShadowDamaged::clear_damageinflicted() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.damageinflicted_ = 0u;
}
inline ::uint32_t RevenantForgedShadowDamaged::damageinflicted() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.RevenantForgedShadowDamaged.damageInflicted)
  return _internal_damageinflicted();
}
inline void RevenantForgedShadowDamaged::set_damageinflicted(::uint32_t value) {
  _internal_set_damageinflicted(value);
  // @@protoc_insertion_point(field_set:rtech.liveapi.RevenantForgedShadowDamaged.damageInflicted)
}
inline ::uint32_t RevenantForgedShadowDamaged::_internal_damageinflicted() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.damageinflicted_;
}
inline void RevenantForgedShadowDamaged::_internal_set_damageinflicted(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.damageinflicted_ = value;
}

// -------------------------------------------------------------------

// PlayerRespawnTeam

// uint64 timestamp = 1;
inline void PlayerRespawnTeam::clear_timestamp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.timestamp_ = ::uint64_t{0u};
}
inline ::uint64_t PlayerRespawnTeam::timestamp() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.PlayerRespawnTeam.timestamp)
  return _internal_timestamp();
}
inline void PlayerRespawnTeam::set_timestamp(::uint64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:rtech.liveapi.PlayerRespawnTeam.timestamp)
}
inline ::uint64_t PlayerRespawnTeam::_internal_timestamp() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.timestamp_;
}
inline void PlayerRespawnTeam::_internal_set_timestamp(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.timestamp_ = value;
}

// string category = 2;
inline void PlayerRespawnTeam::clear_category() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.category_.ClearToEmpty();
}
inline const std::string& PlayerRespawnTeam::category() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rtech.liveapi.PlayerRespawnTeam.category)
  return _internal_category();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PlayerRespawnTeam::set_category(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.category_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:rtech.liveapi.PlayerRespawnTeam.category)
}
inline std::string* PlayerRespawnTeam::mutable_category() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_category();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.PlayerRespawnTeam.category)
  return _s;
}
inline const std::string& PlayerRespawnTeam::_internal_category() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.category_.Get();
}
inline void PlayerRespawnTeam::_internal_set_category(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.category_.Set(value, GetArena());
}
inline std::string* PlayerRespawnTeam::_internal_mutable_category() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.category_.Mutable( GetArena());
}
inline std::string* PlayerRespawnTeam::release_category() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:rtech.liveapi.PlayerRespawnTeam.category)
  return _impl_.category_.Release();
}
inline void PlayerRespawnTeam::set_allocated_category(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.category_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.category_.IsDefault()) {
          _impl_.category_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.PlayerRespawnTeam.category)
}

// .rtech.liveapi.Player player = 3;
inline bool PlayerRespawnTeam::has_player() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.player_ != nullptr);
  return value;
}
inline void PlayerRespawnTeam::clear_player() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.player_ != nullptr) _impl_.player_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::rtech::liveapi::Player& PlayerRespawnTeam::_internal_player() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::rtech::liveapi::Player* p = _impl_.player_;
  return p != nullptr ? *p : reinterpret_cast<const ::rtech::liveapi::Player&>(::rtech::liveapi::_Player_default_instance_);
}
inline const ::rtech::liveapi::Player& PlayerRespawnTeam::player() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rtech.liveapi.PlayerRespawnTeam.player)
  return _internal_player();
}
inline void PlayerRespawnTeam::unsafe_arena_set_allocated_player(::rtech::liveapi::Player* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.player_);
  }
  _impl_.player_ = reinterpret_cast<::rtech::liveapi::Player*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rtech.liveapi.PlayerRespawnTeam.player)
}
inline ::rtech::liveapi::Player* PlayerRespawnTeam::release_player() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::rtech::liveapi::Player* released = _impl_.player_;
  _impl_.player_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::rtech::liveapi::Player* PlayerRespawnTeam::unsafe_arena_release_player() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:rtech.liveapi.PlayerRespawnTeam.player)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::rtech::liveapi::Player* temp = _impl_.player_;
  _impl_.player_ = nullptr;
  return temp;
}
inline ::rtech::liveapi::Player* PlayerRespawnTeam::_internal_mutable_player() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.player_ == nullptr) {
    auto* p = CreateMaybeMessage<::rtech::liveapi::Player>(GetArena());
    _impl_.player_ = reinterpret_cast<::rtech::liveapi::Player*>(p);
  }
  return _impl_.player_;
}
inline ::rtech::liveapi::Player* PlayerRespawnTeam::mutable_player() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::rtech::liveapi::Player* _msg = _internal_mutable_player();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.PlayerRespawnTeam.player)
  return _msg;
}
inline void PlayerRespawnTeam::set_allocated_player(::rtech::liveapi::Player* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::rtech::liveapi::Player*>(_impl_.player_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::rtech::liveapi::Player*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.player_ = reinterpret_cast<::rtech::liveapi::Player*>(value);
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.PlayerRespawnTeam.player)
}

// string respawned = 4;
inline void PlayerRespawnTeam::clear_respawned() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.respawned_.ClearToEmpty();
}
inline const std::string& PlayerRespawnTeam::respawned() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rtech.liveapi.PlayerRespawnTeam.respawned)
  return _internal_respawned();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PlayerRespawnTeam::set_respawned(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.respawned_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:rtech.liveapi.PlayerRespawnTeam.respawned)
}
inline std::string* PlayerRespawnTeam::mutable_respawned() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_respawned();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.PlayerRespawnTeam.respawned)
  return _s;
}
inline const std::string& PlayerRespawnTeam::_internal_respawned() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.respawned_.Get();
}
inline void PlayerRespawnTeam::_internal_set_respawned(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.respawned_.Set(value, GetArena());
}
inline std::string* PlayerRespawnTeam::_internal_mutable_respawned() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.respawned_.Mutable( GetArena());
}
inline std::string* PlayerRespawnTeam::release_respawned() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:rtech.liveapi.PlayerRespawnTeam.respawned)
  return _impl_.respawned_.Release();
}
inline void PlayerRespawnTeam::set_allocated_respawned(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.respawned_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.respawned_.IsDefault()) {
          _impl_.respawned_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.PlayerRespawnTeam.respawned)
}

// -------------------------------------------------------------------

// PlayerRevive

// uint64 timestamp = 1;
inline void PlayerRevive::clear_timestamp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.timestamp_ = ::uint64_t{0u};
}
inline ::uint64_t PlayerRevive::timestamp() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.PlayerRevive.timestamp)
  return _internal_timestamp();
}
inline void PlayerRevive::set_timestamp(::uint64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:rtech.liveapi.PlayerRevive.timestamp)
}
inline ::uint64_t PlayerRevive::_internal_timestamp() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.timestamp_;
}
inline void PlayerRevive::_internal_set_timestamp(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.timestamp_ = value;
}

// string category = 2;
inline void PlayerRevive::clear_category() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.category_.ClearToEmpty();
}
inline const std::string& PlayerRevive::category() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rtech.liveapi.PlayerRevive.category)
  return _internal_category();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PlayerRevive::set_category(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.category_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:rtech.liveapi.PlayerRevive.category)
}
inline std::string* PlayerRevive::mutable_category() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_category();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.PlayerRevive.category)
  return _s;
}
inline const std::string& PlayerRevive::_internal_category() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.category_.Get();
}
inline void PlayerRevive::_internal_set_category(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.category_.Set(value, GetArena());
}
inline std::string* PlayerRevive::_internal_mutable_category() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.category_.Mutable( GetArena());
}
inline std::string* PlayerRevive::release_category() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:rtech.liveapi.PlayerRevive.category)
  return _impl_.category_.Release();
}
inline void PlayerRevive::set_allocated_category(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.category_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.category_.IsDefault()) {
          _impl_.category_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.PlayerRevive.category)
}

// .rtech.liveapi.Player player = 3;
inline bool PlayerRevive::has_player() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.player_ != nullptr);
  return value;
}
inline void PlayerRevive::clear_player() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.player_ != nullptr) _impl_.player_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::rtech::liveapi::Player& PlayerRevive::_internal_player() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::rtech::liveapi::Player* p = _impl_.player_;
  return p != nullptr ? *p : reinterpret_cast<const ::rtech::liveapi::Player&>(::rtech::liveapi::_Player_default_instance_);
}
inline const ::rtech::liveapi::Player& PlayerRevive::player() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rtech.liveapi.PlayerRevive.player)
  return _internal_player();
}
inline void PlayerRevive::unsafe_arena_set_allocated_player(::rtech::liveapi::Player* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.player_);
  }
  _impl_.player_ = reinterpret_cast<::rtech::liveapi::Player*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rtech.liveapi.PlayerRevive.player)
}
inline ::rtech::liveapi::Player* PlayerRevive::release_player() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::rtech::liveapi::Player* released = _impl_.player_;
  _impl_.player_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::rtech::liveapi::Player* PlayerRevive::unsafe_arena_release_player() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:rtech.liveapi.PlayerRevive.player)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::rtech::liveapi::Player* temp = _impl_.player_;
  _impl_.player_ = nullptr;
  return temp;
}
inline ::rtech::liveapi::Player* PlayerRevive::_internal_mutable_player() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.player_ == nullptr) {
    auto* p = CreateMaybeMessage<::rtech::liveapi::Player>(GetArena());
    _impl_.player_ = reinterpret_cast<::rtech::liveapi::Player*>(p);
  }
  return _impl_.player_;
}
inline ::rtech::liveapi::Player* PlayerRevive::mutable_player() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::rtech::liveapi::Player* _msg = _internal_mutable_player();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.PlayerRevive.player)
  return _msg;
}
inline void PlayerRevive::set_allocated_player(::rtech::liveapi::Player* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::rtech::liveapi::Player*>(_impl_.player_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::rtech::liveapi::Player*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.player_ = reinterpret_cast<::rtech::liveapi::Player*>(value);
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.PlayerRevive.player)
}

// .rtech.liveapi.Player revived = 4;
inline bool PlayerRevive::has_revived() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.revived_ != nullptr);
  return value;
}
inline void PlayerRevive::clear_revived() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.revived_ != nullptr) _impl_.revived_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::rtech::liveapi::Player& PlayerRevive::_internal_revived() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::rtech::liveapi::Player* p = _impl_.revived_;
  return p != nullptr ? *p : reinterpret_cast<const ::rtech::liveapi::Player&>(::rtech::liveapi::_Player_default_instance_);
}
inline const ::rtech::liveapi::Player& PlayerRevive::revived() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rtech.liveapi.PlayerRevive.revived)
  return _internal_revived();
}
inline void PlayerRevive::unsafe_arena_set_allocated_revived(::rtech::liveapi::Player* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.revived_);
  }
  _impl_.revived_ = reinterpret_cast<::rtech::liveapi::Player*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rtech.liveapi.PlayerRevive.revived)
}
inline ::rtech::liveapi::Player* PlayerRevive::release_revived() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::rtech::liveapi::Player* released = _impl_.revived_;
  _impl_.revived_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::rtech::liveapi::Player* PlayerRevive::unsafe_arena_release_revived() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:rtech.liveapi.PlayerRevive.revived)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::rtech::liveapi::Player* temp = _impl_.revived_;
  _impl_.revived_ = nullptr;
  return temp;
}
inline ::rtech::liveapi::Player* PlayerRevive::_internal_mutable_revived() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.revived_ == nullptr) {
    auto* p = CreateMaybeMessage<::rtech::liveapi::Player>(GetArena());
    _impl_.revived_ = reinterpret_cast<::rtech::liveapi::Player*>(p);
  }
  return _impl_.revived_;
}
inline ::rtech::liveapi::Player* PlayerRevive::mutable_revived() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::rtech::liveapi::Player* _msg = _internal_mutable_revived();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.PlayerRevive.revived)
  return _msg;
}
inline void PlayerRevive::set_allocated_revived(::rtech::liveapi::Player* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::rtech::liveapi::Player*>(_impl_.revived_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::rtech::liveapi::Player*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.revived_ = reinterpret_cast<::rtech::liveapi::Player*>(value);
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.PlayerRevive.revived)
}

// -------------------------------------------------------------------

// ArenasItemSelected

// uint64 timestamp = 1;
inline void ArenasItemSelected::clear_timestamp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.timestamp_ = ::uint64_t{0u};
}
inline ::uint64_t ArenasItemSelected::timestamp() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.ArenasItemSelected.timestamp)
  return _internal_timestamp();
}
inline void ArenasItemSelected::set_timestamp(::uint64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:rtech.liveapi.ArenasItemSelected.timestamp)
}
inline ::uint64_t ArenasItemSelected::_internal_timestamp() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.timestamp_;
}
inline void ArenasItemSelected::_internal_set_timestamp(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.timestamp_ = value;
}

// string category = 2;
inline void ArenasItemSelected::clear_category() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.category_.ClearToEmpty();
}
inline const std::string& ArenasItemSelected::category() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rtech.liveapi.ArenasItemSelected.category)
  return _internal_category();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ArenasItemSelected::set_category(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.category_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:rtech.liveapi.ArenasItemSelected.category)
}
inline std::string* ArenasItemSelected::mutable_category() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_category();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.ArenasItemSelected.category)
  return _s;
}
inline const std::string& ArenasItemSelected::_internal_category() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.category_.Get();
}
inline void ArenasItemSelected::_internal_set_category(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.category_.Set(value, GetArena());
}
inline std::string* ArenasItemSelected::_internal_mutable_category() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.category_.Mutable( GetArena());
}
inline std::string* ArenasItemSelected::release_category() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:rtech.liveapi.ArenasItemSelected.category)
  return _impl_.category_.Release();
}
inline void ArenasItemSelected::set_allocated_category(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.category_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.category_.IsDefault()) {
          _impl_.category_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.ArenasItemSelected.category)
}

// .rtech.liveapi.Player player = 3;
inline bool ArenasItemSelected::has_player() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.player_ != nullptr);
  return value;
}
inline void ArenasItemSelected::clear_player() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.player_ != nullptr) _impl_.player_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::rtech::liveapi::Player& ArenasItemSelected::_internal_player() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::rtech::liveapi::Player* p = _impl_.player_;
  return p != nullptr ? *p : reinterpret_cast<const ::rtech::liveapi::Player&>(::rtech::liveapi::_Player_default_instance_);
}
inline const ::rtech::liveapi::Player& ArenasItemSelected::player() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rtech.liveapi.ArenasItemSelected.player)
  return _internal_player();
}
inline void ArenasItemSelected::unsafe_arena_set_allocated_player(::rtech::liveapi::Player* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.player_);
  }
  _impl_.player_ = reinterpret_cast<::rtech::liveapi::Player*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rtech.liveapi.ArenasItemSelected.player)
}
inline ::rtech::liveapi::Player* ArenasItemSelected::release_player() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::rtech::liveapi::Player* released = _impl_.player_;
  _impl_.player_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::rtech::liveapi::Player* ArenasItemSelected::unsafe_arena_release_player() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:rtech.liveapi.ArenasItemSelected.player)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::rtech::liveapi::Player* temp = _impl_.player_;
  _impl_.player_ = nullptr;
  return temp;
}
inline ::rtech::liveapi::Player* ArenasItemSelected::_internal_mutable_player() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.player_ == nullptr) {
    auto* p = CreateMaybeMessage<::rtech::liveapi::Player>(GetArena());
    _impl_.player_ = reinterpret_cast<::rtech::liveapi::Player*>(p);
  }
  return _impl_.player_;
}
inline ::rtech::liveapi::Player* ArenasItemSelected::mutable_player() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::rtech::liveapi::Player* _msg = _internal_mutable_player();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.ArenasItemSelected.player)
  return _msg;
}
inline void ArenasItemSelected::set_allocated_player(::rtech::liveapi::Player* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::rtech::liveapi::Player*>(_impl_.player_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::rtech::liveapi::Player*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.player_ = reinterpret_cast<::rtech::liveapi::Player*>(value);
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.ArenasItemSelected.player)
}

// string item = 4;
inline void ArenasItemSelected::clear_item() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.item_.ClearToEmpty();
}
inline const std::string& ArenasItemSelected::item() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rtech.liveapi.ArenasItemSelected.item)
  return _internal_item();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ArenasItemSelected::set_item(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.item_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:rtech.liveapi.ArenasItemSelected.item)
}
inline std::string* ArenasItemSelected::mutable_item() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_item();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.ArenasItemSelected.item)
  return _s;
}
inline const std::string& ArenasItemSelected::_internal_item() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.item_.Get();
}
inline void ArenasItemSelected::_internal_set_item(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.item_.Set(value, GetArena());
}
inline std::string* ArenasItemSelected::_internal_mutable_item() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.item_.Mutable( GetArena());
}
inline std::string* ArenasItemSelected::release_item() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:rtech.liveapi.ArenasItemSelected.item)
  return _impl_.item_.Release();
}
inline void ArenasItemSelected::set_allocated_item(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.item_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.item_.IsDefault()) {
          _impl_.item_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.ArenasItemSelected.item)
}

// int32 quantity = 5;
inline void ArenasItemSelected::clear_quantity() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.quantity_ = 0;
}
inline ::int32_t ArenasItemSelected::quantity() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.ArenasItemSelected.quantity)
  return _internal_quantity();
}
inline void ArenasItemSelected::set_quantity(::int32_t value) {
  _internal_set_quantity(value);
  // @@protoc_insertion_point(field_set:rtech.liveapi.ArenasItemSelected.quantity)
}
inline ::int32_t ArenasItemSelected::_internal_quantity() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.quantity_;
}
inline void ArenasItemSelected::_internal_set_quantity(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.quantity_ = value;
}

// -------------------------------------------------------------------

// ArenasItemDeselected

// uint64 timestamp = 1;
inline void ArenasItemDeselected::clear_timestamp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.timestamp_ = ::uint64_t{0u};
}
inline ::uint64_t ArenasItemDeselected::timestamp() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.ArenasItemDeselected.timestamp)
  return _internal_timestamp();
}
inline void ArenasItemDeselected::set_timestamp(::uint64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:rtech.liveapi.ArenasItemDeselected.timestamp)
}
inline ::uint64_t ArenasItemDeselected::_internal_timestamp() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.timestamp_;
}
inline void ArenasItemDeselected::_internal_set_timestamp(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.timestamp_ = value;
}

// string category = 2;
inline void ArenasItemDeselected::clear_category() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.category_.ClearToEmpty();
}
inline const std::string& ArenasItemDeselected::category() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rtech.liveapi.ArenasItemDeselected.category)
  return _internal_category();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ArenasItemDeselected::set_category(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.category_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:rtech.liveapi.ArenasItemDeselected.category)
}
inline std::string* ArenasItemDeselected::mutable_category() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_category();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.ArenasItemDeselected.category)
  return _s;
}
inline const std::string& ArenasItemDeselected::_internal_category() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.category_.Get();
}
inline void ArenasItemDeselected::_internal_set_category(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.category_.Set(value, GetArena());
}
inline std::string* ArenasItemDeselected::_internal_mutable_category() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.category_.Mutable( GetArena());
}
inline std::string* ArenasItemDeselected::release_category() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:rtech.liveapi.ArenasItemDeselected.category)
  return _impl_.category_.Release();
}
inline void ArenasItemDeselected::set_allocated_category(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.category_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.category_.IsDefault()) {
          _impl_.category_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.ArenasItemDeselected.category)
}

// .rtech.liveapi.Player player = 3;
inline bool ArenasItemDeselected::has_player() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.player_ != nullptr);
  return value;
}
inline void ArenasItemDeselected::clear_player() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.player_ != nullptr) _impl_.player_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::rtech::liveapi::Player& ArenasItemDeselected::_internal_player() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::rtech::liveapi::Player* p = _impl_.player_;
  return p != nullptr ? *p : reinterpret_cast<const ::rtech::liveapi::Player&>(::rtech::liveapi::_Player_default_instance_);
}
inline const ::rtech::liveapi::Player& ArenasItemDeselected::player() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rtech.liveapi.ArenasItemDeselected.player)
  return _internal_player();
}
inline void ArenasItemDeselected::unsafe_arena_set_allocated_player(::rtech::liveapi::Player* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.player_);
  }
  _impl_.player_ = reinterpret_cast<::rtech::liveapi::Player*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rtech.liveapi.ArenasItemDeselected.player)
}
inline ::rtech::liveapi::Player* ArenasItemDeselected::release_player() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::rtech::liveapi::Player* released = _impl_.player_;
  _impl_.player_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::rtech::liveapi::Player* ArenasItemDeselected::unsafe_arena_release_player() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:rtech.liveapi.ArenasItemDeselected.player)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::rtech::liveapi::Player* temp = _impl_.player_;
  _impl_.player_ = nullptr;
  return temp;
}
inline ::rtech::liveapi::Player* ArenasItemDeselected::_internal_mutable_player() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.player_ == nullptr) {
    auto* p = CreateMaybeMessage<::rtech::liveapi::Player>(GetArena());
    _impl_.player_ = reinterpret_cast<::rtech::liveapi::Player*>(p);
  }
  return _impl_.player_;
}
inline ::rtech::liveapi::Player* ArenasItemDeselected::mutable_player() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::rtech::liveapi::Player* _msg = _internal_mutable_player();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.ArenasItemDeselected.player)
  return _msg;
}
inline void ArenasItemDeselected::set_allocated_player(::rtech::liveapi::Player* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::rtech::liveapi::Player*>(_impl_.player_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::rtech::liveapi::Player*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.player_ = reinterpret_cast<::rtech::liveapi::Player*>(value);
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.ArenasItemDeselected.player)
}

// string item = 4;
inline void ArenasItemDeselected::clear_item() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.item_.ClearToEmpty();
}
inline const std::string& ArenasItemDeselected::item() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rtech.liveapi.ArenasItemDeselected.item)
  return _internal_item();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ArenasItemDeselected::set_item(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.item_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:rtech.liveapi.ArenasItemDeselected.item)
}
inline std::string* ArenasItemDeselected::mutable_item() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_item();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.ArenasItemDeselected.item)
  return _s;
}
inline const std::string& ArenasItemDeselected::_internal_item() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.item_.Get();
}
inline void ArenasItemDeselected::_internal_set_item(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.item_.Set(value, GetArena());
}
inline std::string* ArenasItemDeselected::_internal_mutable_item() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.item_.Mutable( GetArena());
}
inline std::string* ArenasItemDeselected::release_item() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:rtech.liveapi.ArenasItemDeselected.item)
  return _impl_.item_.Release();
}
inline void ArenasItemDeselected::set_allocated_item(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.item_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.item_.IsDefault()) {
          _impl_.item_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.ArenasItemDeselected.item)
}

// int32 quantity = 5;
inline void ArenasItemDeselected::clear_quantity() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.quantity_ = 0;
}
inline ::int32_t ArenasItemDeselected::quantity() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.ArenasItemDeselected.quantity)
  return _internal_quantity();
}
inline void ArenasItemDeselected::set_quantity(::int32_t value) {
  _internal_set_quantity(value);
  // @@protoc_insertion_point(field_set:rtech.liveapi.ArenasItemDeselected.quantity)
}
inline ::int32_t ArenasItemDeselected::_internal_quantity() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.quantity_;
}
inline void ArenasItemDeselected::_internal_set_quantity(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.quantity_ = value;
}

// -------------------------------------------------------------------

// InventoryPickUp

// uint64 timestamp = 1;
inline void InventoryPickUp::clear_timestamp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.timestamp_ = ::uint64_t{0u};
}
inline ::uint64_t InventoryPickUp::timestamp() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.InventoryPickUp.timestamp)
  return _internal_timestamp();
}
inline void InventoryPickUp::set_timestamp(::uint64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:rtech.liveapi.InventoryPickUp.timestamp)
}
inline ::uint64_t InventoryPickUp::_internal_timestamp() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.timestamp_;
}
inline void InventoryPickUp::_internal_set_timestamp(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.timestamp_ = value;
}

// string category = 2;
inline void InventoryPickUp::clear_category() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.category_.ClearToEmpty();
}
inline const std::string& InventoryPickUp::category() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rtech.liveapi.InventoryPickUp.category)
  return _internal_category();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void InventoryPickUp::set_category(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.category_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:rtech.liveapi.InventoryPickUp.category)
}
inline std::string* InventoryPickUp::mutable_category() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_category();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.InventoryPickUp.category)
  return _s;
}
inline const std::string& InventoryPickUp::_internal_category() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.category_.Get();
}
inline void InventoryPickUp::_internal_set_category(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.category_.Set(value, GetArena());
}
inline std::string* InventoryPickUp::_internal_mutable_category() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.category_.Mutable( GetArena());
}
inline std::string* InventoryPickUp::release_category() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:rtech.liveapi.InventoryPickUp.category)
  return _impl_.category_.Release();
}
inline void InventoryPickUp::set_allocated_category(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.category_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.category_.IsDefault()) {
          _impl_.category_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.InventoryPickUp.category)
}

// .rtech.liveapi.Player player = 3;
inline bool InventoryPickUp::has_player() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.player_ != nullptr);
  return value;
}
inline void InventoryPickUp::clear_player() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.player_ != nullptr) _impl_.player_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::rtech::liveapi::Player& InventoryPickUp::_internal_player() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::rtech::liveapi::Player* p = _impl_.player_;
  return p != nullptr ? *p : reinterpret_cast<const ::rtech::liveapi::Player&>(::rtech::liveapi::_Player_default_instance_);
}
inline const ::rtech::liveapi::Player& InventoryPickUp::player() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rtech.liveapi.InventoryPickUp.player)
  return _internal_player();
}
inline void InventoryPickUp::unsafe_arena_set_allocated_player(::rtech::liveapi::Player* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.player_);
  }
  _impl_.player_ = reinterpret_cast<::rtech::liveapi::Player*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rtech.liveapi.InventoryPickUp.player)
}
inline ::rtech::liveapi::Player* InventoryPickUp::release_player() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::rtech::liveapi::Player* released = _impl_.player_;
  _impl_.player_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::rtech::liveapi::Player* InventoryPickUp::unsafe_arena_release_player() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:rtech.liveapi.InventoryPickUp.player)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::rtech::liveapi::Player* temp = _impl_.player_;
  _impl_.player_ = nullptr;
  return temp;
}
inline ::rtech::liveapi::Player* InventoryPickUp::_internal_mutable_player() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.player_ == nullptr) {
    auto* p = CreateMaybeMessage<::rtech::liveapi::Player>(GetArena());
    _impl_.player_ = reinterpret_cast<::rtech::liveapi::Player*>(p);
  }
  return _impl_.player_;
}
inline ::rtech::liveapi::Player* InventoryPickUp::mutable_player() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::rtech::liveapi::Player* _msg = _internal_mutable_player();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.InventoryPickUp.player)
  return _msg;
}
inline void InventoryPickUp::set_allocated_player(::rtech::liveapi::Player* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::rtech::liveapi::Player*>(_impl_.player_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::rtech::liveapi::Player*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.player_ = reinterpret_cast<::rtech::liveapi::Player*>(value);
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.InventoryPickUp.player)
}

// string item = 4;
inline void InventoryPickUp::clear_item() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.item_.ClearToEmpty();
}
inline const std::string& InventoryPickUp::item() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rtech.liveapi.InventoryPickUp.item)
  return _internal_item();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void InventoryPickUp::set_item(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.item_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:rtech.liveapi.InventoryPickUp.item)
}
inline std::string* InventoryPickUp::mutable_item() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_item();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.InventoryPickUp.item)
  return _s;
}
inline const std::string& InventoryPickUp::_internal_item() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.item_.Get();
}
inline void InventoryPickUp::_internal_set_item(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.item_.Set(value, GetArena());
}
inline std::string* InventoryPickUp::_internal_mutable_item() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.item_.Mutable( GetArena());
}
inline std::string* InventoryPickUp::release_item() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:rtech.liveapi.InventoryPickUp.item)
  return _impl_.item_.Release();
}
inline void InventoryPickUp::set_allocated_item(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.item_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.item_.IsDefault()) {
          _impl_.item_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.InventoryPickUp.item)
}

// int32 quantity = 5;
inline void InventoryPickUp::clear_quantity() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.quantity_ = 0;
}
inline ::int32_t InventoryPickUp::quantity() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.InventoryPickUp.quantity)
  return _internal_quantity();
}
inline void InventoryPickUp::set_quantity(::int32_t value) {
  _internal_set_quantity(value);
  // @@protoc_insertion_point(field_set:rtech.liveapi.InventoryPickUp.quantity)
}
inline ::int32_t InventoryPickUp::_internal_quantity() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.quantity_;
}
inline void InventoryPickUp::_internal_set_quantity(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.quantity_ = value;
}

// -------------------------------------------------------------------

// InventoryDrop

// uint64 timestamp = 1;
inline void InventoryDrop::clear_timestamp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.timestamp_ = ::uint64_t{0u};
}
inline ::uint64_t InventoryDrop::timestamp() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.InventoryDrop.timestamp)
  return _internal_timestamp();
}
inline void InventoryDrop::set_timestamp(::uint64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:rtech.liveapi.InventoryDrop.timestamp)
}
inline ::uint64_t InventoryDrop::_internal_timestamp() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.timestamp_;
}
inline void InventoryDrop::_internal_set_timestamp(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.timestamp_ = value;
}

// string category = 2;
inline void InventoryDrop::clear_category() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.category_.ClearToEmpty();
}
inline const std::string& InventoryDrop::category() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rtech.liveapi.InventoryDrop.category)
  return _internal_category();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void InventoryDrop::set_category(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.category_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:rtech.liveapi.InventoryDrop.category)
}
inline std::string* InventoryDrop::mutable_category() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_category();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.InventoryDrop.category)
  return _s;
}
inline const std::string& InventoryDrop::_internal_category() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.category_.Get();
}
inline void InventoryDrop::_internal_set_category(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.category_.Set(value, GetArena());
}
inline std::string* InventoryDrop::_internal_mutable_category() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.category_.Mutable( GetArena());
}
inline std::string* InventoryDrop::release_category() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:rtech.liveapi.InventoryDrop.category)
  return _impl_.category_.Release();
}
inline void InventoryDrop::set_allocated_category(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.category_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.category_.IsDefault()) {
          _impl_.category_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.InventoryDrop.category)
}

// .rtech.liveapi.Player player = 3;
inline bool InventoryDrop::has_player() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.player_ != nullptr);
  return value;
}
inline void InventoryDrop::clear_player() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.player_ != nullptr) _impl_.player_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::rtech::liveapi::Player& InventoryDrop::_internal_player() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::rtech::liveapi::Player* p = _impl_.player_;
  return p != nullptr ? *p : reinterpret_cast<const ::rtech::liveapi::Player&>(::rtech::liveapi::_Player_default_instance_);
}
inline const ::rtech::liveapi::Player& InventoryDrop::player() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rtech.liveapi.InventoryDrop.player)
  return _internal_player();
}
inline void InventoryDrop::unsafe_arena_set_allocated_player(::rtech::liveapi::Player* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.player_);
  }
  _impl_.player_ = reinterpret_cast<::rtech::liveapi::Player*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rtech.liveapi.InventoryDrop.player)
}
inline ::rtech::liveapi::Player* InventoryDrop::release_player() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::rtech::liveapi::Player* released = _impl_.player_;
  _impl_.player_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::rtech::liveapi::Player* InventoryDrop::unsafe_arena_release_player() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:rtech.liveapi.InventoryDrop.player)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::rtech::liveapi::Player* temp = _impl_.player_;
  _impl_.player_ = nullptr;
  return temp;
}
inline ::rtech::liveapi::Player* InventoryDrop::_internal_mutable_player() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.player_ == nullptr) {
    auto* p = CreateMaybeMessage<::rtech::liveapi::Player>(GetArena());
    _impl_.player_ = reinterpret_cast<::rtech::liveapi::Player*>(p);
  }
  return _impl_.player_;
}
inline ::rtech::liveapi::Player* InventoryDrop::mutable_player() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::rtech::liveapi::Player* _msg = _internal_mutable_player();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.InventoryDrop.player)
  return _msg;
}
inline void InventoryDrop::set_allocated_player(::rtech::liveapi::Player* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::rtech::liveapi::Player*>(_impl_.player_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::rtech::liveapi::Player*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.player_ = reinterpret_cast<::rtech::liveapi::Player*>(value);
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.InventoryDrop.player)
}

// string item = 4;
inline void InventoryDrop::clear_item() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.item_.ClearToEmpty();
}
inline const std::string& InventoryDrop::item() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rtech.liveapi.InventoryDrop.item)
  return _internal_item();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void InventoryDrop::set_item(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.item_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:rtech.liveapi.InventoryDrop.item)
}
inline std::string* InventoryDrop::mutable_item() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_item();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.InventoryDrop.item)
  return _s;
}
inline const std::string& InventoryDrop::_internal_item() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.item_.Get();
}
inline void InventoryDrop::_internal_set_item(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.item_.Set(value, GetArena());
}
inline std::string* InventoryDrop::_internal_mutable_item() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.item_.Mutable( GetArena());
}
inline std::string* InventoryDrop::release_item() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:rtech.liveapi.InventoryDrop.item)
  return _impl_.item_.Release();
}
inline void InventoryDrop::set_allocated_item(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.item_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.item_.IsDefault()) {
          _impl_.item_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.InventoryDrop.item)
}

// int32 quantity = 5;
inline void InventoryDrop::clear_quantity() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.quantity_ = 0;
}
inline ::int32_t InventoryDrop::quantity() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.InventoryDrop.quantity)
  return _internal_quantity();
}
inline void InventoryDrop::set_quantity(::int32_t value) {
  _internal_set_quantity(value);
  // @@protoc_insertion_point(field_set:rtech.liveapi.InventoryDrop.quantity)
}
inline ::int32_t InventoryDrop::_internal_quantity() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.quantity_;
}
inline void InventoryDrop::_internal_set_quantity(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.quantity_ = value;
}

// repeated string extraData = 6;
inline int InventoryDrop::_internal_extradata_size() const {
  return _internal_extradata().size();
}
inline int InventoryDrop::extradata_size() const {
  return _internal_extradata_size();
}
inline void InventoryDrop::clear_extradata() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.extradata_.Clear();
}
inline std::string* InventoryDrop::add_extradata()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_extradata()->Add();
  // @@protoc_insertion_point(field_add_mutable:rtech.liveapi.InventoryDrop.extraData)
  return _s;
}
inline const std::string& InventoryDrop::extradata(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rtech.liveapi.InventoryDrop.extraData)
  return _internal_extradata().Get(index);
}
inline std::string* InventoryDrop::mutable_extradata(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.InventoryDrop.extraData)
  return _internal_mutable_extradata()->Mutable(index);
}
inline void InventoryDrop::set_extradata(int index, const std::string& value) {
  _internal_mutable_extradata()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:rtech.liveapi.InventoryDrop.extraData)
}
inline void InventoryDrop::set_extradata(int index, std::string&& value) {
  _internal_mutable_extradata()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:rtech.liveapi.InventoryDrop.extraData)
}
inline void InventoryDrop::set_extradata(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_extradata()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:rtech.liveapi.InventoryDrop.extraData)
}
inline void InventoryDrop::set_extradata(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_extradata()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:rtech.liveapi.InventoryDrop.extraData)
}
inline void InventoryDrop::set_extradata(int index, absl::string_view value) {
  _internal_mutable_extradata()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:rtech.liveapi.InventoryDrop.extraData)
}
inline void InventoryDrop::add_extradata(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_extradata()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:rtech.liveapi.InventoryDrop.extraData)
}
inline void InventoryDrop::add_extradata(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_extradata()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:rtech.liveapi.InventoryDrop.extraData)
}
inline void InventoryDrop::add_extradata(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_extradata()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:rtech.liveapi.InventoryDrop.extraData)
}
inline void InventoryDrop::add_extradata(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_extradata()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:rtech.liveapi.InventoryDrop.extraData)
}
inline void InventoryDrop::add_extradata(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_extradata()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:rtech.liveapi.InventoryDrop.extraData)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
InventoryDrop::extradata() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:rtech.liveapi.InventoryDrop.extraData)
  return _internal_extradata();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
InventoryDrop::mutable_extradata() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:rtech.liveapi.InventoryDrop.extraData)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_extradata();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
InventoryDrop::_internal_extradata() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.extradata_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
InventoryDrop::_internal_mutable_extradata() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.extradata_;
}

// -------------------------------------------------------------------

// InventoryUse

// uint64 timestamp = 1;
inline void InventoryUse::clear_timestamp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.timestamp_ = ::uint64_t{0u};
}
inline ::uint64_t InventoryUse::timestamp() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.InventoryUse.timestamp)
  return _internal_timestamp();
}
inline void InventoryUse::set_timestamp(::uint64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:rtech.liveapi.InventoryUse.timestamp)
}
inline ::uint64_t InventoryUse::_internal_timestamp() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.timestamp_;
}
inline void InventoryUse::_internal_set_timestamp(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.timestamp_ = value;
}

// string category = 2;
inline void InventoryUse::clear_category() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.category_.ClearToEmpty();
}
inline const std::string& InventoryUse::category() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rtech.liveapi.InventoryUse.category)
  return _internal_category();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void InventoryUse::set_category(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.category_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:rtech.liveapi.InventoryUse.category)
}
inline std::string* InventoryUse::mutable_category() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_category();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.InventoryUse.category)
  return _s;
}
inline const std::string& InventoryUse::_internal_category() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.category_.Get();
}
inline void InventoryUse::_internal_set_category(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.category_.Set(value, GetArena());
}
inline std::string* InventoryUse::_internal_mutable_category() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.category_.Mutable( GetArena());
}
inline std::string* InventoryUse::release_category() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:rtech.liveapi.InventoryUse.category)
  return _impl_.category_.Release();
}
inline void InventoryUse::set_allocated_category(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.category_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.category_.IsDefault()) {
          _impl_.category_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.InventoryUse.category)
}

// .rtech.liveapi.Player player = 3;
inline bool InventoryUse::has_player() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.player_ != nullptr);
  return value;
}
inline void InventoryUse::clear_player() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.player_ != nullptr) _impl_.player_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::rtech::liveapi::Player& InventoryUse::_internal_player() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::rtech::liveapi::Player* p = _impl_.player_;
  return p != nullptr ? *p : reinterpret_cast<const ::rtech::liveapi::Player&>(::rtech::liveapi::_Player_default_instance_);
}
inline const ::rtech::liveapi::Player& InventoryUse::player() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rtech.liveapi.InventoryUse.player)
  return _internal_player();
}
inline void InventoryUse::unsafe_arena_set_allocated_player(::rtech::liveapi::Player* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.player_);
  }
  _impl_.player_ = reinterpret_cast<::rtech::liveapi::Player*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rtech.liveapi.InventoryUse.player)
}
inline ::rtech::liveapi::Player* InventoryUse::release_player() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::rtech::liveapi::Player* released = _impl_.player_;
  _impl_.player_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::rtech::liveapi::Player* InventoryUse::unsafe_arena_release_player() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:rtech.liveapi.InventoryUse.player)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::rtech::liveapi::Player* temp = _impl_.player_;
  _impl_.player_ = nullptr;
  return temp;
}
inline ::rtech::liveapi::Player* InventoryUse::_internal_mutable_player() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.player_ == nullptr) {
    auto* p = CreateMaybeMessage<::rtech::liveapi::Player>(GetArena());
    _impl_.player_ = reinterpret_cast<::rtech::liveapi::Player*>(p);
  }
  return _impl_.player_;
}
inline ::rtech::liveapi::Player* InventoryUse::mutable_player() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::rtech::liveapi::Player* _msg = _internal_mutable_player();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.InventoryUse.player)
  return _msg;
}
inline void InventoryUse::set_allocated_player(::rtech::liveapi::Player* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::rtech::liveapi::Player*>(_impl_.player_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::rtech::liveapi::Player*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.player_ = reinterpret_cast<::rtech::liveapi::Player*>(value);
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.InventoryUse.player)
}

// string item = 4;
inline void InventoryUse::clear_item() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.item_.ClearToEmpty();
}
inline const std::string& InventoryUse::item() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rtech.liveapi.InventoryUse.item)
  return _internal_item();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void InventoryUse::set_item(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.item_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:rtech.liveapi.InventoryUse.item)
}
inline std::string* InventoryUse::mutable_item() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_item();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.InventoryUse.item)
  return _s;
}
inline const std::string& InventoryUse::_internal_item() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.item_.Get();
}
inline void InventoryUse::_internal_set_item(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.item_.Set(value, GetArena());
}
inline std::string* InventoryUse::_internal_mutable_item() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.item_.Mutable( GetArena());
}
inline std::string* InventoryUse::release_item() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:rtech.liveapi.InventoryUse.item)
  return _impl_.item_.Release();
}
inline void InventoryUse::set_allocated_item(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.item_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.item_.IsDefault()) {
          _impl_.item_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.InventoryUse.item)
}

// int32 quantity = 5;
inline void InventoryUse::clear_quantity() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.quantity_ = 0;
}
inline ::int32_t InventoryUse::quantity() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.InventoryUse.quantity)
  return _internal_quantity();
}
inline void InventoryUse::set_quantity(::int32_t value) {
  _internal_set_quantity(value);
  // @@protoc_insertion_point(field_set:rtech.liveapi.InventoryUse.quantity)
}
inline ::int32_t InventoryUse::_internal_quantity() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.quantity_;
}
inline void InventoryUse::_internal_set_quantity(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.quantity_ = value;
}

// -------------------------------------------------------------------

// BannerCollected

// uint64 timestamp = 1;
inline void BannerCollected::clear_timestamp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.timestamp_ = ::uint64_t{0u};
}
inline ::uint64_t BannerCollected::timestamp() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.BannerCollected.timestamp)
  return _internal_timestamp();
}
inline void BannerCollected::set_timestamp(::uint64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:rtech.liveapi.BannerCollected.timestamp)
}
inline ::uint64_t BannerCollected::_internal_timestamp() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.timestamp_;
}
inline void BannerCollected::_internal_set_timestamp(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.timestamp_ = value;
}

// string category = 2;
inline void BannerCollected::clear_category() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.category_.ClearToEmpty();
}
inline const std::string& BannerCollected::category() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rtech.liveapi.BannerCollected.category)
  return _internal_category();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BannerCollected::set_category(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.category_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:rtech.liveapi.BannerCollected.category)
}
inline std::string* BannerCollected::mutable_category() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_category();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.BannerCollected.category)
  return _s;
}
inline const std::string& BannerCollected::_internal_category() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.category_.Get();
}
inline void BannerCollected::_internal_set_category(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.category_.Set(value, GetArena());
}
inline std::string* BannerCollected::_internal_mutable_category() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.category_.Mutable( GetArena());
}
inline std::string* BannerCollected::release_category() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:rtech.liveapi.BannerCollected.category)
  return _impl_.category_.Release();
}
inline void BannerCollected::set_allocated_category(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.category_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.category_.IsDefault()) {
          _impl_.category_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.BannerCollected.category)
}

// .rtech.liveapi.Player player = 3;
inline bool BannerCollected::has_player() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.player_ != nullptr);
  return value;
}
inline void BannerCollected::clear_player() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.player_ != nullptr) _impl_.player_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::rtech::liveapi::Player& BannerCollected::_internal_player() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::rtech::liveapi::Player* p = _impl_.player_;
  return p != nullptr ? *p : reinterpret_cast<const ::rtech::liveapi::Player&>(::rtech::liveapi::_Player_default_instance_);
}
inline const ::rtech::liveapi::Player& BannerCollected::player() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rtech.liveapi.BannerCollected.player)
  return _internal_player();
}
inline void BannerCollected::unsafe_arena_set_allocated_player(::rtech::liveapi::Player* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.player_);
  }
  _impl_.player_ = reinterpret_cast<::rtech::liveapi::Player*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rtech.liveapi.BannerCollected.player)
}
inline ::rtech::liveapi::Player* BannerCollected::release_player() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::rtech::liveapi::Player* released = _impl_.player_;
  _impl_.player_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::rtech::liveapi::Player* BannerCollected::unsafe_arena_release_player() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:rtech.liveapi.BannerCollected.player)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::rtech::liveapi::Player* temp = _impl_.player_;
  _impl_.player_ = nullptr;
  return temp;
}
inline ::rtech::liveapi::Player* BannerCollected::_internal_mutable_player() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.player_ == nullptr) {
    auto* p = CreateMaybeMessage<::rtech::liveapi::Player>(GetArena());
    _impl_.player_ = reinterpret_cast<::rtech::liveapi::Player*>(p);
  }
  return _impl_.player_;
}
inline ::rtech::liveapi::Player* BannerCollected::mutable_player() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::rtech::liveapi::Player* _msg = _internal_mutable_player();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.BannerCollected.player)
  return _msg;
}
inline void BannerCollected::set_allocated_player(::rtech::liveapi::Player* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::rtech::liveapi::Player*>(_impl_.player_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::rtech::liveapi::Player*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.player_ = reinterpret_cast<::rtech::liveapi::Player*>(value);
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.BannerCollected.player)
}

// .rtech.liveapi.Player collected = 4;
inline bool BannerCollected::has_collected() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.collected_ != nullptr);
  return value;
}
inline void BannerCollected::clear_collected() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.collected_ != nullptr) _impl_.collected_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::rtech::liveapi::Player& BannerCollected::_internal_collected() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::rtech::liveapi::Player* p = _impl_.collected_;
  return p != nullptr ? *p : reinterpret_cast<const ::rtech::liveapi::Player&>(::rtech::liveapi::_Player_default_instance_);
}
inline const ::rtech::liveapi::Player& BannerCollected::collected() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rtech.liveapi.BannerCollected.collected)
  return _internal_collected();
}
inline void BannerCollected::unsafe_arena_set_allocated_collected(::rtech::liveapi::Player* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.collected_);
  }
  _impl_.collected_ = reinterpret_cast<::rtech::liveapi::Player*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rtech.liveapi.BannerCollected.collected)
}
inline ::rtech::liveapi::Player* BannerCollected::release_collected() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::rtech::liveapi::Player* released = _impl_.collected_;
  _impl_.collected_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::rtech::liveapi::Player* BannerCollected::unsafe_arena_release_collected() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:rtech.liveapi.BannerCollected.collected)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::rtech::liveapi::Player* temp = _impl_.collected_;
  _impl_.collected_ = nullptr;
  return temp;
}
inline ::rtech::liveapi::Player* BannerCollected::_internal_mutable_collected() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.collected_ == nullptr) {
    auto* p = CreateMaybeMessage<::rtech::liveapi::Player>(GetArena());
    _impl_.collected_ = reinterpret_cast<::rtech::liveapi::Player*>(p);
  }
  return _impl_.collected_;
}
inline ::rtech::liveapi::Player* BannerCollected::mutable_collected() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::rtech::liveapi::Player* _msg = _internal_mutable_collected();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.BannerCollected.collected)
  return _msg;
}
inline void BannerCollected::set_allocated_collected(::rtech::liveapi::Player* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::rtech::liveapi::Player*>(_impl_.collected_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::rtech::liveapi::Player*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.collected_ = reinterpret_cast<::rtech::liveapi::Player*>(value);
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.BannerCollected.collected)
}

// -------------------------------------------------------------------

// PlayerAbilityUsed

// uint64 timestamp = 1;
inline void PlayerAbilityUsed::clear_timestamp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.timestamp_ = ::uint64_t{0u};
}
inline ::uint64_t PlayerAbilityUsed::timestamp() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.PlayerAbilityUsed.timestamp)
  return _internal_timestamp();
}
inline void PlayerAbilityUsed::set_timestamp(::uint64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:rtech.liveapi.PlayerAbilityUsed.timestamp)
}
inline ::uint64_t PlayerAbilityUsed::_internal_timestamp() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.timestamp_;
}
inline void PlayerAbilityUsed::_internal_set_timestamp(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.timestamp_ = value;
}

// string category = 2;
inline void PlayerAbilityUsed::clear_category() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.category_.ClearToEmpty();
}
inline const std::string& PlayerAbilityUsed::category() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rtech.liveapi.PlayerAbilityUsed.category)
  return _internal_category();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PlayerAbilityUsed::set_category(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.category_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:rtech.liveapi.PlayerAbilityUsed.category)
}
inline std::string* PlayerAbilityUsed::mutable_category() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_category();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.PlayerAbilityUsed.category)
  return _s;
}
inline const std::string& PlayerAbilityUsed::_internal_category() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.category_.Get();
}
inline void PlayerAbilityUsed::_internal_set_category(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.category_.Set(value, GetArena());
}
inline std::string* PlayerAbilityUsed::_internal_mutable_category() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.category_.Mutable( GetArena());
}
inline std::string* PlayerAbilityUsed::release_category() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:rtech.liveapi.PlayerAbilityUsed.category)
  return _impl_.category_.Release();
}
inline void PlayerAbilityUsed::set_allocated_category(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.category_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.category_.IsDefault()) {
          _impl_.category_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.PlayerAbilityUsed.category)
}

// .rtech.liveapi.Player player = 3;
inline bool PlayerAbilityUsed::has_player() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.player_ != nullptr);
  return value;
}
inline void PlayerAbilityUsed::clear_player() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.player_ != nullptr) _impl_.player_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::rtech::liveapi::Player& PlayerAbilityUsed::_internal_player() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::rtech::liveapi::Player* p = _impl_.player_;
  return p != nullptr ? *p : reinterpret_cast<const ::rtech::liveapi::Player&>(::rtech::liveapi::_Player_default_instance_);
}
inline const ::rtech::liveapi::Player& PlayerAbilityUsed::player() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rtech.liveapi.PlayerAbilityUsed.player)
  return _internal_player();
}
inline void PlayerAbilityUsed::unsafe_arena_set_allocated_player(::rtech::liveapi::Player* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.player_);
  }
  _impl_.player_ = reinterpret_cast<::rtech::liveapi::Player*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rtech.liveapi.PlayerAbilityUsed.player)
}
inline ::rtech::liveapi::Player* PlayerAbilityUsed::release_player() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::rtech::liveapi::Player* released = _impl_.player_;
  _impl_.player_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::rtech::liveapi::Player* PlayerAbilityUsed::unsafe_arena_release_player() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:rtech.liveapi.PlayerAbilityUsed.player)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::rtech::liveapi::Player* temp = _impl_.player_;
  _impl_.player_ = nullptr;
  return temp;
}
inline ::rtech::liveapi::Player* PlayerAbilityUsed::_internal_mutable_player() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.player_ == nullptr) {
    auto* p = CreateMaybeMessage<::rtech::liveapi::Player>(GetArena());
    _impl_.player_ = reinterpret_cast<::rtech::liveapi::Player*>(p);
  }
  return _impl_.player_;
}
inline ::rtech::liveapi::Player* PlayerAbilityUsed::mutable_player() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::rtech::liveapi::Player* _msg = _internal_mutable_player();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.PlayerAbilityUsed.player)
  return _msg;
}
inline void PlayerAbilityUsed::set_allocated_player(::rtech::liveapi::Player* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::rtech::liveapi::Player*>(_impl_.player_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::rtech::liveapi::Player*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.player_ = reinterpret_cast<::rtech::liveapi::Player*>(value);
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.PlayerAbilityUsed.player)
}

// string linkedEntity = 4;
inline void PlayerAbilityUsed::clear_linkedentity() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.linkedentity_.ClearToEmpty();
}
inline const std::string& PlayerAbilityUsed::linkedentity() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rtech.liveapi.PlayerAbilityUsed.linkedEntity)
  return _internal_linkedentity();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PlayerAbilityUsed::set_linkedentity(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.linkedentity_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:rtech.liveapi.PlayerAbilityUsed.linkedEntity)
}
inline std::string* PlayerAbilityUsed::mutable_linkedentity() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_linkedentity();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.PlayerAbilityUsed.linkedEntity)
  return _s;
}
inline const std::string& PlayerAbilityUsed::_internal_linkedentity() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.linkedentity_.Get();
}
inline void PlayerAbilityUsed::_internal_set_linkedentity(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.linkedentity_.Set(value, GetArena());
}
inline std::string* PlayerAbilityUsed::_internal_mutable_linkedentity() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.linkedentity_.Mutable( GetArena());
}
inline std::string* PlayerAbilityUsed::release_linkedentity() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:rtech.liveapi.PlayerAbilityUsed.linkedEntity)
  return _impl_.linkedentity_.Release();
}
inline void PlayerAbilityUsed::set_allocated_linkedentity(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.linkedentity_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.linkedentity_.IsDefault()) {
          _impl_.linkedentity_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.PlayerAbilityUsed.linkedEntity)
}

// -------------------------------------------------------------------

// LegendUpgradeSelected

// uint64 timestamp = 1;
inline void LegendUpgradeSelected::clear_timestamp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.timestamp_ = ::uint64_t{0u};
}
inline ::uint64_t LegendUpgradeSelected::timestamp() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.LegendUpgradeSelected.timestamp)
  return _internal_timestamp();
}
inline void LegendUpgradeSelected::set_timestamp(::uint64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:rtech.liveapi.LegendUpgradeSelected.timestamp)
}
inline ::uint64_t LegendUpgradeSelected::_internal_timestamp() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.timestamp_;
}
inline void LegendUpgradeSelected::_internal_set_timestamp(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.timestamp_ = value;
}

// string category = 2;
inline void LegendUpgradeSelected::clear_category() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.category_.ClearToEmpty();
}
inline const std::string& LegendUpgradeSelected::category() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rtech.liveapi.LegendUpgradeSelected.category)
  return _internal_category();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void LegendUpgradeSelected::set_category(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.category_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:rtech.liveapi.LegendUpgradeSelected.category)
}
inline std::string* LegendUpgradeSelected::mutable_category() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_category();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.LegendUpgradeSelected.category)
  return _s;
}
inline const std::string& LegendUpgradeSelected::_internal_category() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.category_.Get();
}
inline void LegendUpgradeSelected::_internal_set_category(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.category_.Set(value, GetArena());
}
inline std::string* LegendUpgradeSelected::_internal_mutable_category() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.category_.Mutable( GetArena());
}
inline std::string* LegendUpgradeSelected::release_category() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:rtech.liveapi.LegendUpgradeSelected.category)
  return _impl_.category_.Release();
}
inline void LegendUpgradeSelected::set_allocated_category(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.category_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.category_.IsDefault()) {
          _impl_.category_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.LegendUpgradeSelected.category)
}

// .rtech.liveapi.Player player = 3;
inline bool LegendUpgradeSelected::has_player() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.player_ != nullptr);
  return value;
}
inline void LegendUpgradeSelected::clear_player() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.player_ != nullptr) _impl_.player_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::rtech::liveapi::Player& LegendUpgradeSelected::_internal_player() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::rtech::liveapi::Player* p = _impl_.player_;
  return p != nullptr ? *p : reinterpret_cast<const ::rtech::liveapi::Player&>(::rtech::liveapi::_Player_default_instance_);
}
inline const ::rtech::liveapi::Player& LegendUpgradeSelected::player() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rtech.liveapi.LegendUpgradeSelected.player)
  return _internal_player();
}
inline void LegendUpgradeSelected::unsafe_arena_set_allocated_player(::rtech::liveapi::Player* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.player_);
  }
  _impl_.player_ = reinterpret_cast<::rtech::liveapi::Player*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rtech.liveapi.LegendUpgradeSelected.player)
}
inline ::rtech::liveapi::Player* LegendUpgradeSelected::release_player() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::rtech::liveapi::Player* released = _impl_.player_;
  _impl_.player_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::rtech::liveapi::Player* LegendUpgradeSelected::unsafe_arena_release_player() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:rtech.liveapi.LegendUpgradeSelected.player)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::rtech::liveapi::Player* temp = _impl_.player_;
  _impl_.player_ = nullptr;
  return temp;
}
inline ::rtech::liveapi::Player* LegendUpgradeSelected::_internal_mutable_player() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.player_ == nullptr) {
    auto* p = CreateMaybeMessage<::rtech::liveapi::Player>(GetArena());
    _impl_.player_ = reinterpret_cast<::rtech::liveapi::Player*>(p);
  }
  return _impl_.player_;
}
inline ::rtech::liveapi::Player* LegendUpgradeSelected::mutable_player() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::rtech::liveapi::Player* _msg = _internal_mutable_player();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.LegendUpgradeSelected.player)
  return _msg;
}
inline void LegendUpgradeSelected::set_allocated_player(::rtech::liveapi::Player* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::rtech::liveapi::Player*>(_impl_.player_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::rtech::liveapi::Player*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.player_ = reinterpret_cast<::rtech::liveapi::Player*>(value);
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.LegendUpgradeSelected.player)
}

// string upgradeName = 4;
inline void LegendUpgradeSelected::clear_upgradename() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.upgradename_.ClearToEmpty();
}
inline const std::string& LegendUpgradeSelected::upgradename() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rtech.liveapi.LegendUpgradeSelected.upgradeName)
  return _internal_upgradename();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void LegendUpgradeSelected::set_upgradename(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.upgradename_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:rtech.liveapi.LegendUpgradeSelected.upgradeName)
}
inline std::string* LegendUpgradeSelected::mutable_upgradename() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_upgradename();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.LegendUpgradeSelected.upgradeName)
  return _s;
}
inline const std::string& LegendUpgradeSelected::_internal_upgradename() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.upgradename_.Get();
}
inline void LegendUpgradeSelected::_internal_set_upgradename(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.upgradename_.Set(value, GetArena());
}
inline std::string* LegendUpgradeSelected::_internal_mutable_upgradename() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.upgradename_.Mutable( GetArena());
}
inline std::string* LegendUpgradeSelected::release_upgradename() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:rtech.liveapi.LegendUpgradeSelected.upgradeName)
  return _impl_.upgradename_.Release();
}
inline void LegendUpgradeSelected::set_allocated_upgradename(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.upgradename_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.upgradename_.IsDefault()) {
          _impl_.upgradename_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.LegendUpgradeSelected.upgradeName)
}

// string upgradeDesc = 5;
inline void LegendUpgradeSelected::clear_upgradedesc() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.upgradedesc_.ClearToEmpty();
}
inline const std::string& LegendUpgradeSelected::upgradedesc() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rtech.liveapi.LegendUpgradeSelected.upgradeDesc)
  return _internal_upgradedesc();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void LegendUpgradeSelected::set_upgradedesc(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.upgradedesc_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:rtech.liveapi.LegendUpgradeSelected.upgradeDesc)
}
inline std::string* LegendUpgradeSelected::mutable_upgradedesc() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_upgradedesc();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.LegendUpgradeSelected.upgradeDesc)
  return _s;
}
inline const std::string& LegendUpgradeSelected::_internal_upgradedesc() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.upgradedesc_.Get();
}
inline void LegendUpgradeSelected::_internal_set_upgradedesc(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.upgradedesc_.Set(value, GetArena());
}
inline std::string* LegendUpgradeSelected::_internal_mutable_upgradedesc() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.upgradedesc_.Mutable( GetArena());
}
inline std::string* LegendUpgradeSelected::release_upgradedesc() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:rtech.liveapi.LegendUpgradeSelected.upgradeDesc)
  return _impl_.upgradedesc_.Release();
}
inline void LegendUpgradeSelected::set_allocated_upgradedesc(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.upgradedesc_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.upgradedesc_.IsDefault()) {
          _impl_.upgradedesc_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.LegendUpgradeSelected.upgradeDesc)
}

// int32 level = 6;
inline void LegendUpgradeSelected::clear_level() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.level_ = 0;
}
inline ::int32_t LegendUpgradeSelected::level() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.LegendUpgradeSelected.level)
  return _internal_level();
}
inline void LegendUpgradeSelected::set_level(::int32_t value) {
  _internal_set_level(value);
  // @@protoc_insertion_point(field_set:rtech.liveapi.LegendUpgradeSelected.level)
}
inline ::int32_t LegendUpgradeSelected::_internal_level() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.level_;
}
inline void LegendUpgradeSelected::_internal_set_level(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.level_ = value;
}

// -------------------------------------------------------------------

// ZiplineUsed

// uint64 timestamp = 1;
inline void ZiplineUsed::clear_timestamp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.timestamp_ = ::uint64_t{0u};
}
inline ::uint64_t ZiplineUsed::timestamp() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.ZiplineUsed.timestamp)
  return _internal_timestamp();
}
inline void ZiplineUsed::set_timestamp(::uint64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:rtech.liveapi.ZiplineUsed.timestamp)
}
inline ::uint64_t ZiplineUsed::_internal_timestamp() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.timestamp_;
}
inline void ZiplineUsed::_internal_set_timestamp(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.timestamp_ = value;
}

// string category = 2;
inline void ZiplineUsed::clear_category() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.category_.ClearToEmpty();
}
inline const std::string& ZiplineUsed::category() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rtech.liveapi.ZiplineUsed.category)
  return _internal_category();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ZiplineUsed::set_category(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.category_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:rtech.liveapi.ZiplineUsed.category)
}
inline std::string* ZiplineUsed::mutable_category() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_category();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.ZiplineUsed.category)
  return _s;
}
inline const std::string& ZiplineUsed::_internal_category() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.category_.Get();
}
inline void ZiplineUsed::_internal_set_category(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.category_.Set(value, GetArena());
}
inline std::string* ZiplineUsed::_internal_mutable_category() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.category_.Mutable( GetArena());
}
inline std::string* ZiplineUsed::release_category() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:rtech.liveapi.ZiplineUsed.category)
  return _impl_.category_.Release();
}
inline void ZiplineUsed::set_allocated_category(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.category_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.category_.IsDefault()) {
          _impl_.category_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.ZiplineUsed.category)
}

// .rtech.liveapi.Player player = 3;
inline bool ZiplineUsed::has_player() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.player_ != nullptr);
  return value;
}
inline void ZiplineUsed::clear_player() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.player_ != nullptr) _impl_.player_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::rtech::liveapi::Player& ZiplineUsed::_internal_player() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::rtech::liveapi::Player* p = _impl_.player_;
  return p != nullptr ? *p : reinterpret_cast<const ::rtech::liveapi::Player&>(::rtech::liveapi::_Player_default_instance_);
}
inline const ::rtech::liveapi::Player& ZiplineUsed::player() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rtech.liveapi.ZiplineUsed.player)
  return _internal_player();
}
inline void ZiplineUsed::unsafe_arena_set_allocated_player(::rtech::liveapi::Player* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.player_);
  }
  _impl_.player_ = reinterpret_cast<::rtech::liveapi::Player*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rtech.liveapi.ZiplineUsed.player)
}
inline ::rtech::liveapi::Player* ZiplineUsed::release_player() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::rtech::liveapi::Player* released = _impl_.player_;
  _impl_.player_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::rtech::liveapi::Player* ZiplineUsed::unsafe_arena_release_player() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:rtech.liveapi.ZiplineUsed.player)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::rtech::liveapi::Player* temp = _impl_.player_;
  _impl_.player_ = nullptr;
  return temp;
}
inline ::rtech::liveapi::Player* ZiplineUsed::_internal_mutable_player() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.player_ == nullptr) {
    auto* p = CreateMaybeMessage<::rtech::liveapi::Player>(GetArena());
    _impl_.player_ = reinterpret_cast<::rtech::liveapi::Player*>(p);
  }
  return _impl_.player_;
}
inline ::rtech::liveapi::Player* ZiplineUsed::mutable_player() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::rtech::liveapi::Player* _msg = _internal_mutable_player();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.ZiplineUsed.player)
  return _msg;
}
inline void ZiplineUsed::set_allocated_player(::rtech::liveapi::Player* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::rtech::liveapi::Player*>(_impl_.player_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::rtech::liveapi::Player*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.player_ = reinterpret_cast<::rtech::liveapi::Player*>(value);
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.ZiplineUsed.player)
}

// string linkedEntity = 4;
inline void ZiplineUsed::clear_linkedentity() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.linkedentity_.ClearToEmpty();
}
inline const std::string& ZiplineUsed::linkedentity() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rtech.liveapi.ZiplineUsed.linkedEntity)
  return _internal_linkedentity();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ZiplineUsed::set_linkedentity(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.linkedentity_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:rtech.liveapi.ZiplineUsed.linkedEntity)
}
inline std::string* ZiplineUsed::mutable_linkedentity() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_linkedentity();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.ZiplineUsed.linkedEntity)
  return _s;
}
inline const std::string& ZiplineUsed::_internal_linkedentity() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.linkedentity_.Get();
}
inline void ZiplineUsed::_internal_set_linkedentity(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.linkedentity_.Set(value, GetArena());
}
inline std::string* ZiplineUsed::_internal_mutable_linkedentity() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.linkedentity_.Mutable( GetArena());
}
inline std::string* ZiplineUsed::release_linkedentity() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:rtech.liveapi.ZiplineUsed.linkedEntity)
  return _impl_.linkedentity_.Release();
}
inline void ZiplineUsed::set_allocated_linkedentity(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.linkedentity_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.linkedentity_.IsDefault()) {
          _impl_.linkedentity_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.ZiplineUsed.linkedEntity)
}

// -------------------------------------------------------------------

// GrenadeThrown

// uint64 timestamp = 1;
inline void GrenadeThrown::clear_timestamp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.timestamp_ = ::uint64_t{0u};
}
inline ::uint64_t GrenadeThrown::timestamp() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.GrenadeThrown.timestamp)
  return _internal_timestamp();
}
inline void GrenadeThrown::set_timestamp(::uint64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:rtech.liveapi.GrenadeThrown.timestamp)
}
inline ::uint64_t GrenadeThrown::_internal_timestamp() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.timestamp_;
}
inline void GrenadeThrown::_internal_set_timestamp(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.timestamp_ = value;
}

// string category = 2;
inline void GrenadeThrown::clear_category() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.category_.ClearToEmpty();
}
inline const std::string& GrenadeThrown::category() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rtech.liveapi.GrenadeThrown.category)
  return _internal_category();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GrenadeThrown::set_category(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.category_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:rtech.liveapi.GrenadeThrown.category)
}
inline std::string* GrenadeThrown::mutable_category() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_category();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.GrenadeThrown.category)
  return _s;
}
inline const std::string& GrenadeThrown::_internal_category() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.category_.Get();
}
inline void GrenadeThrown::_internal_set_category(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.category_.Set(value, GetArena());
}
inline std::string* GrenadeThrown::_internal_mutable_category() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.category_.Mutable( GetArena());
}
inline std::string* GrenadeThrown::release_category() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:rtech.liveapi.GrenadeThrown.category)
  return _impl_.category_.Release();
}
inline void GrenadeThrown::set_allocated_category(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.category_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.category_.IsDefault()) {
          _impl_.category_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.GrenadeThrown.category)
}

// .rtech.liveapi.Player player = 3;
inline bool GrenadeThrown::has_player() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.player_ != nullptr);
  return value;
}
inline void GrenadeThrown::clear_player() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.player_ != nullptr) _impl_.player_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::rtech::liveapi::Player& GrenadeThrown::_internal_player() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::rtech::liveapi::Player* p = _impl_.player_;
  return p != nullptr ? *p : reinterpret_cast<const ::rtech::liveapi::Player&>(::rtech::liveapi::_Player_default_instance_);
}
inline const ::rtech::liveapi::Player& GrenadeThrown::player() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rtech.liveapi.GrenadeThrown.player)
  return _internal_player();
}
inline void GrenadeThrown::unsafe_arena_set_allocated_player(::rtech::liveapi::Player* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.player_);
  }
  _impl_.player_ = reinterpret_cast<::rtech::liveapi::Player*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rtech.liveapi.GrenadeThrown.player)
}
inline ::rtech::liveapi::Player* GrenadeThrown::release_player() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::rtech::liveapi::Player* released = _impl_.player_;
  _impl_.player_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::rtech::liveapi::Player* GrenadeThrown::unsafe_arena_release_player() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:rtech.liveapi.GrenadeThrown.player)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::rtech::liveapi::Player* temp = _impl_.player_;
  _impl_.player_ = nullptr;
  return temp;
}
inline ::rtech::liveapi::Player* GrenadeThrown::_internal_mutable_player() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.player_ == nullptr) {
    auto* p = CreateMaybeMessage<::rtech::liveapi::Player>(GetArena());
    _impl_.player_ = reinterpret_cast<::rtech::liveapi::Player*>(p);
  }
  return _impl_.player_;
}
inline ::rtech::liveapi::Player* GrenadeThrown::mutable_player() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::rtech::liveapi::Player* _msg = _internal_mutable_player();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.GrenadeThrown.player)
  return _msg;
}
inline void GrenadeThrown::set_allocated_player(::rtech::liveapi::Player* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::rtech::liveapi::Player*>(_impl_.player_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::rtech::liveapi::Player*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.player_ = reinterpret_cast<::rtech::liveapi::Player*>(value);
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.GrenadeThrown.player)
}

// string linkedEntity = 4;
inline void GrenadeThrown::clear_linkedentity() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.linkedentity_.ClearToEmpty();
}
inline const std::string& GrenadeThrown::linkedentity() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rtech.liveapi.GrenadeThrown.linkedEntity)
  return _internal_linkedentity();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GrenadeThrown::set_linkedentity(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.linkedentity_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:rtech.liveapi.GrenadeThrown.linkedEntity)
}
inline std::string* GrenadeThrown::mutable_linkedentity() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_linkedentity();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.GrenadeThrown.linkedEntity)
  return _s;
}
inline const std::string& GrenadeThrown::_internal_linkedentity() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.linkedentity_.Get();
}
inline void GrenadeThrown::_internal_set_linkedentity(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.linkedentity_.Set(value, GetArena());
}
inline std::string* GrenadeThrown::_internal_mutable_linkedentity() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.linkedentity_.Mutable( GetArena());
}
inline std::string* GrenadeThrown::release_linkedentity() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:rtech.liveapi.GrenadeThrown.linkedEntity)
  return _impl_.linkedentity_.Release();
}
inline void GrenadeThrown::set_allocated_linkedentity(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.linkedentity_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.linkedentity_.IsDefault()) {
          _impl_.linkedentity_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.GrenadeThrown.linkedEntity)
}

// -------------------------------------------------------------------

// BlackMarketAction

// uint64 timestamp = 1;
inline void BlackMarketAction::clear_timestamp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.timestamp_ = ::uint64_t{0u};
}
inline ::uint64_t BlackMarketAction::timestamp() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.BlackMarketAction.timestamp)
  return _internal_timestamp();
}
inline void BlackMarketAction::set_timestamp(::uint64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:rtech.liveapi.BlackMarketAction.timestamp)
}
inline ::uint64_t BlackMarketAction::_internal_timestamp() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.timestamp_;
}
inline void BlackMarketAction::_internal_set_timestamp(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.timestamp_ = value;
}

// string category = 2;
inline void BlackMarketAction::clear_category() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.category_.ClearToEmpty();
}
inline const std::string& BlackMarketAction::category() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rtech.liveapi.BlackMarketAction.category)
  return _internal_category();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BlackMarketAction::set_category(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.category_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:rtech.liveapi.BlackMarketAction.category)
}
inline std::string* BlackMarketAction::mutable_category() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_category();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.BlackMarketAction.category)
  return _s;
}
inline const std::string& BlackMarketAction::_internal_category() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.category_.Get();
}
inline void BlackMarketAction::_internal_set_category(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.category_.Set(value, GetArena());
}
inline std::string* BlackMarketAction::_internal_mutable_category() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.category_.Mutable( GetArena());
}
inline std::string* BlackMarketAction::release_category() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:rtech.liveapi.BlackMarketAction.category)
  return _impl_.category_.Release();
}
inline void BlackMarketAction::set_allocated_category(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.category_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.category_.IsDefault()) {
          _impl_.category_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.BlackMarketAction.category)
}

// .rtech.liveapi.Player player = 3;
inline bool BlackMarketAction::has_player() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.player_ != nullptr);
  return value;
}
inline void BlackMarketAction::clear_player() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.player_ != nullptr) _impl_.player_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::rtech::liveapi::Player& BlackMarketAction::_internal_player() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::rtech::liveapi::Player* p = _impl_.player_;
  return p != nullptr ? *p : reinterpret_cast<const ::rtech::liveapi::Player&>(::rtech::liveapi::_Player_default_instance_);
}
inline const ::rtech::liveapi::Player& BlackMarketAction::player() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rtech.liveapi.BlackMarketAction.player)
  return _internal_player();
}
inline void BlackMarketAction::unsafe_arena_set_allocated_player(::rtech::liveapi::Player* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.player_);
  }
  _impl_.player_ = reinterpret_cast<::rtech::liveapi::Player*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rtech.liveapi.BlackMarketAction.player)
}
inline ::rtech::liveapi::Player* BlackMarketAction::release_player() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::rtech::liveapi::Player* released = _impl_.player_;
  _impl_.player_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::rtech::liveapi::Player* BlackMarketAction::unsafe_arena_release_player() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:rtech.liveapi.BlackMarketAction.player)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::rtech::liveapi::Player* temp = _impl_.player_;
  _impl_.player_ = nullptr;
  return temp;
}
inline ::rtech::liveapi::Player* BlackMarketAction::_internal_mutable_player() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.player_ == nullptr) {
    auto* p = CreateMaybeMessage<::rtech::liveapi::Player>(GetArena());
    _impl_.player_ = reinterpret_cast<::rtech::liveapi::Player*>(p);
  }
  return _impl_.player_;
}
inline ::rtech::liveapi::Player* BlackMarketAction::mutable_player() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::rtech::liveapi::Player* _msg = _internal_mutable_player();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.BlackMarketAction.player)
  return _msg;
}
inline void BlackMarketAction::set_allocated_player(::rtech::liveapi::Player* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::rtech::liveapi::Player*>(_impl_.player_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::rtech::liveapi::Player*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.player_ = reinterpret_cast<::rtech::liveapi::Player*>(value);
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.BlackMarketAction.player)
}

// string item = 4;
inline void BlackMarketAction::clear_item() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.item_.ClearToEmpty();
}
inline const std::string& BlackMarketAction::item() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rtech.liveapi.BlackMarketAction.item)
  return _internal_item();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BlackMarketAction::set_item(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.item_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:rtech.liveapi.BlackMarketAction.item)
}
inline std::string* BlackMarketAction::mutable_item() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_item();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.BlackMarketAction.item)
  return _s;
}
inline const std::string& BlackMarketAction::_internal_item() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.item_.Get();
}
inline void BlackMarketAction::_internal_set_item(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.item_.Set(value, GetArena());
}
inline std::string* BlackMarketAction::_internal_mutable_item() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.item_.Mutable( GetArena());
}
inline std::string* BlackMarketAction::release_item() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:rtech.liveapi.BlackMarketAction.item)
  return _impl_.item_.Release();
}
inline void BlackMarketAction::set_allocated_item(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.item_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.item_.IsDefault()) {
          _impl_.item_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.BlackMarketAction.item)
}

// -------------------------------------------------------------------

// WraithPortal

// uint64 timestamp = 1;
inline void WraithPortal::clear_timestamp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.timestamp_ = ::uint64_t{0u};
}
inline ::uint64_t WraithPortal::timestamp() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.WraithPortal.timestamp)
  return _internal_timestamp();
}
inline void WraithPortal::set_timestamp(::uint64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:rtech.liveapi.WraithPortal.timestamp)
}
inline ::uint64_t WraithPortal::_internal_timestamp() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.timestamp_;
}
inline void WraithPortal::_internal_set_timestamp(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.timestamp_ = value;
}

// string category = 2;
inline void WraithPortal::clear_category() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.category_.ClearToEmpty();
}
inline const std::string& WraithPortal::category() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rtech.liveapi.WraithPortal.category)
  return _internal_category();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void WraithPortal::set_category(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.category_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:rtech.liveapi.WraithPortal.category)
}
inline std::string* WraithPortal::mutable_category() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_category();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.WraithPortal.category)
  return _s;
}
inline const std::string& WraithPortal::_internal_category() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.category_.Get();
}
inline void WraithPortal::_internal_set_category(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.category_.Set(value, GetArena());
}
inline std::string* WraithPortal::_internal_mutable_category() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.category_.Mutable( GetArena());
}
inline std::string* WraithPortal::release_category() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:rtech.liveapi.WraithPortal.category)
  return _impl_.category_.Release();
}
inline void WraithPortal::set_allocated_category(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.category_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.category_.IsDefault()) {
          _impl_.category_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.WraithPortal.category)
}

// .rtech.liveapi.Player player = 3;
inline bool WraithPortal::has_player() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.player_ != nullptr);
  return value;
}
inline void WraithPortal::clear_player() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.player_ != nullptr) _impl_.player_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::rtech::liveapi::Player& WraithPortal::_internal_player() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::rtech::liveapi::Player* p = _impl_.player_;
  return p != nullptr ? *p : reinterpret_cast<const ::rtech::liveapi::Player&>(::rtech::liveapi::_Player_default_instance_);
}
inline const ::rtech::liveapi::Player& WraithPortal::player() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rtech.liveapi.WraithPortal.player)
  return _internal_player();
}
inline void WraithPortal::unsafe_arena_set_allocated_player(::rtech::liveapi::Player* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.player_);
  }
  _impl_.player_ = reinterpret_cast<::rtech::liveapi::Player*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rtech.liveapi.WraithPortal.player)
}
inline ::rtech::liveapi::Player* WraithPortal::release_player() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::rtech::liveapi::Player* released = _impl_.player_;
  _impl_.player_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::rtech::liveapi::Player* WraithPortal::unsafe_arena_release_player() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:rtech.liveapi.WraithPortal.player)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::rtech::liveapi::Player* temp = _impl_.player_;
  _impl_.player_ = nullptr;
  return temp;
}
inline ::rtech::liveapi::Player* WraithPortal::_internal_mutable_player() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.player_ == nullptr) {
    auto* p = CreateMaybeMessage<::rtech::liveapi::Player>(GetArena());
    _impl_.player_ = reinterpret_cast<::rtech::liveapi::Player*>(p);
  }
  return _impl_.player_;
}
inline ::rtech::liveapi::Player* WraithPortal::mutable_player() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::rtech::liveapi::Player* _msg = _internal_mutable_player();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.WraithPortal.player)
  return _msg;
}
inline void WraithPortal::set_allocated_player(::rtech::liveapi::Player* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::rtech::liveapi::Player*>(_impl_.player_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::rtech::liveapi::Player*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.player_ = reinterpret_cast<::rtech::liveapi::Player*>(value);
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.WraithPortal.player)
}

// -------------------------------------------------------------------

// WarpGateUsed

// uint64 timestamp = 1;
inline void WarpGateUsed::clear_timestamp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.timestamp_ = ::uint64_t{0u};
}
inline ::uint64_t WarpGateUsed::timestamp() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.WarpGateUsed.timestamp)
  return _internal_timestamp();
}
inline void WarpGateUsed::set_timestamp(::uint64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:rtech.liveapi.WarpGateUsed.timestamp)
}
inline ::uint64_t WarpGateUsed::_internal_timestamp() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.timestamp_;
}
inline void WarpGateUsed::_internal_set_timestamp(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.timestamp_ = value;
}

// string category = 2;
inline void WarpGateUsed::clear_category() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.category_.ClearToEmpty();
}
inline const std::string& WarpGateUsed::category() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rtech.liveapi.WarpGateUsed.category)
  return _internal_category();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void WarpGateUsed::set_category(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.category_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:rtech.liveapi.WarpGateUsed.category)
}
inline std::string* WarpGateUsed::mutable_category() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_category();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.WarpGateUsed.category)
  return _s;
}
inline const std::string& WarpGateUsed::_internal_category() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.category_.Get();
}
inline void WarpGateUsed::_internal_set_category(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.category_.Set(value, GetArena());
}
inline std::string* WarpGateUsed::_internal_mutable_category() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.category_.Mutable( GetArena());
}
inline std::string* WarpGateUsed::release_category() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:rtech.liveapi.WarpGateUsed.category)
  return _impl_.category_.Release();
}
inline void WarpGateUsed::set_allocated_category(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.category_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.category_.IsDefault()) {
          _impl_.category_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.WarpGateUsed.category)
}

// .rtech.liveapi.Player player = 3;
inline bool WarpGateUsed::has_player() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.player_ != nullptr);
  return value;
}
inline void WarpGateUsed::clear_player() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.player_ != nullptr) _impl_.player_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::rtech::liveapi::Player& WarpGateUsed::_internal_player() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::rtech::liveapi::Player* p = _impl_.player_;
  return p != nullptr ? *p : reinterpret_cast<const ::rtech::liveapi::Player&>(::rtech::liveapi::_Player_default_instance_);
}
inline const ::rtech::liveapi::Player& WarpGateUsed::player() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rtech.liveapi.WarpGateUsed.player)
  return _internal_player();
}
inline void WarpGateUsed::unsafe_arena_set_allocated_player(::rtech::liveapi::Player* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.player_);
  }
  _impl_.player_ = reinterpret_cast<::rtech::liveapi::Player*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rtech.liveapi.WarpGateUsed.player)
}
inline ::rtech::liveapi::Player* WarpGateUsed::release_player() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::rtech::liveapi::Player* released = _impl_.player_;
  _impl_.player_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::rtech::liveapi::Player* WarpGateUsed::unsafe_arena_release_player() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:rtech.liveapi.WarpGateUsed.player)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::rtech::liveapi::Player* temp = _impl_.player_;
  _impl_.player_ = nullptr;
  return temp;
}
inline ::rtech::liveapi::Player* WarpGateUsed::_internal_mutable_player() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.player_ == nullptr) {
    auto* p = CreateMaybeMessage<::rtech::liveapi::Player>(GetArena());
    _impl_.player_ = reinterpret_cast<::rtech::liveapi::Player*>(p);
  }
  return _impl_.player_;
}
inline ::rtech::liveapi::Player* WarpGateUsed::mutable_player() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::rtech::liveapi::Player* _msg = _internal_mutable_player();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.WarpGateUsed.player)
  return _msg;
}
inline void WarpGateUsed::set_allocated_player(::rtech::liveapi::Player* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::rtech::liveapi::Player*>(_impl_.player_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::rtech::liveapi::Player*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.player_ = reinterpret_cast<::rtech::liveapi::Player*>(value);
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.WarpGateUsed.player)
}

// -------------------------------------------------------------------

// AmmoUsed

// uint64 timestamp = 1;
inline void AmmoUsed::clear_timestamp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.timestamp_ = ::uint64_t{0u};
}
inline ::uint64_t AmmoUsed::timestamp() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.AmmoUsed.timestamp)
  return _internal_timestamp();
}
inline void AmmoUsed::set_timestamp(::uint64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:rtech.liveapi.AmmoUsed.timestamp)
}
inline ::uint64_t AmmoUsed::_internal_timestamp() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.timestamp_;
}
inline void AmmoUsed::_internal_set_timestamp(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.timestamp_ = value;
}

// string category = 2;
inline void AmmoUsed::clear_category() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.category_.ClearToEmpty();
}
inline const std::string& AmmoUsed::category() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rtech.liveapi.AmmoUsed.category)
  return _internal_category();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AmmoUsed::set_category(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.category_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:rtech.liveapi.AmmoUsed.category)
}
inline std::string* AmmoUsed::mutable_category() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_category();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.AmmoUsed.category)
  return _s;
}
inline const std::string& AmmoUsed::_internal_category() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.category_.Get();
}
inline void AmmoUsed::_internal_set_category(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.category_.Set(value, GetArena());
}
inline std::string* AmmoUsed::_internal_mutable_category() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.category_.Mutable( GetArena());
}
inline std::string* AmmoUsed::release_category() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:rtech.liveapi.AmmoUsed.category)
  return _impl_.category_.Release();
}
inline void AmmoUsed::set_allocated_category(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.category_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.category_.IsDefault()) {
          _impl_.category_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.AmmoUsed.category)
}

// .rtech.liveapi.Player player = 3;
inline bool AmmoUsed::has_player() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.player_ != nullptr);
  return value;
}
inline void AmmoUsed::clear_player() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.player_ != nullptr) _impl_.player_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::rtech::liveapi::Player& AmmoUsed::_internal_player() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::rtech::liveapi::Player* p = _impl_.player_;
  return p != nullptr ? *p : reinterpret_cast<const ::rtech::liveapi::Player&>(::rtech::liveapi::_Player_default_instance_);
}
inline const ::rtech::liveapi::Player& AmmoUsed::player() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rtech.liveapi.AmmoUsed.player)
  return _internal_player();
}
inline void AmmoUsed::unsafe_arena_set_allocated_player(::rtech::liveapi::Player* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.player_);
  }
  _impl_.player_ = reinterpret_cast<::rtech::liveapi::Player*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rtech.liveapi.AmmoUsed.player)
}
inline ::rtech::liveapi::Player* AmmoUsed::release_player() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::rtech::liveapi::Player* released = _impl_.player_;
  _impl_.player_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::rtech::liveapi::Player* AmmoUsed::unsafe_arena_release_player() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:rtech.liveapi.AmmoUsed.player)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::rtech::liveapi::Player* temp = _impl_.player_;
  _impl_.player_ = nullptr;
  return temp;
}
inline ::rtech::liveapi::Player* AmmoUsed::_internal_mutable_player() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.player_ == nullptr) {
    auto* p = CreateMaybeMessage<::rtech::liveapi::Player>(GetArena());
    _impl_.player_ = reinterpret_cast<::rtech::liveapi::Player*>(p);
  }
  return _impl_.player_;
}
inline ::rtech::liveapi::Player* AmmoUsed::mutable_player() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::rtech::liveapi::Player* _msg = _internal_mutable_player();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.AmmoUsed.player)
  return _msg;
}
inline void AmmoUsed::set_allocated_player(::rtech::liveapi::Player* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::rtech::liveapi::Player*>(_impl_.player_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::rtech::liveapi::Player*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.player_ = reinterpret_cast<::rtech::liveapi::Player*>(value);
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.AmmoUsed.player)
}

// string ammoType = 4;
inline void AmmoUsed::clear_ammotype() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ammotype_.ClearToEmpty();
}
inline const std::string& AmmoUsed::ammotype() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rtech.liveapi.AmmoUsed.ammoType)
  return _internal_ammotype();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AmmoUsed::set_ammotype(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.ammotype_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:rtech.liveapi.AmmoUsed.ammoType)
}
inline std::string* AmmoUsed::mutable_ammotype() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_ammotype();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.AmmoUsed.ammoType)
  return _s;
}
inline const std::string& AmmoUsed::_internal_ammotype() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.ammotype_.Get();
}
inline void AmmoUsed::_internal_set_ammotype(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.ammotype_.Set(value, GetArena());
}
inline std::string* AmmoUsed::_internal_mutable_ammotype() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.ammotype_.Mutable( GetArena());
}
inline std::string* AmmoUsed::release_ammotype() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:rtech.liveapi.AmmoUsed.ammoType)
  return _impl_.ammotype_.Release();
}
inline void AmmoUsed::set_allocated_ammotype(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ammotype_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.ammotype_.IsDefault()) {
          _impl_.ammotype_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.AmmoUsed.ammoType)
}

// uint32 amountUsed = 5;
inline void AmmoUsed::clear_amountused() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.amountused_ = 0u;
}
inline ::uint32_t AmmoUsed::amountused() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.AmmoUsed.amountUsed)
  return _internal_amountused();
}
inline void AmmoUsed::set_amountused(::uint32_t value) {
  _internal_set_amountused(value);
  // @@protoc_insertion_point(field_set:rtech.liveapi.AmmoUsed.amountUsed)
}
inline ::uint32_t AmmoUsed::_internal_amountused() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.amountused_;
}
inline void AmmoUsed::_internal_set_amountused(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.amountused_ = value;
}

// uint32 oldAmmoCount = 6;
inline void AmmoUsed::clear_oldammocount() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.oldammocount_ = 0u;
}
inline ::uint32_t AmmoUsed::oldammocount() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.AmmoUsed.oldAmmoCount)
  return _internal_oldammocount();
}
inline void AmmoUsed::set_oldammocount(::uint32_t value) {
  _internal_set_oldammocount(value);
  // @@protoc_insertion_point(field_set:rtech.liveapi.AmmoUsed.oldAmmoCount)
}
inline ::uint32_t AmmoUsed::_internal_oldammocount() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.oldammocount_;
}
inline void AmmoUsed::_internal_set_oldammocount(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.oldammocount_ = value;
}

// uint32 newAmmoCount = 7;
inline void AmmoUsed::clear_newammocount() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.newammocount_ = 0u;
}
inline ::uint32_t AmmoUsed::newammocount() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.AmmoUsed.newAmmoCount)
  return _internal_newammocount();
}
inline void AmmoUsed::set_newammocount(::uint32_t value) {
  _internal_set_newammocount(value);
  // @@protoc_insertion_point(field_set:rtech.liveapi.AmmoUsed.newAmmoCount)
}
inline ::uint32_t AmmoUsed::_internal_newammocount() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.newammocount_;
}
inline void AmmoUsed::_internal_set_newammocount(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.newammocount_ = value;
}

// -------------------------------------------------------------------

// WeaponSwitched

// uint64 timestamp = 1;
inline void WeaponSwitched::clear_timestamp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.timestamp_ = ::uint64_t{0u};
}
inline ::uint64_t WeaponSwitched::timestamp() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.WeaponSwitched.timestamp)
  return _internal_timestamp();
}
inline void WeaponSwitched::set_timestamp(::uint64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:rtech.liveapi.WeaponSwitched.timestamp)
}
inline ::uint64_t WeaponSwitched::_internal_timestamp() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.timestamp_;
}
inline void WeaponSwitched::_internal_set_timestamp(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.timestamp_ = value;
}

// string category = 2;
inline void WeaponSwitched::clear_category() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.category_.ClearToEmpty();
}
inline const std::string& WeaponSwitched::category() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rtech.liveapi.WeaponSwitched.category)
  return _internal_category();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void WeaponSwitched::set_category(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.category_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:rtech.liveapi.WeaponSwitched.category)
}
inline std::string* WeaponSwitched::mutable_category() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_category();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.WeaponSwitched.category)
  return _s;
}
inline const std::string& WeaponSwitched::_internal_category() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.category_.Get();
}
inline void WeaponSwitched::_internal_set_category(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.category_.Set(value, GetArena());
}
inline std::string* WeaponSwitched::_internal_mutable_category() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.category_.Mutable( GetArena());
}
inline std::string* WeaponSwitched::release_category() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:rtech.liveapi.WeaponSwitched.category)
  return _impl_.category_.Release();
}
inline void WeaponSwitched::set_allocated_category(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.category_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.category_.IsDefault()) {
          _impl_.category_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.WeaponSwitched.category)
}

// .rtech.liveapi.Player player = 3;
inline bool WeaponSwitched::has_player() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.player_ != nullptr);
  return value;
}
inline void WeaponSwitched::clear_player() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.player_ != nullptr) _impl_.player_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::rtech::liveapi::Player& WeaponSwitched::_internal_player() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::rtech::liveapi::Player* p = _impl_.player_;
  return p != nullptr ? *p : reinterpret_cast<const ::rtech::liveapi::Player&>(::rtech::liveapi::_Player_default_instance_);
}
inline const ::rtech::liveapi::Player& WeaponSwitched::player() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rtech.liveapi.WeaponSwitched.player)
  return _internal_player();
}
inline void WeaponSwitched::unsafe_arena_set_allocated_player(::rtech::liveapi::Player* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.player_);
  }
  _impl_.player_ = reinterpret_cast<::rtech::liveapi::Player*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rtech.liveapi.WeaponSwitched.player)
}
inline ::rtech::liveapi::Player* WeaponSwitched::release_player() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::rtech::liveapi::Player* released = _impl_.player_;
  _impl_.player_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::rtech::liveapi::Player* WeaponSwitched::unsafe_arena_release_player() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:rtech.liveapi.WeaponSwitched.player)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::rtech::liveapi::Player* temp = _impl_.player_;
  _impl_.player_ = nullptr;
  return temp;
}
inline ::rtech::liveapi::Player* WeaponSwitched::_internal_mutable_player() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.player_ == nullptr) {
    auto* p = CreateMaybeMessage<::rtech::liveapi::Player>(GetArena());
    _impl_.player_ = reinterpret_cast<::rtech::liveapi::Player*>(p);
  }
  return _impl_.player_;
}
inline ::rtech::liveapi::Player* WeaponSwitched::mutable_player() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::rtech::liveapi::Player* _msg = _internal_mutable_player();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.WeaponSwitched.player)
  return _msg;
}
inline void WeaponSwitched::set_allocated_player(::rtech::liveapi::Player* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::rtech::liveapi::Player*>(_impl_.player_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::rtech::liveapi::Player*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.player_ = reinterpret_cast<::rtech::liveapi::Player*>(value);
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.WeaponSwitched.player)
}

// string oldWeapon = 4;
inline void WeaponSwitched::clear_oldweapon() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.oldweapon_.ClearToEmpty();
}
inline const std::string& WeaponSwitched::oldweapon() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rtech.liveapi.WeaponSwitched.oldWeapon)
  return _internal_oldweapon();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void WeaponSwitched::set_oldweapon(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.oldweapon_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:rtech.liveapi.WeaponSwitched.oldWeapon)
}
inline std::string* WeaponSwitched::mutable_oldweapon() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_oldweapon();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.WeaponSwitched.oldWeapon)
  return _s;
}
inline const std::string& WeaponSwitched::_internal_oldweapon() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.oldweapon_.Get();
}
inline void WeaponSwitched::_internal_set_oldweapon(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.oldweapon_.Set(value, GetArena());
}
inline std::string* WeaponSwitched::_internal_mutable_oldweapon() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.oldweapon_.Mutable( GetArena());
}
inline std::string* WeaponSwitched::release_oldweapon() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:rtech.liveapi.WeaponSwitched.oldWeapon)
  return _impl_.oldweapon_.Release();
}
inline void WeaponSwitched::set_allocated_oldweapon(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.oldweapon_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.oldweapon_.IsDefault()) {
          _impl_.oldweapon_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.WeaponSwitched.oldWeapon)
}

// string newWeapon = 5;
inline void WeaponSwitched::clear_newweapon() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.newweapon_.ClearToEmpty();
}
inline const std::string& WeaponSwitched::newweapon() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rtech.liveapi.WeaponSwitched.newWeapon)
  return _internal_newweapon();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void WeaponSwitched::set_newweapon(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.newweapon_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:rtech.liveapi.WeaponSwitched.newWeapon)
}
inline std::string* WeaponSwitched::mutable_newweapon() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_newweapon();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.WeaponSwitched.newWeapon)
  return _s;
}
inline const std::string& WeaponSwitched::_internal_newweapon() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.newweapon_.Get();
}
inline void WeaponSwitched::_internal_set_newweapon(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.newweapon_.Set(value, GetArena());
}
inline std::string* WeaponSwitched::_internal_mutable_newweapon() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.newweapon_.Mutable( GetArena());
}
inline std::string* WeaponSwitched::release_newweapon() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:rtech.liveapi.WeaponSwitched.newWeapon)
  return _impl_.newweapon_.Release();
}
inline void WeaponSwitched::set_allocated_newweapon(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.newweapon_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.newweapon_.IsDefault()) {
          _impl_.newweapon_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.WeaponSwitched.newWeapon)
}

// -------------------------------------------------------------------

// ChangeCamera

// .rtech.liveapi.PlayerOfInterest poi = 1;
inline bool ChangeCamera::has_poi() const {
  return target_case() == kPoi;
}
inline void ChangeCamera::set_has_poi() {
  _impl_._oneof_case_[0] = kPoi;
}
inline void ChangeCamera::clear_poi() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (target_case() == kPoi) {
    _impl_.target_.poi_ = 0;
    clear_has_target();
  }
}
inline ::rtech::liveapi::PlayerOfInterest ChangeCamera::poi() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.ChangeCamera.poi)
  return _internal_poi();
}
inline void ChangeCamera::set_poi(::rtech::liveapi::PlayerOfInterest value) {
  _internal_set_poi(value);
  // @@protoc_insertion_point(field_set:rtech.liveapi.ChangeCamera.poi)
}
inline ::rtech::liveapi::PlayerOfInterest ChangeCamera::_internal_poi() const {
  if (target_case() == kPoi) {
    return static_cast<::rtech::liveapi::PlayerOfInterest>(_impl_.target_.poi_);
  }
  return static_cast<::rtech::liveapi::PlayerOfInterest>(0);
}
inline void ChangeCamera::_internal_set_poi(::rtech::liveapi::PlayerOfInterest value) {
  if (target_case() != kPoi) {
    clear_target();
    set_has_poi();
  }
  _impl_.target_.poi_ = value;
}

// string name = 2;
inline bool ChangeCamera::has_name() const {
  return target_case() == kName;
}
inline void ChangeCamera::set_has_name() {
  _impl_._oneof_case_[0] = kName;
}
inline void ChangeCamera::clear_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (target_case() == kName) {
    _impl_.target_.name_.Destroy();
    clear_has_target();
  }
}
inline const std::string& ChangeCamera::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rtech.liveapi.ChangeCamera.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ChangeCamera::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (target_case() != kName) {
    clear_target();

    set_has_name();
    _impl_.target_.name_.InitDefault();
  }
  _impl_.target_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:rtech.liveapi.ChangeCamera.name)
}
inline std::string* ChangeCamera::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.ChangeCamera.name)
  return _s;
}
inline const std::string& ChangeCamera::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  if (target_case() != kName) {
    return ::google::protobuf::internal::GetEmptyStringAlreadyInited();
  }
  return _impl_.target_.name_.Get();
}
inline void ChangeCamera::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (target_case() != kName) {
    clear_target();

    set_has_name();
    _impl_.target_.name_.InitDefault();
  }
  _impl_.target_.name_.Set(value, GetArena());
}
inline std::string* ChangeCamera::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (target_case() != kName) {
    clear_target();

    set_has_name();
    _impl_.target_.name_.InitDefault();
  }
  return _impl_.target_.name_.Mutable( GetArena());
}
inline std::string* ChangeCamera::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:rtech.liveapi.ChangeCamera.name)
  if (target_case() != kName) {
    return nullptr;
  }
  clear_has_target();
  return _impl_.target_.name_.Release();
}
inline void ChangeCamera::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_target()) {
    clear_target();
  }
  if (value != nullptr) {
    set_has_name();
    _impl_.target_.name_.InitAllocated(value, GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.ChangeCamera.name)
}

inline bool ChangeCamera::has_target() const {
  return target_case() != TARGET_NOT_SET;
}
inline void ChangeCamera::clear_has_target() {
  _impl_._oneof_case_[0] = TARGET_NOT_SET;
}
inline ChangeCamera::TargetCase ChangeCamera::target_case() const {
  return ChangeCamera::TargetCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// PauseToggle

// float preTimer = 1;
inline void PauseToggle::clear_pretimer() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.pretimer_ = 0;
}
inline float PauseToggle::pretimer() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.PauseToggle.preTimer)
  return _internal_pretimer();
}
inline void PauseToggle::set_pretimer(float value) {
  _internal_set_pretimer(value);
  // @@protoc_insertion_point(field_set:rtech.liveapi.PauseToggle.preTimer)
}
inline float PauseToggle::_internal_pretimer() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.pretimer_;
}
inline void PauseToggle::_internal_set_pretimer(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.pretimer_ = value;
}

// -------------------------------------------------------------------

// CustomMatch_CreateLobby

// -------------------------------------------------------------------

// CustomMatch_JoinLobby

// string roleToken = 1;
inline void CustomMatch_JoinLobby::clear_roletoken() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.roletoken_.ClearToEmpty();
}
inline const std::string& CustomMatch_JoinLobby::roletoken() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rtech.liveapi.CustomMatch_JoinLobby.roleToken)
  return _internal_roletoken();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CustomMatch_JoinLobby::set_roletoken(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.roletoken_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:rtech.liveapi.CustomMatch_JoinLobby.roleToken)
}
inline std::string* CustomMatch_JoinLobby::mutable_roletoken() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_roletoken();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.CustomMatch_JoinLobby.roleToken)
  return _s;
}
inline const std::string& CustomMatch_JoinLobby::_internal_roletoken() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.roletoken_.Get();
}
inline void CustomMatch_JoinLobby::_internal_set_roletoken(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.roletoken_.Set(value, GetArena());
}
inline std::string* CustomMatch_JoinLobby::_internal_mutable_roletoken() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.roletoken_.Mutable( GetArena());
}
inline std::string* CustomMatch_JoinLobby::release_roletoken() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:rtech.liveapi.CustomMatch_JoinLobby.roleToken)
  return _impl_.roletoken_.Release();
}
inline void CustomMatch_JoinLobby::set_allocated_roletoken(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.roletoken_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.roletoken_.IsDefault()) {
          _impl_.roletoken_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.CustomMatch_JoinLobby.roleToken)
}

// -------------------------------------------------------------------

// CustomMatch_LeaveLobby

// -------------------------------------------------------------------

// CustomMatch_SetReady

// bool isReady = 1;
inline void CustomMatch_SetReady::clear_isready() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.isready_ = false;
}
inline bool CustomMatch_SetReady::isready() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.CustomMatch_SetReady.isReady)
  return _internal_isready();
}
inline void CustomMatch_SetReady::set_isready(bool value) {
  _internal_set_isready(value);
  // @@protoc_insertion_point(field_set:rtech.liveapi.CustomMatch_SetReady.isReady)
}
inline bool CustomMatch_SetReady::_internal_isready() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.isready_;
}
inline void CustomMatch_SetReady::_internal_set_isready(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.isready_ = value;
}

// -------------------------------------------------------------------

// CustomMatch_GetLobbyPlayers

// -------------------------------------------------------------------

// CustomMatch_SetMatchmaking

// bool enabled = 1;
inline void CustomMatch_SetMatchmaking::clear_enabled() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.enabled_ = false;
}
inline bool CustomMatch_SetMatchmaking::enabled() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.CustomMatch_SetMatchmaking.enabled)
  return _internal_enabled();
}
inline void CustomMatch_SetMatchmaking::set_enabled(bool value) {
  _internal_set_enabled(value);
  // @@protoc_insertion_point(field_set:rtech.liveapi.CustomMatch_SetMatchmaking.enabled)
}
inline bool CustomMatch_SetMatchmaking::_internal_enabled() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.enabled_;
}
inline void CustomMatch_SetMatchmaking::_internal_set_enabled(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.enabled_ = value;
}

// -------------------------------------------------------------------

// CustomMatch_SetTeam

// int32 teamId = 1;
inline void CustomMatch_SetTeam::clear_teamid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.teamid_ = 0;
}
inline ::int32_t CustomMatch_SetTeam::teamid() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.CustomMatch_SetTeam.teamId)
  return _internal_teamid();
}
inline void CustomMatch_SetTeam::set_teamid(::int32_t value) {
  _internal_set_teamid(value);
  // @@protoc_insertion_point(field_set:rtech.liveapi.CustomMatch_SetTeam.teamId)
}
inline ::int32_t CustomMatch_SetTeam::_internal_teamid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.teamid_;
}
inline void CustomMatch_SetTeam::_internal_set_teamid(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.teamid_ = value;
}

// string targetHardwareName = 2;
inline void CustomMatch_SetTeam::clear_targethardwarename() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.targethardwarename_.ClearToEmpty();
}
inline const std::string& CustomMatch_SetTeam::targethardwarename() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rtech.liveapi.CustomMatch_SetTeam.targetHardwareName)
  return _internal_targethardwarename();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CustomMatch_SetTeam::set_targethardwarename(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.targethardwarename_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:rtech.liveapi.CustomMatch_SetTeam.targetHardwareName)
}
inline std::string* CustomMatch_SetTeam::mutable_targethardwarename() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_targethardwarename();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.CustomMatch_SetTeam.targetHardwareName)
  return _s;
}
inline const std::string& CustomMatch_SetTeam::_internal_targethardwarename() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.targethardwarename_.Get();
}
inline void CustomMatch_SetTeam::_internal_set_targethardwarename(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.targethardwarename_.Set(value, GetArena());
}
inline std::string* CustomMatch_SetTeam::_internal_mutable_targethardwarename() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.targethardwarename_.Mutable( GetArena());
}
inline std::string* CustomMatch_SetTeam::release_targethardwarename() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:rtech.liveapi.CustomMatch_SetTeam.targetHardwareName)
  return _impl_.targethardwarename_.Release();
}
inline void CustomMatch_SetTeam::set_allocated_targethardwarename(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.targethardwarename_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.targethardwarename_.IsDefault()) {
          _impl_.targethardwarename_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.CustomMatch_SetTeam.targetHardwareName)
}

// string targetNucleusHash = 3;
inline void CustomMatch_SetTeam::clear_targetnucleushash() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.targetnucleushash_.ClearToEmpty();
}
inline const std::string& CustomMatch_SetTeam::targetnucleushash() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rtech.liveapi.CustomMatch_SetTeam.targetNucleusHash)
  return _internal_targetnucleushash();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CustomMatch_SetTeam::set_targetnucleushash(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.targetnucleushash_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:rtech.liveapi.CustomMatch_SetTeam.targetNucleusHash)
}
inline std::string* CustomMatch_SetTeam::mutable_targetnucleushash() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_targetnucleushash();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.CustomMatch_SetTeam.targetNucleusHash)
  return _s;
}
inline const std::string& CustomMatch_SetTeam::_internal_targetnucleushash() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.targetnucleushash_.Get();
}
inline void CustomMatch_SetTeam::_internal_set_targetnucleushash(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.targetnucleushash_.Set(value, GetArena());
}
inline std::string* CustomMatch_SetTeam::_internal_mutable_targetnucleushash() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.targetnucleushash_.Mutable( GetArena());
}
inline std::string* CustomMatch_SetTeam::release_targetnucleushash() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:rtech.liveapi.CustomMatch_SetTeam.targetNucleusHash)
  return _impl_.targetnucleushash_.Release();
}
inline void CustomMatch_SetTeam::set_allocated_targetnucleushash(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.targetnucleushash_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.targetnucleushash_.IsDefault()) {
          _impl_.targetnucleushash_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.CustomMatch_SetTeam.targetNucleusHash)
}

// -------------------------------------------------------------------

// CustomMatch_KickPlayer

// string targetHardwareName = 1;
inline void CustomMatch_KickPlayer::clear_targethardwarename() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.targethardwarename_.ClearToEmpty();
}
inline const std::string& CustomMatch_KickPlayer::targethardwarename() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rtech.liveapi.CustomMatch_KickPlayer.targetHardwareName)
  return _internal_targethardwarename();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CustomMatch_KickPlayer::set_targethardwarename(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.targethardwarename_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:rtech.liveapi.CustomMatch_KickPlayer.targetHardwareName)
}
inline std::string* CustomMatch_KickPlayer::mutable_targethardwarename() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_targethardwarename();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.CustomMatch_KickPlayer.targetHardwareName)
  return _s;
}
inline const std::string& CustomMatch_KickPlayer::_internal_targethardwarename() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.targethardwarename_.Get();
}
inline void CustomMatch_KickPlayer::_internal_set_targethardwarename(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.targethardwarename_.Set(value, GetArena());
}
inline std::string* CustomMatch_KickPlayer::_internal_mutable_targethardwarename() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.targethardwarename_.Mutable( GetArena());
}
inline std::string* CustomMatch_KickPlayer::release_targethardwarename() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:rtech.liveapi.CustomMatch_KickPlayer.targetHardwareName)
  return _impl_.targethardwarename_.Release();
}
inline void CustomMatch_KickPlayer::set_allocated_targethardwarename(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.targethardwarename_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.targethardwarename_.IsDefault()) {
          _impl_.targethardwarename_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.CustomMatch_KickPlayer.targetHardwareName)
}

// string targetNucleusHash = 2;
inline void CustomMatch_KickPlayer::clear_targetnucleushash() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.targetnucleushash_.ClearToEmpty();
}
inline const std::string& CustomMatch_KickPlayer::targetnucleushash() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rtech.liveapi.CustomMatch_KickPlayer.targetNucleusHash)
  return _internal_targetnucleushash();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CustomMatch_KickPlayer::set_targetnucleushash(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.targetnucleushash_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:rtech.liveapi.CustomMatch_KickPlayer.targetNucleusHash)
}
inline std::string* CustomMatch_KickPlayer::mutable_targetnucleushash() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_targetnucleushash();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.CustomMatch_KickPlayer.targetNucleusHash)
  return _s;
}
inline const std::string& CustomMatch_KickPlayer::_internal_targetnucleushash() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.targetnucleushash_.Get();
}
inline void CustomMatch_KickPlayer::_internal_set_targetnucleushash(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.targetnucleushash_.Set(value, GetArena());
}
inline std::string* CustomMatch_KickPlayer::_internal_mutable_targetnucleushash() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.targetnucleushash_.Mutable( GetArena());
}
inline std::string* CustomMatch_KickPlayer::release_targetnucleushash() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:rtech.liveapi.CustomMatch_KickPlayer.targetNucleusHash)
  return _impl_.targetnucleushash_.Release();
}
inline void CustomMatch_KickPlayer::set_allocated_targetnucleushash(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.targetnucleushash_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.targetnucleushash_.IsDefault()) {
          _impl_.targetnucleushash_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.CustomMatch_KickPlayer.targetNucleusHash)
}

// -------------------------------------------------------------------

// CustomMatch_SetSettings

// string playlistName = 1;
inline void CustomMatch_SetSettings::clear_playlistname() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.playlistname_.ClearToEmpty();
}
inline const std::string& CustomMatch_SetSettings::playlistname() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rtech.liveapi.CustomMatch_SetSettings.playlistName)
  return _internal_playlistname();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CustomMatch_SetSettings::set_playlistname(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.playlistname_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:rtech.liveapi.CustomMatch_SetSettings.playlistName)
}
inline std::string* CustomMatch_SetSettings::mutable_playlistname() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_playlistname();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.CustomMatch_SetSettings.playlistName)
  return _s;
}
inline const std::string& CustomMatch_SetSettings::_internal_playlistname() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.playlistname_.Get();
}
inline void CustomMatch_SetSettings::_internal_set_playlistname(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.playlistname_.Set(value, GetArena());
}
inline std::string* CustomMatch_SetSettings::_internal_mutable_playlistname() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.playlistname_.Mutable( GetArena());
}
inline std::string* CustomMatch_SetSettings::release_playlistname() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:rtech.liveapi.CustomMatch_SetSettings.playlistName)
  return _impl_.playlistname_.Release();
}
inline void CustomMatch_SetSettings::set_allocated_playlistname(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.playlistname_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.playlistname_.IsDefault()) {
          _impl_.playlistname_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.CustomMatch_SetSettings.playlistName)
}

// bool adminChat = 2;
inline void CustomMatch_SetSettings::clear_adminchat() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.adminchat_ = false;
}
inline bool CustomMatch_SetSettings::adminchat() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.CustomMatch_SetSettings.adminChat)
  return _internal_adminchat();
}
inline void CustomMatch_SetSettings::set_adminchat(bool value) {
  _internal_set_adminchat(value);
  // @@protoc_insertion_point(field_set:rtech.liveapi.CustomMatch_SetSettings.adminChat)
}
inline bool CustomMatch_SetSettings::_internal_adminchat() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.adminchat_;
}
inline void CustomMatch_SetSettings::_internal_set_adminchat(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.adminchat_ = value;
}

// bool teamRename = 3;
inline void CustomMatch_SetSettings::clear_teamrename() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.teamrename_ = false;
}
inline bool CustomMatch_SetSettings::teamrename() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.CustomMatch_SetSettings.teamRename)
  return _internal_teamrename();
}
inline void CustomMatch_SetSettings::set_teamrename(bool value) {
  _internal_set_teamrename(value);
  // @@protoc_insertion_point(field_set:rtech.liveapi.CustomMatch_SetSettings.teamRename)
}
inline bool CustomMatch_SetSettings::_internal_teamrename() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.teamrename_;
}
inline void CustomMatch_SetSettings::_internal_set_teamrename(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.teamrename_ = value;
}

// bool selfAssign = 4;
inline void CustomMatch_SetSettings::clear_selfassign() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.selfassign_ = false;
}
inline bool CustomMatch_SetSettings::selfassign() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.CustomMatch_SetSettings.selfAssign)
  return _internal_selfassign();
}
inline void CustomMatch_SetSettings::set_selfassign(bool value) {
  _internal_set_selfassign(value);
  // @@protoc_insertion_point(field_set:rtech.liveapi.CustomMatch_SetSettings.selfAssign)
}
inline bool CustomMatch_SetSettings::_internal_selfassign() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.selfassign_;
}
inline void CustomMatch_SetSettings::_internal_set_selfassign(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.selfassign_ = value;
}

// bool aimAssist = 5;
inline void CustomMatch_SetSettings::clear_aimassist() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.aimassist_ = false;
}
inline bool CustomMatch_SetSettings::aimassist() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.CustomMatch_SetSettings.aimAssist)
  return _internal_aimassist();
}
inline void CustomMatch_SetSettings::set_aimassist(bool value) {
  _internal_set_aimassist(value);
  // @@protoc_insertion_point(field_set:rtech.liveapi.CustomMatch_SetSettings.aimAssist)
}
inline bool CustomMatch_SetSettings::_internal_aimassist() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.aimassist_;
}
inline void CustomMatch_SetSettings::_internal_set_aimassist(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.aimassist_ = value;
}

// bool anonMode = 6;
inline void CustomMatch_SetSettings::clear_anonmode() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.anonmode_ = false;
}
inline bool CustomMatch_SetSettings::anonmode() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.CustomMatch_SetSettings.anonMode)
  return _internal_anonmode();
}
inline void CustomMatch_SetSettings::set_anonmode(bool value) {
  _internal_set_anonmode(value);
  // @@protoc_insertion_point(field_set:rtech.liveapi.CustomMatch_SetSettings.anonMode)
}
inline bool CustomMatch_SetSettings::_internal_anonmode() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.anonmode_;
}
inline void CustomMatch_SetSettings::_internal_set_anonmode(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.anonmode_ = value;
}

// -------------------------------------------------------------------

// CustomMatch_GetSettings

// -------------------------------------------------------------------

// CustomMatch_SetTeamName

// int32 teamId = 1;
inline void CustomMatch_SetTeamName::clear_teamid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.teamid_ = 0;
}
inline ::int32_t CustomMatch_SetTeamName::teamid() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.CustomMatch_SetTeamName.teamId)
  return _internal_teamid();
}
inline void CustomMatch_SetTeamName::set_teamid(::int32_t value) {
  _internal_set_teamid(value);
  // @@protoc_insertion_point(field_set:rtech.liveapi.CustomMatch_SetTeamName.teamId)
}
inline ::int32_t CustomMatch_SetTeamName::_internal_teamid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.teamid_;
}
inline void CustomMatch_SetTeamName::_internal_set_teamid(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.teamid_ = value;
}

// string teamName = 2;
inline void CustomMatch_SetTeamName::clear_teamname() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.teamname_.ClearToEmpty();
}
inline const std::string& CustomMatch_SetTeamName::teamname() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rtech.liveapi.CustomMatch_SetTeamName.teamName)
  return _internal_teamname();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CustomMatch_SetTeamName::set_teamname(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.teamname_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:rtech.liveapi.CustomMatch_SetTeamName.teamName)
}
inline std::string* CustomMatch_SetTeamName::mutable_teamname() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_teamname();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.CustomMatch_SetTeamName.teamName)
  return _s;
}
inline const std::string& CustomMatch_SetTeamName::_internal_teamname() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.teamname_.Get();
}
inline void CustomMatch_SetTeamName::_internal_set_teamname(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.teamname_.Set(value, GetArena());
}
inline std::string* CustomMatch_SetTeamName::_internal_mutable_teamname() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.teamname_.Mutable( GetArena());
}
inline std::string* CustomMatch_SetTeamName::release_teamname() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:rtech.liveapi.CustomMatch_SetTeamName.teamName)
  return _impl_.teamname_.Release();
}
inline void CustomMatch_SetTeamName::set_allocated_teamname(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.teamname_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.teamname_.IsDefault()) {
          _impl_.teamname_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.CustomMatch_SetTeamName.teamName)
}

// -------------------------------------------------------------------

// CustomMatch_SendChat

// string text = 1;
inline void CustomMatch_SendChat::clear_text() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.text_.ClearToEmpty();
}
inline const std::string& CustomMatch_SendChat::text() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rtech.liveapi.CustomMatch_SendChat.text)
  return _internal_text();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CustomMatch_SendChat::set_text(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.text_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:rtech.liveapi.CustomMatch_SendChat.text)
}
inline std::string* CustomMatch_SendChat::mutable_text() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_text();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.CustomMatch_SendChat.text)
  return _s;
}
inline const std::string& CustomMatch_SendChat::_internal_text() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.text_.Get();
}
inline void CustomMatch_SendChat::_internal_set_text(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.text_.Set(value, GetArena());
}
inline std::string* CustomMatch_SendChat::_internal_mutable_text() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.text_.Mutable( GetArena());
}
inline std::string* CustomMatch_SendChat::release_text() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:rtech.liveapi.CustomMatch_SendChat.text)
  return _impl_.text_.Release();
}
inline void CustomMatch_SendChat::set_allocated_text(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.text_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.text_.IsDefault()) {
          _impl_.text_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.CustomMatch_SendChat.text)
}

// -------------------------------------------------------------------

// Request

// bool withAck = 1;
inline void Request::clear_withack() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.withack_ = false;
}
inline bool Request::withack() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.Request.withAck)
  return _internal_withack();
}
inline void Request::set_withack(bool value) {
  _internal_set_withack(value);
  // @@protoc_insertion_point(field_set:rtech.liveapi.Request.withAck)
}
inline bool Request::_internal_withack() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.withack_;
}
inline void Request::_internal_set_withack(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.withack_ = value;
}

// string preSharedKey = 2;
inline void Request::clear_presharedkey() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.presharedkey_.ClearToEmpty();
}
inline const std::string& Request::presharedkey() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rtech.liveapi.Request.preSharedKey)
  return _internal_presharedkey();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Request::set_presharedkey(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.presharedkey_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:rtech.liveapi.Request.preSharedKey)
}
inline std::string* Request::mutable_presharedkey() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_presharedkey();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.Request.preSharedKey)
  return _s;
}
inline const std::string& Request::_internal_presharedkey() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.presharedkey_.Get();
}
inline void Request::_internal_set_presharedkey(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.presharedkey_.Set(value, GetArena());
}
inline std::string* Request::_internal_mutable_presharedkey() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.presharedkey_.Mutable( GetArena());
}
inline std::string* Request::release_presharedkey() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:rtech.liveapi.Request.preSharedKey)
  return _impl_.presharedkey_.Release();
}
inline void Request::set_allocated_presharedkey(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.presharedkey_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.presharedkey_.IsDefault()) {
          _impl_.presharedkey_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.Request.preSharedKey)
}

// .rtech.liveapi.ChangeCamera changeCam = 4;
inline bool Request::has_changecam() const {
  return actions_case() == kChangeCam;
}
inline bool Request::_internal_has_changecam() const {
  return actions_case() == kChangeCam;
}
inline void Request::set_has_changecam() {
  _impl_._oneof_case_[0] = kChangeCam;
}
inline void Request::clear_changecam() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (actions_case() == kChangeCam) {
    if (GetArena() == nullptr) {
      delete _impl_.actions_.changecam_;
    }
    clear_has_actions();
  }
}
inline ::rtech::liveapi::ChangeCamera* Request::release_changecam() {
  // @@protoc_insertion_point(field_release:rtech.liveapi.Request.changeCam)
  if (actions_case() == kChangeCam) {
    clear_has_actions();
    auto* temp = _impl_.actions_.changecam_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.actions_.changecam_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::rtech::liveapi::ChangeCamera& Request::_internal_changecam() const {
  return actions_case() == kChangeCam ? *_impl_.actions_.changecam_ : reinterpret_cast<::rtech::liveapi::ChangeCamera&>(::rtech::liveapi::_ChangeCamera_default_instance_);
}
inline const ::rtech::liveapi::ChangeCamera& Request::changecam() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rtech.liveapi.Request.changeCam)
  return _internal_changecam();
}
inline ::rtech::liveapi::ChangeCamera* Request::unsafe_arena_release_changecam() {
  // @@protoc_insertion_point(field_unsafe_arena_release:rtech.liveapi.Request.changeCam)
  if (actions_case() == kChangeCam) {
    clear_has_actions();
    auto* temp = _impl_.actions_.changecam_;
    _impl_.actions_.changecam_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Request::unsafe_arena_set_allocated_changecam(::rtech::liveapi::ChangeCamera* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_actions();
  if (value) {
    set_has_changecam();
    _impl_.actions_.changecam_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rtech.liveapi.Request.changeCam)
}
inline ::rtech::liveapi::ChangeCamera* Request::_internal_mutable_changecam() {
  if (actions_case() != kChangeCam) {
    clear_actions();
    set_has_changecam();
    _impl_.actions_.changecam_ = CreateMaybeMessage<::rtech::liveapi::ChangeCamera>(GetArena());
  }
  return _impl_.actions_.changecam_;
}
inline ::rtech::liveapi::ChangeCamera* Request::mutable_changecam() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::rtech::liveapi::ChangeCamera* _msg = _internal_mutable_changecam();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.Request.changeCam)
  return _msg;
}

// .rtech.liveapi.PauseToggle pauseToggle = 5;
inline bool Request::has_pausetoggle() const {
  return actions_case() == kPauseToggle;
}
inline bool Request::_internal_has_pausetoggle() const {
  return actions_case() == kPauseToggle;
}
inline void Request::set_has_pausetoggle() {
  _impl_._oneof_case_[0] = kPauseToggle;
}
inline void Request::clear_pausetoggle() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (actions_case() == kPauseToggle) {
    if (GetArena() == nullptr) {
      delete _impl_.actions_.pausetoggle_;
    }
    clear_has_actions();
  }
}
inline ::rtech::liveapi::PauseToggle* Request::release_pausetoggle() {
  // @@protoc_insertion_point(field_release:rtech.liveapi.Request.pauseToggle)
  if (actions_case() == kPauseToggle) {
    clear_has_actions();
    auto* temp = _impl_.actions_.pausetoggle_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.actions_.pausetoggle_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::rtech::liveapi::PauseToggle& Request::_internal_pausetoggle() const {
  return actions_case() == kPauseToggle ? *_impl_.actions_.pausetoggle_ : reinterpret_cast<::rtech::liveapi::PauseToggle&>(::rtech::liveapi::_PauseToggle_default_instance_);
}
inline const ::rtech::liveapi::PauseToggle& Request::pausetoggle() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rtech.liveapi.Request.pauseToggle)
  return _internal_pausetoggle();
}
inline ::rtech::liveapi::PauseToggle* Request::unsafe_arena_release_pausetoggle() {
  // @@protoc_insertion_point(field_unsafe_arena_release:rtech.liveapi.Request.pauseToggle)
  if (actions_case() == kPauseToggle) {
    clear_has_actions();
    auto* temp = _impl_.actions_.pausetoggle_;
    _impl_.actions_.pausetoggle_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Request::unsafe_arena_set_allocated_pausetoggle(::rtech::liveapi::PauseToggle* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_actions();
  if (value) {
    set_has_pausetoggle();
    _impl_.actions_.pausetoggle_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rtech.liveapi.Request.pauseToggle)
}
inline ::rtech::liveapi::PauseToggle* Request::_internal_mutable_pausetoggle() {
  if (actions_case() != kPauseToggle) {
    clear_actions();
    set_has_pausetoggle();
    _impl_.actions_.pausetoggle_ = CreateMaybeMessage<::rtech::liveapi::PauseToggle>(GetArena());
  }
  return _impl_.actions_.pausetoggle_;
}
inline ::rtech::liveapi::PauseToggle* Request::mutable_pausetoggle() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::rtech::liveapi::PauseToggle* _msg = _internal_mutable_pausetoggle();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.Request.pauseToggle)
  return _msg;
}

// .rtech.liveapi.CustomMatch_CreateLobby customMatch_CreateLobby = 10;
inline bool Request::has_custommatch_createlobby() const {
  return actions_case() == kCustomMatchCreateLobby;
}
inline bool Request::_internal_has_custommatch_createlobby() const {
  return actions_case() == kCustomMatchCreateLobby;
}
inline void Request::set_has_custommatch_createlobby() {
  _impl_._oneof_case_[0] = kCustomMatchCreateLobby;
}
inline void Request::clear_custommatch_createlobby() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (actions_case() == kCustomMatchCreateLobby) {
    if (GetArena() == nullptr) {
      delete _impl_.actions_.custommatch_createlobby_;
    }
    clear_has_actions();
  }
}
inline ::rtech::liveapi::CustomMatch_CreateLobby* Request::release_custommatch_createlobby() {
  // @@protoc_insertion_point(field_release:rtech.liveapi.Request.customMatch_CreateLobby)
  if (actions_case() == kCustomMatchCreateLobby) {
    clear_has_actions();
    auto* temp = _impl_.actions_.custommatch_createlobby_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.actions_.custommatch_createlobby_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::rtech::liveapi::CustomMatch_CreateLobby& Request::_internal_custommatch_createlobby() const {
  return actions_case() == kCustomMatchCreateLobby ? *_impl_.actions_.custommatch_createlobby_ : reinterpret_cast<::rtech::liveapi::CustomMatch_CreateLobby&>(::rtech::liveapi::_CustomMatch_CreateLobby_default_instance_);
}
inline const ::rtech::liveapi::CustomMatch_CreateLobby& Request::custommatch_createlobby() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rtech.liveapi.Request.customMatch_CreateLobby)
  return _internal_custommatch_createlobby();
}
inline ::rtech::liveapi::CustomMatch_CreateLobby* Request::unsafe_arena_release_custommatch_createlobby() {
  // @@protoc_insertion_point(field_unsafe_arena_release:rtech.liveapi.Request.customMatch_CreateLobby)
  if (actions_case() == kCustomMatchCreateLobby) {
    clear_has_actions();
    auto* temp = _impl_.actions_.custommatch_createlobby_;
    _impl_.actions_.custommatch_createlobby_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Request::unsafe_arena_set_allocated_custommatch_createlobby(::rtech::liveapi::CustomMatch_CreateLobby* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_actions();
  if (value) {
    set_has_custommatch_createlobby();
    _impl_.actions_.custommatch_createlobby_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rtech.liveapi.Request.customMatch_CreateLobby)
}
inline ::rtech::liveapi::CustomMatch_CreateLobby* Request::_internal_mutable_custommatch_createlobby() {
  if (actions_case() != kCustomMatchCreateLobby) {
    clear_actions();
    set_has_custommatch_createlobby();
    _impl_.actions_.custommatch_createlobby_ = CreateMaybeMessage<::rtech::liveapi::CustomMatch_CreateLobby>(GetArena());
  }
  return _impl_.actions_.custommatch_createlobby_;
}
inline ::rtech::liveapi::CustomMatch_CreateLobby* Request::mutable_custommatch_createlobby() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::rtech::liveapi::CustomMatch_CreateLobby* _msg = _internal_mutable_custommatch_createlobby();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.Request.customMatch_CreateLobby)
  return _msg;
}

// .rtech.liveapi.CustomMatch_JoinLobby customMatch_JoinLobby = 11;
inline bool Request::has_custommatch_joinlobby() const {
  return actions_case() == kCustomMatchJoinLobby;
}
inline bool Request::_internal_has_custommatch_joinlobby() const {
  return actions_case() == kCustomMatchJoinLobby;
}
inline void Request::set_has_custommatch_joinlobby() {
  _impl_._oneof_case_[0] = kCustomMatchJoinLobby;
}
inline void Request::clear_custommatch_joinlobby() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (actions_case() == kCustomMatchJoinLobby) {
    if (GetArena() == nullptr) {
      delete _impl_.actions_.custommatch_joinlobby_;
    }
    clear_has_actions();
  }
}
inline ::rtech::liveapi::CustomMatch_JoinLobby* Request::release_custommatch_joinlobby() {
  // @@protoc_insertion_point(field_release:rtech.liveapi.Request.customMatch_JoinLobby)
  if (actions_case() == kCustomMatchJoinLobby) {
    clear_has_actions();
    auto* temp = _impl_.actions_.custommatch_joinlobby_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.actions_.custommatch_joinlobby_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::rtech::liveapi::CustomMatch_JoinLobby& Request::_internal_custommatch_joinlobby() const {
  return actions_case() == kCustomMatchJoinLobby ? *_impl_.actions_.custommatch_joinlobby_ : reinterpret_cast<::rtech::liveapi::CustomMatch_JoinLobby&>(::rtech::liveapi::_CustomMatch_JoinLobby_default_instance_);
}
inline const ::rtech::liveapi::CustomMatch_JoinLobby& Request::custommatch_joinlobby() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rtech.liveapi.Request.customMatch_JoinLobby)
  return _internal_custommatch_joinlobby();
}
inline ::rtech::liveapi::CustomMatch_JoinLobby* Request::unsafe_arena_release_custommatch_joinlobby() {
  // @@protoc_insertion_point(field_unsafe_arena_release:rtech.liveapi.Request.customMatch_JoinLobby)
  if (actions_case() == kCustomMatchJoinLobby) {
    clear_has_actions();
    auto* temp = _impl_.actions_.custommatch_joinlobby_;
    _impl_.actions_.custommatch_joinlobby_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Request::unsafe_arena_set_allocated_custommatch_joinlobby(::rtech::liveapi::CustomMatch_JoinLobby* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_actions();
  if (value) {
    set_has_custommatch_joinlobby();
    _impl_.actions_.custommatch_joinlobby_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rtech.liveapi.Request.customMatch_JoinLobby)
}
inline ::rtech::liveapi::CustomMatch_JoinLobby* Request::_internal_mutable_custommatch_joinlobby() {
  if (actions_case() != kCustomMatchJoinLobby) {
    clear_actions();
    set_has_custommatch_joinlobby();
    _impl_.actions_.custommatch_joinlobby_ = CreateMaybeMessage<::rtech::liveapi::CustomMatch_JoinLobby>(GetArena());
  }
  return _impl_.actions_.custommatch_joinlobby_;
}
inline ::rtech::liveapi::CustomMatch_JoinLobby* Request::mutable_custommatch_joinlobby() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::rtech::liveapi::CustomMatch_JoinLobby* _msg = _internal_mutable_custommatch_joinlobby();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.Request.customMatch_JoinLobby)
  return _msg;
}

// .rtech.liveapi.CustomMatch_LeaveLobby customMatch_LeaveLobby = 12;
inline bool Request::has_custommatch_leavelobby() const {
  return actions_case() == kCustomMatchLeaveLobby;
}
inline bool Request::_internal_has_custommatch_leavelobby() const {
  return actions_case() == kCustomMatchLeaveLobby;
}
inline void Request::set_has_custommatch_leavelobby() {
  _impl_._oneof_case_[0] = kCustomMatchLeaveLobby;
}
inline void Request::clear_custommatch_leavelobby() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (actions_case() == kCustomMatchLeaveLobby) {
    if (GetArena() == nullptr) {
      delete _impl_.actions_.custommatch_leavelobby_;
    }
    clear_has_actions();
  }
}
inline ::rtech::liveapi::CustomMatch_LeaveLobby* Request::release_custommatch_leavelobby() {
  // @@protoc_insertion_point(field_release:rtech.liveapi.Request.customMatch_LeaveLobby)
  if (actions_case() == kCustomMatchLeaveLobby) {
    clear_has_actions();
    auto* temp = _impl_.actions_.custommatch_leavelobby_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.actions_.custommatch_leavelobby_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::rtech::liveapi::CustomMatch_LeaveLobby& Request::_internal_custommatch_leavelobby() const {
  return actions_case() == kCustomMatchLeaveLobby ? *_impl_.actions_.custommatch_leavelobby_ : reinterpret_cast<::rtech::liveapi::CustomMatch_LeaveLobby&>(::rtech::liveapi::_CustomMatch_LeaveLobby_default_instance_);
}
inline const ::rtech::liveapi::CustomMatch_LeaveLobby& Request::custommatch_leavelobby() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rtech.liveapi.Request.customMatch_LeaveLobby)
  return _internal_custommatch_leavelobby();
}
inline ::rtech::liveapi::CustomMatch_LeaveLobby* Request::unsafe_arena_release_custommatch_leavelobby() {
  // @@protoc_insertion_point(field_unsafe_arena_release:rtech.liveapi.Request.customMatch_LeaveLobby)
  if (actions_case() == kCustomMatchLeaveLobby) {
    clear_has_actions();
    auto* temp = _impl_.actions_.custommatch_leavelobby_;
    _impl_.actions_.custommatch_leavelobby_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Request::unsafe_arena_set_allocated_custommatch_leavelobby(::rtech::liveapi::CustomMatch_LeaveLobby* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_actions();
  if (value) {
    set_has_custommatch_leavelobby();
    _impl_.actions_.custommatch_leavelobby_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rtech.liveapi.Request.customMatch_LeaveLobby)
}
inline ::rtech::liveapi::CustomMatch_LeaveLobby* Request::_internal_mutable_custommatch_leavelobby() {
  if (actions_case() != kCustomMatchLeaveLobby) {
    clear_actions();
    set_has_custommatch_leavelobby();
    _impl_.actions_.custommatch_leavelobby_ = CreateMaybeMessage<::rtech::liveapi::CustomMatch_LeaveLobby>(GetArena());
  }
  return _impl_.actions_.custommatch_leavelobby_;
}
inline ::rtech::liveapi::CustomMatch_LeaveLobby* Request::mutable_custommatch_leavelobby() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::rtech::liveapi::CustomMatch_LeaveLobby* _msg = _internal_mutable_custommatch_leavelobby();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.Request.customMatch_LeaveLobby)
  return _msg;
}

// .rtech.liveapi.CustomMatch_SetReady customMatch_SetReady = 13;
inline bool Request::has_custommatch_setready() const {
  return actions_case() == kCustomMatchSetReady;
}
inline bool Request::_internal_has_custommatch_setready() const {
  return actions_case() == kCustomMatchSetReady;
}
inline void Request::set_has_custommatch_setready() {
  _impl_._oneof_case_[0] = kCustomMatchSetReady;
}
inline void Request::clear_custommatch_setready() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (actions_case() == kCustomMatchSetReady) {
    if (GetArena() == nullptr) {
      delete _impl_.actions_.custommatch_setready_;
    }
    clear_has_actions();
  }
}
inline ::rtech::liveapi::CustomMatch_SetReady* Request::release_custommatch_setready() {
  // @@protoc_insertion_point(field_release:rtech.liveapi.Request.customMatch_SetReady)
  if (actions_case() == kCustomMatchSetReady) {
    clear_has_actions();
    auto* temp = _impl_.actions_.custommatch_setready_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.actions_.custommatch_setready_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::rtech::liveapi::CustomMatch_SetReady& Request::_internal_custommatch_setready() const {
  return actions_case() == kCustomMatchSetReady ? *_impl_.actions_.custommatch_setready_ : reinterpret_cast<::rtech::liveapi::CustomMatch_SetReady&>(::rtech::liveapi::_CustomMatch_SetReady_default_instance_);
}
inline const ::rtech::liveapi::CustomMatch_SetReady& Request::custommatch_setready() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rtech.liveapi.Request.customMatch_SetReady)
  return _internal_custommatch_setready();
}
inline ::rtech::liveapi::CustomMatch_SetReady* Request::unsafe_arena_release_custommatch_setready() {
  // @@protoc_insertion_point(field_unsafe_arena_release:rtech.liveapi.Request.customMatch_SetReady)
  if (actions_case() == kCustomMatchSetReady) {
    clear_has_actions();
    auto* temp = _impl_.actions_.custommatch_setready_;
    _impl_.actions_.custommatch_setready_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Request::unsafe_arena_set_allocated_custommatch_setready(::rtech::liveapi::CustomMatch_SetReady* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_actions();
  if (value) {
    set_has_custommatch_setready();
    _impl_.actions_.custommatch_setready_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rtech.liveapi.Request.customMatch_SetReady)
}
inline ::rtech::liveapi::CustomMatch_SetReady* Request::_internal_mutable_custommatch_setready() {
  if (actions_case() != kCustomMatchSetReady) {
    clear_actions();
    set_has_custommatch_setready();
    _impl_.actions_.custommatch_setready_ = CreateMaybeMessage<::rtech::liveapi::CustomMatch_SetReady>(GetArena());
  }
  return _impl_.actions_.custommatch_setready_;
}
inline ::rtech::liveapi::CustomMatch_SetReady* Request::mutable_custommatch_setready() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::rtech::liveapi::CustomMatch_SetReady* _msg = _internal_mutable_custommatch_setready();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.Request.customMatch_SetReady)
  return _msg;
}

// .rtech.liveapi.CustomMatch_SetMatchmaking customMatch_SetMatchmaking = 14;
inline bool Request::has_custommatch_setmatchmaking() const {
  return actions_case() == kCustomMatchSetMatchmaking;
}
inline bool Request::_internal_has_custommatch_setmatchmaking() const {
  return actions_case() == kCustomMatchSetMatchmaking;
}
inline void Request::set_has_custommatch_setmatchmaking() {
  _impl_._oneof_case_[0] = kCustomMatchSetMatchmaking;
}
inline void Request::clear_custommatch_setmatchmaking() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (actions_case() == kCustomMatchSetMatchmaking) {
    if (GetArena() == nullptr) {
      delete _impl_.actions_.custommatch_setmatchmaking_;
    }
    clear_has_actions();
  }
}
inline ::rtech::liveapi::CustomMatch_SetMatchmaking* Request::release_custommatch_setmatchmaking() {
  // @@protoc_insertion_point(field_release:rtech.liveapi.Request.customMatch_SetMatchmaking)
  if (actions_case() == kCustomMatchSetMatchmaking) {
    clear_has_actions();
    auto* temp = _impl_.actions_.custommatch_setmatchmaking_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.actions_.custommatch_setmatchmaking_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::rtech::liveapi::CustomMatch_SetMatchmaking& Request::_internal_custommatch_setmatchmaking() const {
  return actions_case() == kCustomMatchSetMatchmaking ? *_impl_.actions_.custommatch_setmatchmaking_ : reinterpret_cast<::rtech::liveapi::CustomMatch_SetMatchmaking&>(::rtech::liveapi::_CustomMatch_SetMatchmaking_default_instance_);
}
inline const ::rtech::liveapi::CustomMatch_SetMatchmaking& Request::custommatch_setmatchmaking() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rtech.liveapi.Request.customMatch_SetMatchmaking)
  return _internal_custommatch_setmatchmaking();
}
inline ::rtech::liveapi::CustomMatch_SetMatchmaking* Request::unsafe_arena_release_custommatch_setmatchmaking() {
  // @@protoc_insertion_point(field_unsafe_arena_release:rtech.liveapi.Request.customMatch_SetMatchmaking)
  if (actions_case() == kCustomMatchSetMatchmaking) {
    clear_has_actions();
    auto* temp = _impl_.actions_.custommatch_setmatchmaking_;
    _impl_.actions_.custommatch_setmatchmaking_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Request::unsafe_arena_set_allocated_custommatch_setmatchmaking(::rtech::liveapi::CustomMatch_SetMatchmaking* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_actions();
  if (value) {
    set_has_custommatch_setmatchmaking();
    _impl_.actions_.custommatch_setmatchmaking_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rtech.liveapi.Request.customMatch_SetMatchmaking)
}
inline ::rtech::liveapi::CustomMatch_SetMatchmaking* Request::_internal_mutable_custommatch_setmatchmaking() {
  if (actions_case() != kCustomMatchSetMatchmaking) {
    clear_actions();
    set_has_custommatch_setmatchmaking();
    _impl_.actions_.custommatch_setmatchmaking_ = CreateMaybeMessage<::rtech::liveapi::CustomMatch_SetMatchmaking>(GetArena());
  }
  return _impl_.actions_.custommatch_setmatchmaking_;
}
inline ::rtech::liveapi::CustomMatch_SetMatchmaking* Request::mutable_custommatch_setmatchmaking() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::rtech::liveapi::CustomMatch_SetMatchmaking* _msg = _internal_mutable_custommatch_setmatchmaking();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.Request.customMatch_SetMatchmaking)
  return _msg;
}

// .rtech.liveapi.CustomMatch_SetTeam customMatch_SetTeam = 15;
inline bool Request::has_custommatch_setteam() const {
  return actions_case() == kCustomMatchSetTeam;
}
inline bool Request::_internal_has_custommatch_setteam() const {
  return actions_case() == kCustomMatchSetTeam;
}
inline void Request::set_has_custommatch_setteam() {
  _impl_._oneof_case_[0] = kCustomMatchSetTeam;
}
inline void Request::clear_custommatch_setteam() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (actions_case() == kCustomMatchSetTeam) {
    if (GetArena() == nullptr) {
      delete _impl_.actions_.custommatch_setteam_;
    }
    clear_has_actions();
  }
}
inline ::rtech::liveapi::CustomMatch_SetTeam* Request::release_custommatch_setteam() {
  // @@protoc_insertion_point(field_release:rtech.liveapi.Request.customMatch_SetTeam)
  if (actions_case() == kCustomMatchSetTeam) {
    clear_has_actions();
    auto* temp = _impl_.actions_.custommatch_setteam_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.actions_.custommatch_setteam_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::rtech::liveapi::CustomMatch_SetTeam& Request::_internal_custommatch_setteam() const {
  return actions_case() == kCustomMatchSetTeam ? *_impl_.actions_.custommatch_setteam_ : reinterpret_cast<::rtech::liveapi::CustomMatch_SetTeam&>(::rtech::liveapi::_CustomMatch_SetTeam_default_instance_);
}
inline const ::rtech::liveapi::CustomMatch_SetTeam& Request::custommatch_setteam() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rtech.liveapi.Request.customMatch_SetTeam)
  return _internal_custommatch_setteam();
}
inline ::rtech::liveapi::CustomMatch_SetTeam* Request::unsafe_arena_release_custommatch_setteam() {
  // @@protoc_insertion_point(field_unsafe_arena_release:rtech.liveapi.Request.customMatch_SetTeam)
  if (actions_case() == kCustomMatchSetTeam) {
    clear_has_actions();
    auto* temp = _impl_.actions_.custommatch_setteam_;
    _impl_.actions_.custommatch_setteam_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Request::unsafe_arena_set_allocated_custommatch_setteam(::rtech::liveapi::CustomMatch_SetTeam* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_actions();
  if (value) {
    set_has_custommatch_setteam();
    _impl_.actions_.custommatch_setteam_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rtech.liveapi.Request.customMatch_SetTeam)
}
inline ::rtech::liveapi::CustomMatch_SetTeam* Request::_internal_mutable_custommatch_setteam() {
  if (actions_case() != kCustomMatchSetTeam) {
    clear_actions();
    set_has_custommatch_setteam();
    _impl_.actions_.custommatch_setteam_ = CreateMaybeMessage<::rtech::liveapi::CustomMatch_SetTeam>(GetArena());
  }
  return _impl_.actions_.custommatch_setteam_;
}
inline ::rtech::liveapi::CustomMatch_SetTeam* Request::mutable_custommatch_setteam() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::rtech::liveapi::CustomMatch_SetTeam* _msg = _internal_mutable_custommatch_setteam();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.Request.customMatch_SetTeam)
  return _msg;
}

// .rtech.liveapi.CustomMatch_KickPlayer customMatch_KickPlayer = 16;
inline bool Request::has_custommatch_kickplayer() const {
  return actions_case() == kCustomMatchKickPlayer;
}
inline bool Request::_internal_has_custommatch_kickplayer() const {
  return actions_case() == kCustomMatchKickPlayer;
}
inline void Request::set_has_custommatch_kickplayer() {
  _impl_._oneof_case_[0] = kCustomMatchKickPlayer;
}
inline void Request::clear_custommatch_kickplayer() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (actions_case() == kCustomMatchKickPlayer) {
    if (GetArena() == nullptr) {
      delete _impl_.actions_.custommatch_kickplayer_;
    }
    clear_has_actions();
  }
}
inline ::rtech::liveapi::CustomMatch_KickPlayer* Request::release_custommatch_kickplayer() {
  // @@protoc_insertion_point(field_release:rtech.liveapi.Request.customMatch_KickPlayer)
  if (actions_case() == kCustomMatchKickPlayer) {
    clear_has_actions();
    auto* temp = _impl_.actions_.custommatch_kickplayer_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.actions_.custommatch_kickplayer_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::rtech::liveapi::CustomMatch_KickPlayer& Request::_internal_custommatch_kickplayer() const {
  return actions_case() == kCustomMatchKickPlayer ? *_impl_.actions_.custommatch_kickplayer_ : reinterpret_cast<::rtech::liveapi::CustomMatch_KickPlayer&>(::rtech::liveapi::_CustomMatch_KickPlayer_default_instance_);
}
inline const ::rtech::liveapi::CustomMatch_KickPlayer& Request::custommatch_kickplayer() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rtech.liveapi.Request.customMatch_KickPlayer)
  return _internal_custommatch_kickplayer();
}
inline ::rtech::liveapi::CustomMatch_KickPlayer* Request::unsafe_arena_release_custommatch_kickplayer() {
  // @@protoc_insertion_point(field_unsafe_arena_release:rtech.liveapi.Request.customMatch_KickPlayer)
  if (actions_case() == kCustomMatchKickPlayer) {
    clear_has_actions();
    auto* temp = _impl_.actions_.custommatch_kickplayer_;
    _impl_.actions_.custommatch_kickplayer_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Request::unsafe_arena_set_allocated_custommatch_kickplayer(::rtech::liveapi::CustomMatch_KickPlayer* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_actions();
  if (value) {
    set_has_custommatch_kickplayer();
    _impl_.actions_.custommatch_kickplayer_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rtech.liveapi.Request.customMatch_KickPlayer)
}
inline ::rtech::liveapi::CustomMatch_KickPlayer* Request::_internal_mutable_custommatch_kickplayer() {
  if (actions_case() != kCustomMatchKickPlayer) {
    clear_actions();
    set_has_custommatch_kickplayer();
    _impl_.actions_.custommatch_kickplayer_ = CreateMaybeMessage<::rtech::liveapi::CustomMatch_KickPlayer>(GetArena());
  }
  return _impl_.actions_.custommatch_kickplayer_;
}
inline ::rtech::liveapi::CustomMatch_KickPlayer* Request::mutable_custommatch_kickplayer() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::rtech::liveapi::CustomMatch_KickPlayer* _msg = _internal_mutable_custommatch_kickplayer();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.Request.customMatch_KickPlayer)
  return _msg;
}

// .rtech.liveapi.CustomMatch_SetSettings customMatch_SetSettings = 17;
inline bool Request::has_custommatch_setsettings() const {
  return actions_case() == kCustomMatchSetSettings;
}
inline bool Request::_internal_has_custommatch_setsettings() const {
  return actions_case() == kCustomMatchSetSettings;
}
inline void Request::set_has_custommatch_setsettings() {
  _impl_._oneof_case_[0] = kCustomMatchSetSettings;
}
inline void Request::clear_custommatch_setsettings() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (actions_case() == kCustomMatchSetSettings) {
    if (GetArena() == nullptr) {
      delete _impl_.actions_.custommatch_setsettings_;
    }
    clear_has_actions();
  }
}
inline ::rtech::liveapi::CustomMatch_SetSettings* Request::release_custommatch_setsettings() {
  // @@protoc_insertion_point(field_release:rtech.liveapi.Request.customMatch_SetSettings)
  if (actions_case() == kCustomMatchSetSettings) {
    clear_has_actions();
    auto* temp = _impl_.actions_.custommatch_setsettings_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.actions_.custommatch_setsettings_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::rtech::liveapi::CustomMatch_SetSettings& Request::_internal_custommatch_setsettings() const {
  return actions_case() == kCustomMatchSetSettings ? *_impl_.actions_.custommatch_setsettings_ : reinterpret_cast<::rtech::liveapi::CustomMatch_SetSettings&>(::rtech::liveapi::_CustomMatch_SetSettings_default_instance_);
}
inline const ::rtech::liveapi::CustomMatch_SetSettings& Request::custommatch_setsettings() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rtech.liveapi.Request.customMatch_SetSettings)
  return _internal_custommatch_setsettings();
}
inline ::rtech::liveapi::CustomMatch_SetSettings* Request::unsafe_arena_release_custommatch_setsettings() {
  // @@protoc_insertion_point(field_unsafe_arena_release:rtech.liveapi.Request.customMatch_SetSettings)
  if (actions_case() == kCustomMatchSetSettings) {
    clear_has_actions();
    auto* temp = _impl_.actions_.custommatch_setsettings_;
    _impl_.actions_.custommatch_setsettings_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Request::unsafe_arena_set_allocated_custommatch_setsettings(::rtech::liveapi::CustomMatch_SetSettings* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_actions();
  if (value) {
    set_has_custommatch_setsettings();
    _impl_.actions_.custommatch_setsettings_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rtech.liveapi.Request.customMatch_SetSettings)
}
inline ::rtech::liveapi::CustomMatch_SetSettings* Request::_internal_mutable_custommatch_setsettings() {
  if (actions_case() != kCustomMatchSetSettings) {
    clear_actions();
    set_has_custommatch_setsettings();
    _impl_.actions_.custommatch_setsettings_ = CreateMaybeMessage<::rtech::liveapi::CustomMatch_SetSettings>(GetArena());
  }
  return _impl_.actions_.custommatch_setsettings_;
}
inline ::rtech::liveapi::CustomMatch_SetSettings* Request::mutable_custommatch_setsettings() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::rtech::liveapi::CustomMatch_SetSettings* _msg = _internal_mutable_custommatch_setsettings();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.Request.customMatch_SetSettings)
  return _msg;
}

// .rtech.liveapi.CustomMatch_SendChat customMatch_SendChat = 18;
inline bool Request::has_custommatch_sendchat() const {
  return actions_case() == kCustomMatchSendChat;
}
inline bool Request::_internal_has_custommatch_sendchat() const {
  return actions_case() == kCustomMatchSendChat;
}
inline void Request::set_has_custommatch_sendchat() {
  _impl_._oneof_case_[0] = kCustomMatchSendChat;
}
inline void Request::clear_custommatch_sendchat() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (actions_case() == kCustomMatchSendChat) {
    if (GetArena() == nullptr) {
      delete _impl_.actions_.custommatch_sendchat_;
    }
    clear_has_actions();
  }
}
inline ::rtech::liveapi::CustomMatch_SendChat* Request::release_custommatch_sendchat() {
  // @@protoc_insertion_point(field_release:rtech.liveapi.Request.customMatch_SendChat)
  if (actions_case() == kCustomMatchSendChat) {
    clear_has_actions();
    auto* temp = _impl_.actions_.custommatch_sendchat_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.actions_.custommatch_sendchat_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::rtech::liveapi::CustomMatch_SendChat& Request::_internal_custommatch_sendchat() const {
  return actions_case() == kCustomMatchSendChat ? *_impl_.actions_.custommatch_sendchat_ : reinterpret_cast<::rtech::liveapi::CustomMatch_SendChat&>(::rtech::liveapi::_CustomMatch_SendChat_default_instance_);
}
inline const ::rtech::liveapi::CustomMatch_SendChat& Request::custommatch_sendchat() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rtech.liveapi.Request.customMatch_SendChat)
  return _internal_custommatch_sendchat();
}
inline ::rtech::liveapi::CustomMatch_SendChat* Request::unsafe_arena_release_custommatch_sendchat() {
  // @@protoc_insertion_point(field_unsafe_arena_release:rtech.liveapi.Request.customMatch_SendChat)
  if (actions_case() == kCustomMatchSendChat) {
    clear_has_actions();
    auto* temp = _impl_.actions_.custommatch_sendchat_;
    _impl_.actions_.custommatch_sendchat_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Request::unsafe_arena_set_allocated_custommatch_sendchat(::rtech::liveapi::CustomMatch_SendChat* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_actions();
  if (value) {
    set_has_custommatch_sendchat();
    _impl_.actions_.custommatch_sendchat_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rtech.liveapi.Request.customMatch_SendChat)
}
inline ::rtech::liveapi::CustomMatch_SendChat* Request::_internal_mutable_custommatch_sendchat() {
  if (actions_case() != kCustomMatchSendChat) {
    clear_actions();
    set_has_custommatch_sendchat();
    _impl_.actions_.custommatch_sendchat_ = CreateMaybeMessage<::rtech::liveapi::CustomMatch_SendChat>(GetArena());
  }
  return _impl_.actions_.custommatch_sendchat_;
}
inline ::rtech::liveapi::CustomMatch_SendChat* Request::mutable_custommatch_sendchat() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::rtech::liveapi::CustomMatch_SendChat* _msg = _internal_mutable_custommatch_sendchat();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.Request.customMatch_SendChat)
  return _msg;
}

// .rtech.liveapi.CustomMatch_GetLobbyPlayers customMatch_GetLobbyPlayers = 19;
inline bool Request::has_custommatch_getlobbyplayers() const {
  return actions_case() == kCustomMatchGetLobbyPlayers;
}
inline bool Request::_internal_has_custommatch_getlobbyplayers() const {
  return actions_case() == kCustomMatchGetLobbyPlayers;
}
inline void Request::set_has_custommatch_getlobbyplayers() {
  _impl_._oneof_case_[0] = kCustomMatchGetLobbyPlayers;
}
inline void Request::clear_custommatch_getlobbyplayers() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (actions_case() == kCustomMatchGetLobbyPlayers) {
    if (GetArena() == nullptr) {
      delete _impl_.actions_.custommatch_getlobbyplayers_;
    }
    clear_has_actions();
  }
}
inline ::rtech::liveapi::CustomMatch_GetLobbyPlayers* Request::release_custommatch_getlobbyplayers() {
  // @@protoc_insertion_point(field_release:rtech.liveapi.Request.customMatch_GetLobbyPlayers)
  if (actions_case() == kCustomMatchGetLobbyPlayers) {
    clear_has_actions();
    auto* temp = _impl_.actions_.custommatch_getlobbyplayers_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.actions_.custommatch_getlobbyplayers_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::rtech::liveapi::CustomMatch_GetLobbyPlayers& Request::_internal_custommatch_getlobbyplayers() const {
  return actions_case() == kCustomMatchGetLobbyPlayers ? *_impl_.actions_.custommatch_getlobbyplayers_ : reinterpret_cast<::rtech::liveapi::CustomMatch_GetLobbyPlayers&>(::rtech::liveapi::_CustomMatch_GetLobbyPlayers_default_instance_);
}
inline const ::rtech::liveapi::CustomMatch_GetLobbyPlayers& Request::custommatch_getlobbyplayers() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rtech.liveapi.Request.customMatch_GetLobbyPlayers)
  return _internal_custommatch_getlobbyplayers();
}
inline ::rtech::liveapi::CustomMatch_GetLobbyPlayers* Request::unsafe_arena_release_custommatch_getlobbyplayers() {
  // @@protoc_insertion_point(field_unsafe_arena_release:rtech.liveapi.Request.customMatch_GetLobbyPlayers)
  if (actions_case() == kCustomMatchGetLobbyPlayers) {
    clear_has_actions();
    auto* temp = _impl_.actions_.custommatch_getlobbyplayers_;
    _impl_.actions_.custommatch_getlobbyplayers_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Request::unsafe_arena_set_allocated_custommatch_getlobbyplayers(::rtech::liveapi::CustomMatch_GetLobbyPlayers* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_actions();
  if (value) {
    set_has_custommatch_getlobbyplayers();
    _impl_.actions_.custommatch_getlobbyplayers_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rtech.liveapi.Request.customMatch_GetLobbyPlayers)
}
inline ::rtech::liveapi::CustomMatch_GetLobbyPlayers* Request::_internal_mutable_custommatch_getlobbyplayers() {
  if (actions_case() != kCustomMatchGetLobbyPlayers) {
    clear_actions();
    set_has_custommatch_getlobbyplayers();
    _impl_.actions_.custommatch_getlobbyplayers_ = CreateMaybeMessage<::rtech::liveapi::CustomMatch_GetLobbyPlayers>(GetArena());
  }
  return _impl_.actions_.custommatch_getlobbyplayers_;
}
inline ::rtech::liveapi::CustomMatch_GetLobbyPlayers* Request::mutable_custommatch_getlobbyplayers() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::rtech::liveapi::CustomMatch_GetLobbyPlayers* _msg = _internal_mutable_custommatch_getlobbyplayers();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.Request.customMatch_GetLobbyPlayers)
  return _msg;
}

// .rtech.liveapi.CustomMatch_SetTeamName customMatch_SetTeamName = 20;
inline bool Request::has_custommatch_setteamname() const {
  return actions_case() == kCustomMatchSetTeamName;
}
inline bool Request::_internal_has_custommatch_setteamname() const {
  return actions_case() == kCustomMatchSetTeamName;
}
inline void Request::set_has_custommatch_setteamname() {
  _impl_._oneof_case_[0] = kCustomMatchSetTeamName;
}
inline void Request::clear_custommatch_setteamname() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (actions_case() == kCustomMatchSetTeamName) {
    if (GetArena() == nullptr) {
      delete _impl_.actions_.custommatch_setteamname_;
    }
    clear_has_actions();
  }
}
inline ::rtech::liveapi::CustomMatch_SetTeamName* Request::release_custommatch_setteamname() {
  // @@protoc_insertion_point(field_release:rtech.liveapi.Request.customMatch_SetTeamName)
  if (actions_case() == kCustomMatchSetTeamName) {
    clear_has_actions();
    auto* temp = _impl_.actions_.custommatch_setteamname_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.actions_.custommatch_setteamname_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::rtech::liveapi::CustomMatch_SetTeamName& Request::_internal_custommatch_setteamname() const {
  return actions_case() == kCustomMatchSetTeamName ? *_impl_.actions_.custommatch_setteamname_ : reinterpret_cast<::rtech::liveapi::CustomMatch_SetTeamName&>(::rtech::liveapi::_CustomMatch_SetTeamName_default_instance_);
}
inline const ::rtech::liveapi::CustomMatch_SetTeamName& Request::custommatch_setteamname() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rtech.liveapi.Request.customMatch_SetTeamName)
  return _internal_custommatch_setteamname();
}
inline ::rtech::liveapi::CustomMatch_SetTeamName* Request::unsafe_arena_release_custommatch_setteamname() {
  // @@protoc_insertion_point(field_unsafe_arena_release:rtech.liveapi.Request.customMatch_SetTeamName)
  if (actions_case() == kCustomMatchSetTeamName) {
    clear_has_actions();
    auto* temp = _impl_.actions_.custommatch_setteamname_;
    _impl_.actions_.custommatch_setteamname_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Request::unsafe_arena_set_allocated_custommatch_setteamname(::rtech::liveapi::CustomMatch_SetTeamName* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_actions();
  if (value) {
    set_has_custommatch_setteamname();
    _impl_.actions_.custommatch_setteamname_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rtech.liveapi.Request.customMatch_SetTeamName)
}
inline ::rtech::liveapi::CustomMatch_SetTeamName* Request::_internal_mutable_custommatch_setteamname() {
  if (actions_case() != kCustomMatchSetTeamName) {
    clear_actions();
    set_has_custommatch_setteamname();
    _impl_.actions_.custommatch_setteamname_ = CreateMaybeMessage<::rtech::liveapi::CustomMatch_SetTeamName>(GetArena());
  }
  return _impl_.actions_.custommatch_setteamname_;
}
inline ::rtech::liveapi::CustomMatch_SetTeamName* Request::mutable_custommatch_setteamname() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::rtech::liveapi::CustomMatch_SetTeamName* _msg = _internal_mutable_custommatch_setteamname();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.Request.customMatch_SetTeamName)
  return _msg;
}

// .rtech.liveapi.CustomMatch_GetSettings customMatch_GetSettings = 21;
inline bool Request::has_custommatch_getsettings() const {
  return actions_case() == kCustomMatchGetSettings;
}
inline bool Request::_internal_has_custommatch_getsettings() const {
  return actions_case() == kCustomMatchGetSettings;
}
inline void Request::set_has_custommatch_getsettings() {
  _impl_._oneof_case_[0] = kCustomMatchGetSettings;
}
inline void Request::clear_custommatch_getsettings() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (actions_case() == kCustomMatchGetSettings) {
    if (GetArena() == nullptr) {
      delete _impl_.actions_.custommatch_getsettings_;
    }
    clear_has_actions();
  }
}
inline ::rtech::liveapi::CustomMatch_GetSettings* Request::release_custommatch_getsettings() {
  // @@protoc_insertion_point(field_release:rtech.liveapi.Request.customMatch_GetSettings)
  if (actions_case() == kCustomMatchGetSettings) {
    clear_has_actions();
    auto* temp = _impl_.actions_.custommatch_getsettings_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.actions_.custommatch_getsettings_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::rtech::liveapi::CustomMatch_GetSettings& Request::_internal_custommatch_getsettings() const {
  return actions_case() == kCustomMatchGetSettings ? *_impl_.actions_.custommatch_getsettings_ : reinterpret_cast<::rtech::liveapi::CustomMatch_GetSettings&>(::rtech::liveapi::_CustomMatch_GetSettings_default_instance_);
}
inline const ::rtech::liveapi::CustomMatch_GetSettings& Request::custommatch_getsettings() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rtech.liveapi.Request.customMatch_GetSettings)
  return _internal_custommatch_getsettings();
}
inline ::rtech::liveapi::CustomMatch_GetSettings* Request::unsafe_arena_release_custommatch_getsettings() {
  // @@protoc_insertion_point(field_unsafe_arena_release:rtech.liveapi.Request.customMatch_GetSettings)
  if (actions_case() == kCustomMatchGetSettings) {
    clear_has_actions();
    auto* temp = _impl_.actions_.custommatch_getsettings_;
    _impl_.actions_.custommatch_getsettings_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Request::unsafe_arena_set_allocated_custommatch_getsettings(::rtech::liveapi::CustomMatch_GetSettings* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_actions();
  if (value) {
    set_has_custommatch_getsettings();
    _impl_.actions_.custommatch_getsettings_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rtech.liveapi.Request.customMatch_GetSettings)
}
inline ::rtech::liveapi::CustomMatch_GetSettings* Request::_internal_mutable_custommatch_getsettings() {
  if (actions_case() != kCustomMatchGetSettings) {
    clear_actions();
    set_has_custommatch_getsettings();
    _impl_.actions_.custommatch_getsettings_ = CreateMaybeMessage<::rtech::liveapi::CustomMatch_GetSettings>(GetArena());
  }
  return _impl_.actions_.custommatch_getsettings_;
}
inline ::rtech::liveapi::CustomMatch_GetSettings* Request::mutable_custommatch_getsettings() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::rtech::liveapi::CustomMatch_GetSettings* _msg = _internal_mutable_custommatch_getsettings();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.Request.customMatch_GetSettings)
  return _msg;
}

inline bool Request::has_actions() const {
  return actions_case() != ACTIONS_NOT_SET;
}
inline void Request::clear_has_actions() {
  _impl_._oneof_case_[0] = ACTIONS_NOT_SET;
}
inline Request::ActionsCase Request::actions_case() const {
  return Request::ActionsCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// RequestStatus

// string status = 1;
inline void RequestStatus::clear_status() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.status_.ClearToEmpty();
}
inline const std::string& RequestStatus::status() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rtech.liveapi.RequestStatus.status)
  return _internal_status();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RequestStatus::set_status(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.status_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:rtech.liveapi.RequestStatus.status)
}
inline std::string* RequestStatus::mutable_status() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.RequestStatus.status)
  return _s;
}
inline const std::string& RequestStatus::_internal_status() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.status_.Get();
}
inline void RequestStatus::_internal_set_status(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.status_.Set(value, GetArena());
}
inline std::string* RequestStatus::_internal_mutable_status() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.status_.Mutable( GetArena());
}
inline std::string* RequestStatus::release_status() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:rtech.liveapi.RequestStatus.status)
  return _impl_.status_.Release();
}
inline void RequestStatus::set_allocated_status(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.status_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.status_.IsDefault()) {
          _impl_.status_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.RequestStatus.status)
}

// -------------------------------------------------------------------

// Response

// bool success = 1;
inline void Response::clear_success() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.success_ = false;
}
inline bool Response::success() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.Response.success)
  return _internal_success();
}
inline void Response::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:rtech.liveapi.Response.success)
}
inline bool Response::_internal_success() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.success_;
}
inline void Response::_internal_set_success(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.success_ = value;
}

// .google.protobuf.Any result = 2;
inline bool Response::has_result() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.result_ != nullptr);
  return value;
}
inline const ::google::protobuf::Any& Response::_internal_result() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::google::protobuf::Any* p = _impl_.result_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Any&>(::google::protobuf::_Any_default_instance_);
}
inline const ::google::protobuf::Any& Response::result() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rtech.liveapi.Response.result)
  return _internal_result();
}
inline void Response::unsafe_arena_set_allocated_result(::google::protobuf::Any* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.result_);
  }
  _impl_.result_ = reinterpret_cast<::google::protobuf::Any*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rtech.liveapi.Response.result)
}
inline ::google::protobuf::Any* Response::release_result() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Any* released = _impl_.result_;
  _impl_.result_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::Any* Response::unsafe_arena_release_result() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:rtech.liveapi.Response.result)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Any* temp = _impl_.result_;
  _impl_.result_ = nullptr;
  return temp;
}
inline ::google::protobuf::Any* Response::_internal_mutable_result() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.result_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::Any>(GetArena());
    _impl_.result_ = reinterpret_cast<::google::protobuf::Any*>(p);
  }
  return _impl_.result_;
}
inline ::google::protobuf::Any* Response::mutable_result() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::Any* _msg = _internal_mutable_result();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.Response.result)
  return _msg;
}
inline void Response::set_allocated_result(::google::protobuf::Any* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.result_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.result_ = reinterpret_cast<::google::protobuf::Any*>(value);
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.Response.result)
}

// -------------------------------------------------------------------

// LiveAPIEvent

// fixed32 event_size = 1;
inline void LiveAPIEvent::clear_event_size() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.event_size_ = 0u;
}
inline ::uint32_t LiveAPIEvent::event_size() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.LiveAPIEvent.event_size)
  return _internal_event_size();
}
inline void LiveAPIEvent::set_event_size(::uint32_t value) {
  _internal_set_event_size(value);
  // @@protoc_insertion_point(field_set:rtech.liveapi.LiveAPIEvent.event_size)
}
inline ::uint32_t LiveAPIEvent::_internal_event_size() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.event_size_;
}
inline void LiveAPIEvent::_internal_set_event_size(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.event_size_ = value;
}

// .google.protobuf.Any gameMessage = 3;
inline bool LiveAPIEvent::has_gamemessage() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.gamemessage_ != nullptr);
  return value;
}
inline const ::google::protobuf::Any& LiveAPIEvent::_internal_gamemessage() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::google::protobuf::Any* p = _impl_.gamemessage_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Any&>(::google::protobuf::_Any_default_instance_);
}
inline const ::google::protobuf::Any& LiveAPIEvent::gamemessage() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rtech.liveapi.LiveAPIEvent.gameMessage)
  return _internal_gamemessage();
}
inline void LiveAPIEvent::unsafe_arena_set_allocated_gamemessage(::google::protobuf::Any* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.gamemessage_);
  }
  _impl_.gamemessage_ = reinterpret_cast<::google::protobuf::Any*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rtech.liveapi.LiveAPIEvent.gameMessage)
}
inline ::google::protobuf::Any* LiveAPIEvent::release_gamemessage() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Any* released = _impl_.gamemessage_;
  _impl_.gamemessage_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::Any* LiveAPIEvent::unsafe_arena_release_gamemessage() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:rtech.liveapi.LiveAPIEvent.gameMessage)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Any* temp = _impl_.gamemessage_;
  _impl_.gamemessage_ = nullptr;
  return temp;
}
inline ::google::protobuf::Any* LiveAPIEvent::_internal_mutable_gamemessage() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.gamemessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::Any>(GetArena());
    _impl_.gamemessage_ = reinterpret_cast<::google::protobuf::Any*>(p);
  }
  return _impl_.gamemessage_;
}
inline ::google::protobuf::Any* LiveAPIEvent::mutable_gamemessage() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::Any* _msg = _internal_mutable_gamemessage();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.LiveAPIEvent.gameMessage)
  return _msg;
}
inline void LiveAPIEvent::set_allocated_gamemessage(::google::protobuf::Any* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.gamemessage_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.gamemessage_ = reinterpret_cast<::google::protobuf::Any*>(value);
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.LiveAPIEvent.gameMessage)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace liveapi
}  // namespace rtech


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::rtech::liveapi::PlayerOfInterest> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::rtech::liveapi::PlayerOfInterest>() {
  return ::rtech::liveapi::PlayerOfInterest_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_events_2eproto_2epb_2eh
