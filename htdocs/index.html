<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <title>ApexLegends LiveAPI ⇔ WebAPI Playground</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            font-family: 'Consolas', 'PlemolJP', monospace;
        }
        html {
            width: 100%;
        }
        body {
            width: 100%;
            display: grid;
            grid-template-columns: 20em auto;
        }

        /* サイドバー関係 */
        #sidebar {
            box-sizing: border-box;
            padding: 1em;
            border-bottom: 1px solid black;
            border-right: 1px solid black;
        }
        #sidebar h3 {
            margin: 0.4em 0;
            padding: 0;
        }
        #sidebar div {
            padding-left: 1em;
        }
        #sidebar dl {
            margin: 0;
            padding-left: 1em;
            font-size: 90%;
        }
        #sidebar dt {
            margin: 0;
            padding: 0;
        }
        #sidebar dd {
            margin: 0;
            padding-left: 1em;
        }
        #sidebar ul {
            margin: 0;
            padding-left: 1em;
        }
        #sidebar li {
            list-style: none;
            margin: 0;
            padding: 0;
        }
        .sidebar-selected {
            background-color: #FFCCCC;
        }
        #sidebar button {
            width: 100%;
            margin-left: auto;
            margin-right: auto;
        }
        #sidebar p {
            margin: 0;
            padding: 0;
        }
        
        /* main */
        #main {
            box-sizing: border-box;
            width: 100%;
            padding: 1em;
        }
        #main > div.hide {
            display: none;
        }

        #main h3 {
            margin: 0.5em 0;
        }
        
        #main h4 {
            margin: 0.4em 0;
        }

        #main button {
            line-height: 1.3em;
            padding: 0 2em;
        }

        /* tournament-set */
        #tournament-set input, #tournament-rename input {
            width: 40em;
            line-height: 1.3em;
        }
        #tournament-set table {
            border-collapse: collapse;
        }
        #tournament-set th {
            border: 1px solid black;
            padding: 0.1em 1em;
        }
        #tournament-set td {
            border: 1px solid black;
            padding: 0.1em 1em;
        }
        #tournament-set tr:hover:has(>td) {
            background-color: #FFFFCC;
        }
        #tournament-set tr.tournament-set-selected {
            background-color: #FFCCCC;
        }

        /* observer-set */
        
        #observer-set table {
            border-collapse: collapse;
        }
        #observer-set th {
            border: 1px solid black;
            padding: 0.1em 1em;
        }
        #observer-set td {
            border: 1px solid black;
            padding: 0.1em 1em;
        }
        #observer-set tr:hover:has(>td) {
            background-color: #FFFFCC;
        }
        #observer-set tr.observer-set-selected {
            background-color: #FFCCCC;
        }

        /* player-name */
        #player-name table {
            border-collapse: collapse;
        }
        #player-name th {
            border: 1px solid black;
            padding: 0.1em 1em;
        }
        #player-name td {
            border: 1px solid black;
            padding: 0.1em 1em;
        }
        #player-name input {
            width: 12em;
            line-height: 1.3em;
        }

        /* team-name */
        #team-name #team-name-container {
            display: grid;
            grid-template-columns: 2em 1fr 1fr;
        }
        #team-name #team-name-num {
            text-align: right;
            line-height: 1.2em;
            font-size: 100%;
            background-color: #CCC;
        }
        #team-name textarea {
            font-size: 100%;
            height: 36em;
            line-height: 1.2em;
            overflow: clip;
            padding-left: 0.1em;
        }
        #team-name #team-name-output {
            line-height: 1.2em;
            font-size: 100%;
            background-color: #CCC;
        }

        /* realtime */
        #realtime #realtime-gameinfo {
            position: fixed;
            right: 1em;
            top: 1em;
            font-size: 50%;
            width: 60em;
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            box-sizing: border-box;
            border: 1px solid black;

        }
        #realtime #realtime-gameinfo > div {
            margin-right: 1em;
            align-items: baseline;
        }
        #realtime #realtime-teams {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr 1fr 1fr;
        }
        #realtime .realtime-team-banner {
            display: grid;
            grid-template-columns: 2em 1fr 2em 2em;
        }
        #realtime-teams > div {
            box-sizing: border-box;
            border: 1px solid black;
            margin: 1px;
        }
        .realtime-team-kills-header, .realtime-team-placement-header {
            font-size: 30%;
            text-align: center;
        }
        .realtime-team-number, .realtime-team-name {
            line-height: 2em;
        }
        .realtime-team-name {
            overflow: clip;
            font-weight: bold;
        }
        .realtime-team-number, .realtime-team-kills-value, .realtime-team-placement-value {
            text-align: center;
        }
        .realtime-team-eliminated {
            opacity: 0.3;
        }
        .realtime-player-base {
            display: grid;
            grid-template-columns: 2fr 1fr;
            box-sizing: border-box;
            border-top: 1px solid black;
            padding: 0 2px;
        }
        .realtime-player-base.realtime-player-state-collected {
            color: rgb(109, 198, 24);
        }
        .realtime-player-base.realtime-player-state-down {
            color: rgb(213, 25, 26);
        }
        .realtime-player-base.realtime-player-state-killed {
            color: #999;
        }
        .realtime-player-name {
            font-size: 90%;
            font-weight: bold;
            overflow: clip;
        }
        .realtime-player-hpshield {
            display: grid;
            grid-template-columns: 20px 1fr;
        }
        .realtime-player-hpbar, .realtime-player-shieldbar {
            margin-top: 3px;
        }
        .realtime-player-right, .realtime-player-character,.realtime-player-hp, .realtime-player-shield {
            font-size: 30%;
            overflow: clip;
        }
        .realtime-player-base.realtime-player-selected {
            background-color: #FFCCCC;
        }
        .realtime-player-state-alive:hover {
            background-color: #FFFFCC;
        }

        /* announce */
        #announce input {
            width: 40em;
            line-height: 1.3em;
        }

        /* result */
        #result-game-info {
            display: flex;
            font-size: 50%;
        }

        .result-game-info-number {
            font-weight: bold;
        }

        #result-game-info > div {
            box-sizing: border-box;
            border: 1px solid black;
            margin: 1px;
            padding: 2px;
        }
        
        #result-game-info > div:hover {
            background-color: #FFFFCC;
        }

        .result-game-info-selected {
            background-color: #FFCCCC;
        }

        #result-all-base {
            margin-top: 1em;
            display: grid;
            grid-template-columns: 1fr 1fr;
            border-top: 1px solid black;
            border-left: 1px solid black;
            box-sizing: border-box;
        }
        #result-all-base.hide {
            display: none;
        }

        .result-all-team-base {
            border-right: 1px solid black;
            border-bottom: 1px solid black;
            box-sizing: border-box;
        }
        .result-all-team-banner {
            display: grid;
            grid-template-columns: 2em 1fr 4em 4em 4em;
            line-height: 3em;
        }
        .result-all-team-name {
            font-weight: bold;
            padding-left: 1em;
        }
        .result-all-team-rank {
            text-align: right;
        }
        .result-all-team-kills, .result-all-team-placement, .result-all-team-points {
            text-align: center;
            line-height: 2em;
        }
        .result-all-team-points {
            font-weight: bold;
        }
        .result-all-team-kills-label, .result-all-team-placement-label, .result-all-team-points-label {
            font-size: 50%;
            line-height: 1;
        }
        .result-all-team-placement span {
            font-size: 50%;
        }

        .result-all-player-base {
            margin: 0 4em 0 8em;
            display: grid;
            grid-template-columns: 1fr 4em;
            padding-left: 1em;
            border-top: 1px solid black;
            border-left: 1px solid black;
            box-sizing: border-box;
        }

        #result-single {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr 1fr;
            border-top: 1px solid black;
            border-left: 1px solid black;
            box-sizing: border-box;
            margin-top: 1em;
        }
        #result-single.hide {
            display: none;
        }

        .result-single-team-base {
            border-right: 1px solid black;
            border-bottom: 1px solid black;

        }
        .result-single-team-banner {
            display: grid;
            grid-template-columns: 1fr 2.2em 2.2em 2.4em;
        }
        .result-single-team-name {
            font-weight: bold;
            line-height: 2em;
            padding-left: 1em;
            overflow: clip;
        }
        .result-single-team-placement-label, .result-single-team-kills-label, .result-single-team-points-label {
            font-size: 50%;
            text-align: center;
        }
        .result-single-team-placement-value, .result-single-team-kills-value, .result-single-team-points-value {
            text-align: center;
        }
        .result-single-player-label-base > div {
            font-size: 50%;
            text-align: center;
            background-color: #CCC;
        }
        .result-single-player-label-base, .result-single-player-base {
            font-size: 80%;
            display: grid;
            grid-template-columns: 1fr 5em 2em 2em 3em;
        }
        .result-single-player-base {
            line-height: 2em;
        }
        .result-single-player-name {
            padding-left: 0.5em;
            overflow: clip;
        }
        .result-single-player-kills, .result-single-player-assists {
            text-align: center;
        }
        .result-single-player-character {
            text-align: center;
            overflow: clip;
            white-space: nowrap;
            font-size: 50%;
        }
        .result-single-player-damage {
            text-align: center;
        }
    </style>
</head>

<body>
    
<div id="sidebar">
    <h3>WebAPI Connection</h3>
    <div>
        <button id="connectbtn">force reconnect</button>
        <p>status: <span id="connectstatus">connecting...</span></p>
    </div>
    <h3>Current Tournament</h3>
    <dl>
        <dt>Name:</dt>
        <dd id="current_tournament_name">noname</dd>
        <dt>ID:</dt>
        <dd id="current_tournament_id">none</dd>
    </dl>
    <h3>Current Observer</h3>
    <dl>
        <dt>ID:</dt>
        <dd id="current_observer_id">none</dd>
    </dl>
    <h3>MENU</h3>
    <ul id="sidebarmenu">
        <li>
            Tournament
            <ul>
                <li><a href="#tournament-set">set</a></li>
                <li><a href="#tournament-rename">rename</a></li>
                <li><a href="#tournament-params"><s>set parameters</s></a></li>
            </ul>
        </li>
        <li>
            Observer
            <ul>
                <li><a href="#observer-set">set</a></li>
            </ul>
        </li>
        <li>Player
            <ul>
                <li><a href="#player-name">set name</a></li>
                <li><a href="#player-params"><s>set parameters</s></a></li>
            </ul>
        </li>
        <li>Team
            <ul>
                <li><a href="#team-name">set name</a></li>
                <li><a href="#team-params"><s>set parameters</s></a></li>
            </ul>
        </li>
        <li><a href="#realtime">Realtime View</a></li>
        <li><a href="#overlay">Overlay</a></li>
        <li><a href="#announce">Announce</a></li>
        <li>
            Result
            <ul id="ulresult">
                <li><a href="#result-all">all</a></li>
            </ul>
        </li>
    </ul>
</div>

<div id="main">
<div id="tournament-set" class="hide">
    <h3>Tournament: set name</h3>
    <p>create new tournament or select exists tournament.</p>
    <h4>create new tournament</h4>
    <p>
        <input type="text" id="tournament-set-text" placeholder="input tournament name" /><button id="tournament-set-button">create</button>
        <br>
        ** If there is already a tournament with the same name, the existing tournament will be selected.
    </p>
    <h4>select exists tournament</h4>
    <table>
        <thead>
            <tr><th>name</th><th>ID</th></tr>
        </thead>
        <tbody id="tournamentids"></tbody>
    </table>
</div>
<div id="tournament-rename" class="hide">
    <h3>Tournament: rename</h3>
    <p>rename current tournament.</p>
    <p>
        <input type="text" id="tournament-rename-text" placeholder="input tournament name" /><button id="tournament-rename-button">rename</button>
        <br>
    </p>
</div>
<div id="tournament-params" class="hide">
    <h3>Tournament: set parameters</h3>
    <p>
        not yet implemented.
    </p>
</div>

<div id="observer-set" class="hide">
    <h3>Observer: set</h3>
    <h4>gather observer hash</h4>
    <p>
        <button id="observer-set-getfromlobby">get from lobby</button>
    </p>
    <h4>select observer for overlay</h4>
    <table>
        <thead>
            <tr><th>ID</th><th>name</th></tr>
        </thead>
        <tbody id="observer-set-list"></tbody>
    </table>
</div>

<div id="player-name" class="hide">
    <h3>Player: set name</h3>
    <h4>gather player hash</h4>
    <p>
        <button id="player-name-getfromresults">get from results</button>
        <button id="player-name-getfromlivedata"><s>get from current game</s></button>
        <button id="player-name-getfromlobby">get from lobby</button>
    </p>
    <h4>set player name</h4>
    <table>
        <thead>
            <tr><th>ID</th><th>name</th><th>in-game name</th><th>set name</th></tr>
        </thead>
        <tbody id="player-name-list"></tbody>
    </table>
</div>
<div id="player-params" class="hide">
    <h3>Player: set parameters</h3>
    <p>
        not yet implemented.
    </p>
</div>
<div id="team-name" class="hide">
    <h3>Team: set name</h3>
    <div id="team-name-container">
        <div></div>
        <div>input</div>
        <div>set name result</div>
        <pre id="team-name-num"></pre>
        <textarea id="team-name-text"></textarea>
        <pre id="team-name-output"></pre>
    </div>
    <button id="team-name-button">set name</button>
</div>
<div id="team-params" class="hide">
    <h3>Team: set parameters</h3>
    <p>
        not yet implemented.
    </p>
</div>

<div id="realtime" class="hide">
    <h3>Realtime View</h3>
    <div id="realtime-gameinfo"></div>
    <div id="realtime-teams"></div>
</div>

<div id="overlay" class="hide">
    <h3>Overlay</h3>
    <h4>force hide overlay</h4>
    <p>
        <label><input type="checkbox" id="overlay-hide-leaderboard" /> Force hide LeaderBoard</label>
    </p>
    <p>
        <label><input type="checkbox" id="overlay-hide-teambanner" /> Force hide TeamBanner</label>
    </p>
    <p>
        <label><input type="checkbox" id="overlay-hide-playerbanner" /> Force hide PlayerBanner</label>
    </p>
    <p>
        <label><input type="checkbox" id="overlay-hide-teamkills" /> Force hide TeamKills</label>
    </p>
    <p>
        <label><input type="checkbox" id="overlay-hide-owneditems" /> Force hide OwnedItems</label>
    </p>
    <p>
        <label><input type="checkbox" id="overlay-hide-gameinfo" /> Force hide GameInfo</label>
    </p>
    <p>
        <label><input type="checkbox" id="overlay-hide-championbanner" /> Force hide ChampionBanner</label>
    </p>
    <h4>select by group</h4>
    <p>
        <label><input type="checkbox" id="overlay-hide-teamplayerinfo" /> Force hide Team/Player Overlay</label>
    </p>
</div>

<div id="announce" class="hide">
    <h3>Announce</h3>
    <h4>send chat</h4>
    <p>
        <input type="text" id="announce-text" /><button id="announce-button">send</button>
    </p>
</div>

<div id="result" class="hide">
    <h3>Result</h3>
    <p><a href="#result-all">show all results</a></p>
    <div id="result-game-info"></div>
    <div id="result-all-base">
        <div id="result-all-left"></div>
        <div id="result-all-right"></div>
    </div>
    <div id="result-single" class="hide"></div>
</div>
</div>



<script type="module">
import * as ApexWebAPI from "./apex-webapi.js";

class ObserverConfig {
    #callback;
    #observers;
    #current;
    #base;

    constructor() {
        this.#observers = {};
        this.#current = "";
        this.#base = document.getElementById('observer-set-list');
    }

    #generateObserverNode(id) {
        const node = {
            base: document.createElement('tr'),
            id: document.createElement('td'),
            name: document.createElement('td')
        }

        /* append */
        node.base.appendChild(node.id);
        node.base.appendChild(node.name);

        /* draw */
        node.id.innerText = id;
        
        /* set current */
        if (this.#current != "" && id == this.#current) {
            node.base.classList.add('observer-set-selected');
        }

        /* set callback */
        node.base.addEventListener('click', () => {
            if (this.#current == id) return;
            if (typeof(this.#callback) != 'function') return;
            this.#callback(id);
        });

        return node;
    }

    drawObserverName(id, name) {
        if (id == '') return;
        if (!(id in this.#observers)) {
            this.#observers[id] = {};
        }
        const observer = this.#observers[id];
        if (!('name' in observer)) {
            observer.name = name;
        }

        if (!('node' in observer)) {
            observer.node = this.#generateObserverNode(id);
            this.#base.appendChild(observer.node.base);
        }

        observer.node.name.innerText = name;
    }

    setCurrentObserver(id) {
        this.#current = id;
        if (id == '') return;
        document.getElementById('current_observer_id').innerText = id;
        if (!(id in this.#observers)) return;
        const observer = this.#observers[id];
        if (!('node' in observer)) return;
        for (const node of document.querySelectorAll('tr.observer-set-selected')) {
            node.classList.remove('observer-set-selected');
        }
        observer.node.base.classList.add('observer-set-selected');
    }
    
    setClickCallback(func) {
        this.#callback = func;
    }
}

class RealtimeView {
    #_game;
    #basenode;
    #gameinfonode;
    #nodes;
    #gameinfonodes;
    #callback;
    #playersnamenode;

    constructor() {
        this.#basenode = document.getElementById('realtime-teams');
        this.#nodes = [];
        this.#callback = null;
        this.#playersnamenode = {};

        // ゲーム情報の格納先作成
        this.#gameinfonode = document.getElementById('realtime-gameinfo');
        this.#gameinfonodes = {
            datacenter: document.createElement('div'),
            aimassiston: document.createElement('div'),
            serverid: document.createElement('div'),
            anonymousmode: document.createElement('div'),
            state: document.createElement('div'),
            start: document.createElement('div'),
            end: document.createElement('div'),
            map: document.createElement('div'),
            playlistname: document.createElement('div'),
            playlistdesc: document.createElement('div'),
        };
        this.#gameinfonode.appendChild(this.#gameinfonodes.datacenter);
        this.#gameinfonode.appendChild(this.#gameinfonodes.aimassiston);
        this.#gameinfonode.appendChild(this.#gameinfonodes.anonymousmode);
        this.#gameinfonode.appendChild(this.#gameinfonodes.serverid);
        this.#gameinfonode.appendChild(this.#gameinfonodes.state);
        this.#gameinfonode.appendChild(this.#gameinfonodes.start);
        this.#gameinfonode.appendChild(this.#gameinfonodes.end);
        this.#gameinfonode.appendChild(this.#gameinfonodes.map);
        this.#gameinfonode.appendChild(this.#gameinfonodes.playlistname);
        this.#gameinfonode.appendChild(this.#gameinfonodes.playlistdesc);

    }

    #precheckTeamID(teamid) {
        if (teamid < this.#basenode.children.length) return;
        for (let i = this.#basenode.children.length; i <= teamid; ++i) {
            this.#appendTeamNode(i);
        }
    }

    #precheckPlayerID(teamid, playerid) {
        if (playerid < this.#nodes[teamid].players.length) return;
        for (let i = this.#nodes[teamid].players.length; i <= playerid; ++i) {
            this.#appendPlayerNode(teamid, i);
        }
    }

    #drawBarHP(canvas, hp, hpmax) {
        const height = 8;
        canvas.width = hpmax + 2;
        canvas.height = height;
        const ctx = canvas.getContext('2d');
        ctx.fillStyle = "#000000";
        ctx.fillRect(0, 0, hpmax + 2, height);
        ctx.fillStyle = "#FFFFFF";
        ctx.fillRect(1, 1, hp, height - 2);
    }
    
    #drawBarShield(canvas, shield, shieldmax, gold = false) {
        const height = 8;
        canvas.width = shieldmax + 2;
        canvas.height = height;
        const ctx = canvas.getContext('2d');
        ctx.fillStyle = "#000000";
        ctx.fillRect(0, 0, shieldmax + 2, height);

        if (shieldmax == 125) {
            ctx.fillStyle = "#FF0000";
        } else if (shieldmax == 100) {
            if (gold) {
                ctx.fillStyle = "#E6B422";
            } else {
                ctx.fillStyle = "#A260BF";
            }
        } else if (shieldmax == 75) {
            ctx.fillStyle = "#7FCCE3";
        } else {
            ctx.fillStyle = "#FFFFFF";
        }
        ctx.fillRect(1, 1, shield, height - 2);
    }

    #generateTeamNode(teamid) {
        const teamnode = {};
        teamnode.base = document.createElement('div');
        teamnode.banner = document.createElement('div');
        teamnode.number = document.createElement('div');
        teamnode.name = document.createElement('div');
        teamnode.kills = document.createElement('div');
        teamnode.kills_header = document.createElement('div');
        teamnode.kills_value = document.createElement('div');
        teamnode.placement = document.createElement('div');
        teamnode.placement_header = document.createElement('div');
        teamnode.placement_value = document.createElement('div');
        teamnode.players = [];

        /* append */
        teamnode.banner.appendChild(teamnode.number);
        teamnode.banner.appendChild(teamnode.name);
        teamnode.banner.appendChild(teamnode.kills);
        teamnode.banner.appendChild(teamnode.placement);
        teamnode.kills.appendChild(teamnode.kills_header);
        teamnode.kills.appendChild(teamnode.kills_value);
        teamnode.placement.appendChild(teamnode.placement_header);
        teamnode.placement.appendChild(teamnode.placement_value);
        teamnode.base.appendChild(teamnode.banner);

        /* set class */
        teamnode.base.classList.add('realtime-team-base');
        teamnode.banner.classList.add('realtime-team-banner');
        teamnode.number.classList.add('realtime-team-number');
        teamnode.name.classList.add('realtime-team-name');
        teamnode.kills.classList.add('realtime-team-kills');
        teamnode.kills_header.classList.add('realtime-team-kills-header');
        teamnode.kills_value.classList.add('realtime-team-kills-value');
        teamnode.placement.classList.add('realtime-team-placement');
        teamnode.placement_header.classList.add('realtime-team-placement-header');
        teamnode.placement_value.classList.add('realtime-team-placement-value');

        /* set initial text */
        teamnode.number.innerText = (teamid + 1);
        teamnode.kills_header.innerText = 'kills';
        teamnode.kills_value.innerText = '0';
        teamnode.placement_header.innerText = 'place';
        teamnode.placement_value.innerText = '0';

        return teamnode;
    }

    #generatePlayerNode(teamid, playerid) {
        const playernode = {};
        playernode.base = document.createElement('div');
        playernode.left = document.createElement('div');
        playernode.right = document.createElement('div');
        playernode.name = document.createElement('div');
        playernode.character = document.createElement('div');
        playernode.hpshield = document.createElement('div');
        playernode.hp = document.createElement('div');
        playernode.hpbar = document.createElement('canvas');
        playernode.shield = document.createElement('div');
        playernode.shieldbar = document.createElement('canvas');
        playernode.kills = document.createElement('div');
        playernode.assists = document.createElement('div');
        playernode.damage_dealt = document.createElement('div');
        playernode.damage_taken = document.createElement('div');

        /* append */
        playernode.base.appendChild(playernode.left);
        playernode.base.appendChild(playernode.right);
        playernode.left.appendChild(playernode.name);
        playernode.left.appendChild(playernode.hpshield);
        playernode.left.appendChild(playernode.character);
        playernode.hpshield.appendChild(playernode.hp);
        playernode.hpshield.appendChild(playernode.hpbar);
        playernode.hpshield.appendChild(playernode.shield);
        playernode.hpshield.appendChild(playernode.shieldbar);
        playernode.right.appendChild(playernode.kills);
        playernode.right.appendChild(playernode.assists);
        playernode.right.appendChild(playernode.damage_dealt);
        playernode.right.appendChild(playernode.damage_taken);
        
        /* set class */
        playernode.base.classList.add('realtime-player-base');
        playernode.base.classList.add('realtime-player-state-alive'); // デフォルトは生存
        playernode.left.classList.add('realtime-player-left');
        playernode.right.classList.add('realtime-player-right');
        playernode.name.classList.add('realtime-player-name');
        playernode.character.classList.add('realtime-player-character');
        playernode.hpshield.classList.add('realtime-player-hpshield');
        playernode.hp.classList.add('realtime-player-hp');
        playernode.hpbar.classList.add('realtime-player-hpbar');
        playernode.shield.classList.add('realtime-player-shield');
        playernode.shieldbar.classList.add('realtime-player-shieldbar');
        playernode.kills.classList.add('realtime-player-kills');
        playernode.assists.classList.add('realtime-player-assists');
        playernode.damage_dealt.classList.add('realtime-player-damage-dealt');
        playernode.damage_taken.classList.add('realtime-player-damage-taken');

        /* set initial text */
        playernode.hp.innerText = 'HP:';
        playernode.shield.innerText = '🛡:';
        playernode.character.innerText = '';
        playernode.kills.innerText = 'kills:0';
        playernode.assists.innerText = 'assists:0';
        playernode.damage_dealt.innerText = 'dealt:0';
        playernode.damage_taken.innerText = 'taken:0';

        /* set canvas size */
        playernode.hpbar.width = 1;
        playernode.hpbar.height = 1;
        playernode.shieldbar.width = 1;
        playernode.shieldbar.height = 1;

        /* set click callback */
        playernode.base.addEventListener('click', (ev) => {
            if (playernode.base.classList.contains('realtime-player-state-alive')) {
                if (typeof(this.#callback) == "function") {
                    this.#callback(teamid, playerid);
                }
            }
        });

        return playernode;
    }

    #appendTeamNode(teamid) {
        const teamnode = this.#generateTeamNode(teamid);
        this.#nodes.push(teamnode);
        this.#basenode.appendChild(teamnode.base);
    }

    #appendPlayerNode(teamid, playerid) {
        const playernode = this.#generatePlayerNode(teamid, playerid);
        this.#nodes[teamid].players.push(playernode);
        this.#nodes[teamid].base.appendChild(playernode.base);
    }

    #getDateString(timestamp) {
        if (timestamp == 0) return 'none';
        return (new Date(timestamp)).toLocaleString();
    }

    drawGameInfo() {
        if (this.#_game == null) return;
        this.#gameinfonodes.datacenter.innerText = 'datacenter:' + this.#_game.datacenter;
        this.#gameinfonodes.aimassiston.innerText = 'aimassiston:' + this.#_game.aimassiston;
        this.#gameinfonodes.anonymousmode.innerText = 'anonymousmode:' + this.#_game.anonymousmode;
        this.#gameinfonodes.serverid.innerText = 'serverid:' + this.#_game.serverid;
        this.#gameinfonodes.state.innerText = 'state:' + this.#_game.state;
        this.#gameinfonodes.start.innerText = 'start:' + this.#getDateString(this.#_game.start);
        this.#gameinfonodes.end.innerText = 'end:' + this.#getDateString(this.#_game.end);
        this.#gameinfonodes.map.innerText = 'map:' + this.#_game.map;
        // this.#gameinfonodes.playlistname.innerText = 'playlistname:' + this.#_game.playlistname;
        // this.#gameinfonodes.playlistdesc.innerText = 'playlistdesc:' + this.#_game.playlistdesc;
    }

    drawTeamName(teamid) {
        this.#precheckTeamID(teamid);
        if (teamid < this.#_game.teams.length) {
            const team = this.#_game.teams[teamid];
            let name = '';
            if ('params' in team && 'name' in team.params) {
                name = team.params.name;
            } else if ('name' in team) {
                name = team.name;
            }
            if (name != '') {
                this.#nodes[teamid].name.innerText = name;
                return true;
            }
        }
        return false;
    }

    drawTeamKills(teamid) {
        this.#precheckTeamID(teamid);
        if (teamid < this.#_game.teams.length) {
            const team = this.#_game.teams[teamid];
            if ('kills' in team) {
                this.#nodes[teamid].kills_value.innerText = team.kills;
                return true;
            }
        }
        return false;
    }

    drawTeamPlacement(teamid) {
        this.#precheckTeamID(teamid);
        if (teamid < this.#_game.teams.length) {
            const team = this.#_game.teams[teamid];
            if ('placement' in team) {
                this.#nodes[teamid].placement_value.innerText = team.placement;
                return true;
            }
        }
        return false;
    }
    
    drawTeamEliminated(teamid) {
        this.#precheckTeamID(teamid);
        if (teamid < this.#_game.teams.length) {
            const team = this.#_game.teams[teamid];
            if ('eliminated' in team) {
                if (team.eliminated) {
                    this.#nodes[teamid].base.classList.add('realtime-team-eliminated');
                } else {
                    this.#nodes[teamid].base.classList.remove('realtime-team-eliminated');
                }
                return true;
            }
        }
        return false;
    }

    drawTeam(teamid) {
        if (drawTeamName(teamid) &&
        drawTeamKills(teamid) &&
        drawTeamPlacement(teamid)) {
            return true;
        }
        return false;
    }

    static PLAYERNODE_NAME = 0x00;
    static PLAYERNODE_CHARACTER = 0x01;
    static PLAYERNODE_HP = 0x02;
    static PLAYERNODE_SHIELD = 0x03;
    static PLAYERNODE_KILLS = 0x04;
    static PLAYERNODE_ASSISTS = 0x05;
    static PLAYERNODE_DAMAGE_DEALT = 0x06;
    static PLAYERNODE_DAMAGE_TAKEN = 0x07;
    static PLAYERNODE_STATE = 0x08;
    static PLAYERNODE_SELECTED = 0x09;

    drawPlayerNode(teamid, playerid, nodetype = RealtimeView.PLAYERNODE_NAME) {
        this.#precheckTeamID(teamid);
        this.#precheckPlayerID(teamid, playerid);
        if (teamid >= this.#_game.teams.length) return false;
        if (playerid >= this.#_game.teams[teamid].length) return false;
        const player = this.#_game.teams[teamid].players[playerid];
        switch(nodetype) {
            case RealtimeView.PLAYERNODE_NAME: {
                const node = this.#nodes[teamid].players[playerid].name;
                this.#playersnamenode[player.hash] = node;
                if ('params' in player && 'name' in player.params) {
                    node.innerText = player.params.name;
                    return true;
                } else if ('name' in player) {
                    node.innerText = player.name;
                    return true;
                }
                break;
            }
            case RealtimeView.PLAYERNODE_CHARACTER: {
                const node = this.#nodes[teamid].players[playerid].character;
                if ('character' in player) {
                    node.innerText = player.character;
                    return true;
                }
                break;
            }
            case RealtimeView.PLAYERNODE_HP: {
                const node = this.#nodes[teamid].players[playerid].hpbar;
                if ('hp' in player && 'hp_max' in player) {
                    // node.innerText = 'HP:' + player.hp + '/' + player.hp_max;
                    this.#drawBarHP(node, player.hp, player.hp_max);
                    return true;
                }
                break;
            }
            case RealtimeView.PLAYERNODE_SHIELD: {
                const node = this.#nodes[teamid].players[playerid].shieldbar;
                if ('shield' in player && 'shield_max' in player) {
                    let gold = false;
                    if ('items' in player && 'bodyshield' in player.items && player.items.bodyshield == 4) gold = true;
                    this.#drawBarShield(node, player.shield, player.shield_max, gold);
                    return true;
                }
                break;
            }
            case RealtimeView.PLAYERNODE_KILLS: {
                const node = this.#nodes[teamid].players[playerid].kills;
                if ('kills' in player) {
                    node.innerText = 'kills:' + player.kills;
                    return true;
                }
                break;
            }
            case RealtimeView.PLAYERNODE_ASSISTS: {
                const node = this.#nodes[teamid].players[playerid].assists;
                if ('assists' in player) {
                    node.innerText = 'assists:' + player.assists;
                    return true;
                }
                break;
            }
            case RealtimeView.PLAYERNODE_DAMAGE_DEALT: {
                const node = this.#nodes[teamid].players[playerid].damage_dealt;
                if ('damage_dealt' in player) {
                    node.innerText = 'dealt:' + player.damage_dealt;
                    return true;
                }
                break;
            }
            case RealtimeView.PLAYERNODE_DAMAGE_TAKEN: {
                const node = this.#nodes[teamid].players[playerid].damage_taken;
                if ('damage_taken' in player) {
                    node.innerText = 'taken:' + player.damage_taken;
                    return true;
                }
                break;
            }
            case RealtimeView.PLAYERNODE_STATE: {
                const node = this.#nodes[teamid].players[playerid].base;
                if ('state' in player) {
                    if (player.state == ApexWebAPI.ApexWebAPI.WEBAPI_PLAYER_STATE_DOWN) {
                        node.classList.remove('realtime-player-state-alive');
                        node.classList.add('realtime-player-state-down');
                        node.classList.remove('realtime-player-state-killed');
                        node.classList.remove('realtime-player-state-collected');
                    } else if (player.state == ApexWebAPI.ApexWebAPI.WEBAPI_PLAYER_STATE_KILLED) {
                        node.classList.remove('realtime-player-state-alive');
                        node.classList.remove('realtime-player-state-down');
                        node.classList.add('realtime-player-state-killed');
                        node.classList.remove('realtime-player-state-collected');
                    } else if (player.state == ApexWebAPI.ApexWebAPI.WEBAPI_PLAYER_STATE_COLLECTED) {
                        node.classList.remove('realtime-player-state-alive');
                        node.classList.remove('realtime-player-state-down');
                        node.classList.remove('realtime-player-state-killed');
                        node.classList.add('realtime-player-state-collected');
                    } else {
                        node.classList.add('realtime-player-state-alive');
                        node.classList.remove('realtime-player-state-down');
                        node.classList.remove('realtime-player-state-killed');
                        node.classList.remove('realtime-player-state-collected');
                    }
                    return true;
                }
                break;
            }
            case RealtimeView.PLAYERNODE_SELECTED: {
                const node = this.#nodes[teamid].players[playerid].base;
                for (const t of document.querySelectorAll('.realtime-player-selected')) {
                    t.classList.remove('realtime-player-selected');
                }
                node.classList.add('realtime-player-selected');
                break;
            }
        }
        return false;
    }

    redrawPlayerName(hash, params) {
        if (hash in this.#playersnamenode) {
            const namenode = this.#playersnamenode[hash];
            if ('name' in params && params.name != '') {
                namenode.innerText = params.name;
            }
        }
    }

    drawPlayer(teamid, playerid) {
        let result = true;
        if (!drawPlayerNode(teamid, playerid, PLAYERNODE_NAME)) result = false;
        if (!drawPlayerNode(teamid, playerid, PLAYERNODE_CHARACTER)) result = false;
        if (!drawPlayerNode(teamid, playerid, PLAYERNODE_HP)) result = false;
        if (!drawPlayerNode(teamid, playerid, PLAYERNODE_SHIELD)) result = false;
        if (!drawPlayerNode(teamid, playerid, PLAYERNODE_KILLS)) result = false;
        if (!drawPlayerNode(teamid, playerid, PLAYERNODE_ASSISTS)) result = false;
        if (!drawPlayerNode(teamid, playerid, PLAYERNODE_DAMAGE_DEALT)) result = false;
        if (!drawPlayerNode(teamid, playerid, PLAYERNODE_DAMAGE_TAKEN)) result = false;
        if (!drawPlayerNode(teamid, playerid, PLAYERNODE_STATE)) result = false;
        return result;
    }

    setGame(game) {
        this.#_game = game;
        this.drawGameInfo();
    }

    clear() {
        this.#basenode.innerHTML = '';
        this.#nodes.splice(0);
        for (const key in this.#playersnamenode) {
            delete this.#playersnamenode[key];
        }
    }

    setPlayerClickCallback(func) {
        this.#callback = func;
    }
}

class ResultView {
    #_game;
    #_results;
    #info;
    #all;
    #left;
    #right;
    #single;
    #nodes;
    #infonodes;
    #players; // params保存用
    #current;
    #callback;
    #unknownidcallback;
    static points_table = [12, 9, 7, 5, 4, 3, 3, 2, 2, 2, 1, 1, 1, 1, 1];

    constructor() {
        this.#info = document.getElementById('result-game-info');
        this.#all = document.getElementById('result-all-base');
        this.#left = document.getElementById('result-all-left');
        this.#right = document.getElementById('result-all-right');
        this.#single = document.getElementById('result-single');
        this.#nodes = [];
        this.#infonodes = [];
        this.#_game = null;
        this.#_results = null;
        this.#players = {};
        this.#current = "all";
        this.#callback = null;
        this.#unknownidcallback = null;
        this.clear();
    }
    
    #generateGameInfoNode(gameid) {
        const node = {
            base: document.createElement('div'),
            gamenumber: document.createElement('div'),
            datacenter: document.createElement('div'),
            serverid: document.createElement('div'),
            playlistname: document.createElement('div'),
            playlistdesc: document.createElement('div'),
            map: document.createElement('div'),
            start: document.createElement('div'),
            end: document.createElement('div'),
            anonymousmode: document.createElement('div'),
            aimassiston: document.createElement('div')
        }

        /* append */
        node.base.appendChild(node.gamenumber);
        node.base.appendChild(node.datacenter);
        node.base.appendChild(node.serverid);
        // node.base.appendChild(node.playlistname);
        // node.base.appendChild(node.playlistdesc);
        node.base.appendChild(node.map);
        node.base.appendChild(node.start);
        node.base.appendChild(node.end);
        node.base.appendChild(node.anonymousmode);
        node.base.appendChild(node.aimassiston);

        /* class */
        node.gamenumber.classList.add('result-game-info-number');

        /* callback */
        node.base.addEventListener('click', () => {
            if (typeof(this.#callback) == 'function') {
                this.#callback(gameid);
            }
        });

        return node;
    }

    #generateTeamNodeForAll() {
        const node = {
            base: document.createElement('div'),
            banner: document.createElement('div'),
            rank: document.createElement('div'),
            name: document.createElement('div'),
            placement: document.createElement('div'),
            placement_label: document.createElement('div'),
            placement_value: document.createElement('div'),
            kills: document.createElement('div'),
            kills_label: document.createElement('div'),
            kills_value: document.createElement('div'),
            points: document.createElement('div'),
            points_label: document.createElement('div'),
            points_value: document.createElement('div'),
        }

        /* append */
        node.base.appendChild(node.banner);
        node.banner.appendChild(node.rank);
        node.banner.appendChild(node.name);
        node.banner.appendChild(node.placement);
        node.banner.appendChild(node.kills);
        node.banner.appendChild(node.points);
        node.placement.appendChild(node.placement_label);
        node.placement.appendChild(node.placement_value);
        node.kills.appendChild(node.kills_label);
        node.kills.appendChild(node.kills_value);
        node.points.appendChild(node.points_label);
        node.points.appendChild(node.points_value);

        /* set class */
        node.base.classList.add('result-all-team-base');
        node.banner.classList.add('result-all-team-banner');
        node.rank.classList.add('result-all-team-rank');
        node.name.classList.add('result-all-team-name');
        node.placement.classList.add('result-all-team-placement');
        node.placement_label.classList.add('result-all-team-placement-label');
        node.kills.classList.add('result-all-team-kills');
        node.kills_label.classList.add('result-all-team-kills-label');
        node.points.classList.add('result-all-team-points');
        node.points_label.classList.add('result-all-team-kills-label');
        return node;
    }

    #drawTeamForAll(rank, total, team, placement = null) {
        // 要素が足りてなかったら埋める
        if (rank >= this.#nodes.length) {
            for (let i = this.#nodes.length; i <= rank; ++i) {
                const node = this.#generateTeamNodeForAll();
                this.#nodes.push(node);
                if (i < (total / 2)) {
                    this.#left.appendChild(node.base);
                } else {
                    this.#right.appendChild(node.base);
                }
            }
        }

        // テキスト設定
        const node = this.#nodes[rank];
        node.rank.innerText = team.rank;
        node.name.innerText = this.#getTeamName(team.id, team.name);
        node.placement_value.innerText = team.points - team.kills;
        node.placement_label.innerText = 'PP';
        if (placement != null) {
            node.placement_value.innerHTML += '<span>(' + placement + ')</span>';
        }
        node.kills_value.innerText = team.kills;
        node.kills_label.innerText = 'KP';
        node.points_value.innerText = team.points;
        node.points_label.innerText = 'TOTAL';
    }

    #generateTeamNodeForSingle() {
        const node = {
            base: document.createElement('div'),
            banner: document.createElement('div'),
            name: document.createElement('div'),
            placement: document.createElement('div'),
            placement_label: document.createElement('div'),
            placement_value: document.createElement('div'),
            kills: document.createElement('div'),
            kills_label: document.createElement('div'),
            kills_value: document.createElement('div'),
            points: document.createElement('div'),
            points_label: document.createElement('div'),
            points_value: document.createElement('div')
        }

        /* append */
        node.base.appendChild(node.banner);
        node.banner.appendChild(node.name);
        node.banner.appendChild(node.placement);
        node.banner.appendChild(node.kills);
        node.banner.appendChild(node.points);
        node.placement.appendChild(node.placement_label);
        node.placement.appendChild(node.placement_value);
        node.kills.appendChild(node.kills_label);
        node.kills.appendChild(node.kills_value);
        node.points.appendChild(node.points_label);
        node.points.appendChild(node.points_value);

        /* set class */
        node.base.classList.add('result-single-team-base');
        node.banner.classList.add('result-single-team-banner');
        node.name.classList.add('result-single-team-name');
        node.placement.classList.add('result-single-team-placement');
        node.placement_label.classList.add('result-single-team-placement-label');
        node.placement_value.classList.add('result-single-team-placement-value');
        node.kills.classList.add('result-single-team-kills');
        node.kills_label.classList.add('result-single-team-kills-label');
        node.kills_value.classList.add('result-single-team-kills-value');
        node.points.classList.add('result-single-team-points');
        node.points_label.classList.add('result-single-team-points-label');
        node.points_value.classList.add('result-single-team-points-value');

        /* set text */
        node.placement_label.innerText = 'place';
        node.kills_label.innerText = 'kills';
        node.points_label.innerText = 'points';
        return node;
    }

    #generatePlayerLabelNodeForSingle() {
        const node = {
            base: document.createElement('div'),
            name: document.createElement('div'),
            character: document.createElement('div'),
            kills: document.createElement('div'),
            assists: document.createElement('div'),
            damage: document.createElement('div')
        }

        /* append */
        node.base.appendChild(node.name);
        node.base.appendChild(node.character);
        node.base.appendChild(node.kills);
        node.base.appendChild(node.assists);
        node.base.appendChild(node.damage);

        /* set class */
        node.base.classList.add('result-single-player-label-base');
        node.name.classList.add('result-single-player-label-name');
        node.character.classList.add('result-single-player-label-character');
        node.kills.classList.add('result-single-player-label-kills');
        node.assists.classList.add('result-single-player-label-assists');
        node.damage.classList.add('result-single-player-label-damage');

        /* set text */
        node.name.innerText = 'name';
        node.character.innerText = 'CH';
        node.kills.innerText = 'K';
        node.assists.innerText = 'A';
        node.damage.innerText = 'DMG';

        return node;
    }

    #generatePlayerNodeForSingle() {
        const node = {
            base: document.createElement('div'),
            name: document.createElement('div'),
            character: document.createElement('div'),
            kills: document.createElement('div'),
            assists: document.createElement('div'),
            damage: document.createElement('div')
        }

        /* append */
        node.base.appendChild(node.name);
        node.base.appendChild(node.character);
        node.base.appendChild(node.kills);
        node.base.appendChild(node.assists);
        node.base.appendChild(node.damage);

        /* set class */
        node.base.classList.add('result-single-player-base');
        node.name.classList.add('result-single-player-name');
        node.character.classList.add('result-single-player-character');
        node.kills.classList.add('result-single-player-kills');
        node.assists.classList.add('result-single-player-assists');
        node.damage.classList.add('result-single-player-damage');

        return node;
    }

    #drawResult(gameid) {
        if (gameid >= this.#_results.length) return;
        const result = this.#_results[gameid];

        for (const [teamidstr, data] of Object.entries(result.teams)) {
            const teamid = parseInt(teamidstr, 10);
            const teamnode = this.#generateTeamNodeForSingle();
            
            // テキスト設定
            teamnode.name.innerText = this.#getTeamName(teamid, data.name);
            teamnode.placement_value.innerText = data.placement;
            teamnode.kills_value.innerText = data.kills;
            teamnode.points_value.innerText = data.kills + (data.placement - 1 < 15 ? ResultView.points_table[data.placement - 1] : 0);

            // ラベル
            const playerlabelnode = this.#generatePlayerLabelNodeForSingle();
            teamnode.base.appendChild(playerlabelnode.base);

            for (const player of data.players) {
                const playernode = this.#generatePlayerNodeForSingle();
                teamnode.base.appendChild(playernode.base);

                // テキスト設定
                playernode.name.innerText = this.#getPlayerName(player.id, player.name);
                playernode.character.innerText = player.character;
                playernode.kills.innerText = player.kills;
                playernode.assists.innerText = player.assists;
                playernode.damage.innerText = player.damage_dealt;

                // 更新用に登録
                this.#savePlayerNode(player.id, playernode.name);
            }
            this.#single.appendChild(teamnode.base);
        }
    }

    #drawGameInfo() {
        // infonodesの数を調整
        if (this.#infonodes.length > this.#_results.length) {
            // 削除
            for (let i = this.#infonodes.length; i <= this.#_results.length; --i) {
                this.#infonodes.pop(); // 最後の要素を削除
                this.#info.removeChild(this.#info.lastChild()); // 最後の要素を削除
            }
        } else if (this.#infonodes.length < this.#_results.length) {
            // 追加
            for (let i = this.#infonodes.length; i < this.#_results.length; ++i) {
                const node = this.#generateGameInfoNode(i);
                this.#infonodes.push(node);
                this.#info.appendChild(node.base);
            }
        }
        
        // テキスト設定
        for (let i = 0; i < this.#_results.length; ++i) {
            const result = this.#_results[i];
            const node = this.#infonodes[i];
            node.gamenumber.innerText = 'Game ' + (i + 1);
            node.datacenter.innerText = 'datacenter: ' + result.datacenter;
            node.serverid.innerText = 'serverid: '+ result.serverid;
            node.playlistname.innerText = 'playlistname: ' + result.playlistname;
            node.playlistdesc.innerText = 'playlistdesc: ' + result.playlistdesc;
            node.map.innerText = 'map: ' + result.map;
            node.start.innerText = 'start: ' + (new Date(result.start)).toLocaleString();
            node.end.innerText = 'end: ' + (new Date(result.end)).toLocaleString();
            node.anonymousmode.innerText = 'anonymousmode: ' + (result.anonymousmode ? 'true' : 'false');
            node.aimassiston.innerText = 'aimassiston: ' + (result.aimassiston ? 'true' : 'false');
        }
    }

    #drawResults(target) {
        // 計算用
        const data = {};

        const result_to_data = (gameid, result) => {
            if ('teams' in result) {
                for (const [k, v] of Object.entries(result.teams)) {
                    if (!(k in data)) {
                        data[k] = {
                            id: parseInt(k, 10),
                            name: v.name,
                            points: 0,
                            kills: 0,
                            points_array: [],
                            placement_array: [],
                            kills_array: [],
                            players: {}
                        };
                    }
                    const team = data[k];

                    /* ポイント・キル加算 */
                    let points = v.kills;
                    if (v.placement - 1 < 15) {
                        points += ResultView.points_table[v.placement - 1];
                    }
                    team.points += points;
                    team.kills += v.kills;

                    /* タイブレーク用の値を挿入 */
                    team.points_array.push(points);
                    team.placement_array.push(v.placement);
                    team.kills_array.push(v.kills);

                    /* ソートしておく */
                    team.points_array.reverse();
                    team.placement_array.sort();
                    team.kills_array.reverse();

                    /* プレイヤーデータ更新 */
                    for (const player of v.players) {
                        if (!(player.id in team.players)) {
                            team.players[player.id] = {
                                name: player.name,
                                kills: 0
                            };
                        }
                        team.players[player.id].kills += player.kills;
                    }
                }
            }
        };

        // 過去のゲームのポイントを加算
        if (target == 'all') {
            for (const [gameid, result] of this.#_results.entries()) {
                result_to_data(gameid, result);
            }
        } else if (typeof target == 'number') {
            if (target < this.#_results.length) {
                result_to_data(target, this.#_results[target]);
            } else {
                return;
            }
        } else {
            return;
        }

        // 順位ソート
        const p = Object.keys(data);
        p.sort((a, b) => {
            const _a = data[a];
            const _b = data[b];
            // 現在のトータルポイント比較
            if (_a.points > _b.points) return -1;
            if (_a.points < _b.points) return  1;
            
            // 同点の場合は、過去のゲームの最高ポイント
            for (let i = 0; i < _a.points_array.length && i < _b.points_array.length; ++i) {
                if (_a.points_array[i] > _b.points_array[i]) return -1;
                if (_a.points_array[i] < _b.points_array[i]) return  1;
            }

            // 同点の場合は、過去のゲームの最高順位
            for (let i = 0; i < _a.placement_array.length && i < _b.placement_array.length; ++i) {
                if (_a.placement_array[i] > _b.placement_array[i]) return  1;
                if (_a.placement_array[i] < _b.placement_array[i]) return -1;
            }

            // 同点の場合は、過去のゲームの最高キル数
            for (let i = 0; i < _a.kills_array.length && i < _b.kills_array.length; ++i) {
                if (_a.kills_array[i] > _b.kills_array[i]) return -1;
                if (_a.kills_array[i] < _b.kills_array[i]) return  1;
            }

            // イレギュラー: 試合数多いほうが勝ち(比較対象が多い)
            if (_a.points_array.length > _b.points_array.length) return -1;
            if (_a.points_array.length < _b.points_array.length) return  1;

            return 0;
        });

        for (let i = 0; i < p.length; ++i) {
            // 計算した順番を保存
            const teamid = p[i];
            const team = data[teamid];
            team.rank = i + 1;

            // 描画
            if (target == 'all') {
                this.#drawTeamForAll(i, p.length, team);
            } else {
                this.#drawTeamForAll(i, p.length, team, this.#_results[target].teams[p[i]].placement);
            }
        }
    }

    #selectCurrentGame(gameid) {
        if (gameid < this.#infonodes.length) {
            const node = this.#infonodes[gameid];
            node.base.classList.add('result-game-info-selected');
        }
    }

    #clearCurrentGame() {
        for(const node of document.querySelectorAll('.result-game-info-selected')) {
            node.classList.remove('result-game-info-selected');
        }
    }

    #getTeamName(teamid, fallback) {
        if (this.#_game != null) {
            if (teamid < this.#_game.teams.length) {
                const team = this.#_game.teams[teamid];
                if ('params' in team && 'name' in team.params && team.params.name != '') {
                    return team.params.name;
                }
            }
        }
        return fallback;
    }

    #getPlayerName(id, fallback) {
        if (id in this.#players) {
            const player = this.#players[id];
            if ('params' in player && 'name' in player.params && player.params.name != '') {
                return player.params.name;
            }
        } else {
            if (typeof(this.#unknownidcallback) == 'function') {
                this.#unknownidcallback(id);
            }
        }
        return fallback;
    }

    #savePlayerNode(id, node) {
        if (!(id in this.#players)) {
            this.#players[id] = {
                nodes: [],
            };
        }
        const player = this.#players[id];
        player.nodes.push(node);
    }

    savePlayerParams(id, params) {
        if (!(id in this.#players)) {
            this.#players[id] = {
                nodes: [],
            };
        }
        const player = this.#players[id];
        player.params = params;
        for (const node of player.nodes) {
            if ('name' in player.params) {
                node.innerText = player.params.name;
            }
        }
    }

    clear() {
        this.#info.innerHTML = '';
        this.#left.innerHTML = '';
        this.#right.innerHTML = '';
        this.#single.innerHTML = '';
        this.#nodes.splice(0);
        this.#infonodes.splice(0);
        for (const [playerid, data] of Object.entries(this.#players)) {
            data.nodes.splice(0);
        }
    }

    #hideSingleGameResult() {
        this.#single.classList.add('hide');
    }

    showSingleGameResult(gameid) {
        this.#current = gameid;

        // 内容表示
        this.clear();
        if (this.#_results != null) {
            this.#drawGameInfo();
            this.#clearCurrentGame();
            this.#selectCurrentGame(gameid);
            this.#drawResults(gameid);
            this.#drawResult(gameid);
        }

        // 表示切替
        this.#single.classList.remove('hide');
    }

    showAllResults() {
        this.#current = 'all';

        // 内容表示
        this.clear();
        if (this.#_results != null) {
            this.#drawGameInfo();
            this.#clearCurrentGame();
            this.#drawResults('all');
        }

        // 表示切替
        this.#hideSingleGameResult();
    }
    
    setResults(results) {
        this.#_results = results;
        if (this.#current == 'all') {
            this.showAllResults();
        } else {
            this.showSingleGameResult(this.#current);
        }
    }

    setGame(game) {
        console.log(game);
        this.#_game = game;
    }

    setGameClickCallback(func) {
        this.#callback = func;
    }
    setUnknownIDCallback(func) {
        this.#unknownidcallback = func;
    }
}

class WebAPIConfig {
    #webapi;
    #_game;
    #tournament_id;
    #tournament_name;
    #tournament_ids;
    #players;
    #realtimeview;
    #observerconfig;
    #resultview;

    constructor(url) {
        this.#tournament_id = "";
        this.#tournament_name = "noname";
        this.#tournament_ids = {};
        this.#players = {};
        this.#realtimeview = new RealtimeView();
        this.#observerconfig = new ObserverConfig();
        this.#resultview = new ResultView();

        this.#setupWebAPI(url);
        this.#setupButton();
        this.#setupCallback();
        this.#setupTextarea();
        this.#setupMenuSelect();
        this.#setupLineNumber();
    }

    #setupWebAPI(url) {
        this.#webapi = new ApexWebAPI.ApexWebAPI(url);

        // 接続系
        this.#webapi.addEventListener('open', (ev) => {
            this.#_game = ev.detail.game;
            this.#realtimeview.setGame(ev.detail.game);
            this.#resultview.setGame(ev.detail.game);
            this.#setConnectionStatus('open');

            /* 初回情報取得 */
            this.#webapi.getCurrentTournament();
            this.#webapi.getTournamentIDs();
            this.#webapi.getPlayers();
            this.#webapi.getAll();
            this.#webapi.getObserver();
            this.#webapi.getObservers();
            this.#webapi.sendGetLobbyPlayers();
            this.#webapi.getTournamentResults();
        });

        this.#webapi.addEventListener('close', (ev) => {
            this.#setConnectionStatus('close');
        });

        this.#webapi.addEventListener('error', (ev) => {
            this.#setConnectionStatus('error');
        });

        /* 設定変更イベント */
        this.#webapi.addEventListener('getcurrenttournament', (ev) => {
            if (ev.detail.id != '' && this.#tournament_id != ev.detail.id) {
                // 現在のトーナメントIDが変わった場合
                this.#getTeamNames();
            }
            this.#tournament_id = ev.detail.id;
            this.#tournament_name = ev.detail.name;
            if (ev.detail.id == '') {
                this.#setCurrentTournament('none', 'noname');
                window.location.assign("#tournament-set");
            } else {
                this.#setCurrentTournament(ev.detail.id, ev.detail.name);
            }
            this.#setCurrentResultsCount(ev.detail.count);
        });

        this.#webapi.addEventListener('gettournamentids', (ev) => {
            this.#procTournamentIDs(event.detail.ids);
        });

        this.#webapi.addEventListener('settournamentname', (ev) => {
            this.#webapi.getCurrentTournament();
            this.#webapi.getTournamentIDs();
            this.#webapi.getTournamentResults();
        });

        this.#webapi.addEventListener('renametournamentname', (ev) => {
            this.#webapi.getCurrentTournament();
            this.#webapi.getTournamentIDs();
        });

        this.#webapi.addEventListener('getplayers', (ev) => {
            for (const [id, params] of Object.entries(ev.detail.players)) {
                if (!(id in this.#players)) {
                    this.#players[id] = {};
                }
                this.#players[id].params = params;
                this.#realtimeview.redrawPlayerName(id, params); // RealtimeViewの再描画
                this.#resultview.savePlayerParams(id, params); // ResultView用にも保存
            }
            this.#procPlayers();
        });

        this.#webapi.addEventListener('lobbyplayer', (ev) => {
            this.#procPlayerInGameName(ev.detail.hash, ev.detail.name);
            if (ev.detail.observer) {
                this.#observerconfig.drawObserverName(ev.detail.hash, ev.detail.name);
            }
        });

        /* observer用 */
        this.#webapi.addEventListener('getobserver', (ev) => {
            this.#observerconfig.setCurrentObserver(ev.detail.hash); 
        });
        this.#webapi.addEventListener('getobservers', (ev) => {
            for (const observer of ev.detail.observers) {
                this.#observerconfig.drawObserverName(observer.hash, observer.name);
            }
        })

        /* realtime view 用 関連付け */
        this.#webapi.addEventListener('matchsetup', (ev) => {
            this.#realtimeview.drawGameInfo();
        })
        this.#webapi.addEventListener('gamestatechange', (ev) => {
            this.#realtimeview.drawGameInfo();
        })
        this.#webapi.addEventListener('clearlivedata', (ev) => {
            this.#_game = ev.detail.game;
            this.#realtimeview.setGame(ev.detail.game);
            this.#realtimeview.clear();
        });
        this.#webapi.addEventListener('teamname', (ev) => {
            this.#realtimeview.drawTeamName(ev.detail.team.id);
        });
        this.#webapi.addEventListener('playerstats', (ev) => {
            this.#realtimeview.drawTeamKills(ev.detail.team.id);
            this.#realtimeview.drawPlayerNode(ev.detail.team.id, ev.detail.player.id, RealtimeView.PLAYERNODE_KILLS);
            this.#realtimeview.drawPlayerNode(ev.detail.team.id, ev.detail.player.id, RealtimeView.PLAYERNODE_ASSISTS);
        });
        this.#webapi.addEventListener('squadeliminate', (ev) => {
            this.#realtimeview.drawTeamPlacement(ev.detail.team.id);
            this.#realtimeview.drawTeamEliminated(ev.detail.team.id);
        });
        this.#webapi.addEventListener('teamplacement', (ev) => {
            this.#realtimeview.drawTeamPlacement(ev.detail.team.id);
            this.#realtimeview.drawTeamEliminated(ev.detail.team.id);
        });
        this.#webapi.addEventListener('setteamparams', (ev) => {
            const teamid = ev.detail.teamid;
            if (teamid >= this.#_game.teams.length) return;
            if (!('name' in this.#_game.teams[teamid])) return;
            this.#realtimeview.drawTeamName(ev.detail.teamid);
        });
        this.#webapi.addEventListener('getteamparams', (ev) => {
            const teamid = ev.detail.teamid;
            if (teamid >= this.#_game.teams.length) return;
            if (!('name' in this.#_game.teams[teamid])) return;
            this.#realtimeview.drawTeamName(ev.detail.teamid);
        });
        this.#webapi.addEventListener('playername', (ev) => {
            this.#realtimeview.drawPlayerNode(ev.detail.team.id, ev.detail.player.id, RealtimeView.PLAYERNODE_NAME);
        });
        this.#webapi.addEventListener('playercharacter', (ev) => {
            this.#realtimeview.drawPlayerNode(ev.detail.team.id, ev.detail.player.id, RealtimeView.PLAYERNODE_CHARACTER);
        });
        this.#webapi.addEventListener('playerhp', (ev) => {
            this.#realtimeview.drawPlayerNode(ev.detail.team.id, ev.detail.player.id, RealtimeView.PLAYERNODE_HP);
        });
        this.#webapi.addEventListener('playershield', (ev) => {
            this.#realtimeview.drawPlayerNode(ev.detail.team.id, ev.detail.player.id, RealtimeView.PLAYERNODE_SHIELD);
        });
        this.#webapi.addEventListener('playerdamage', (ev) => {
            this.#realtimeview.drawPlayerNode(ev.detail.team.id, ev.detail.player.id, RealtimeView.PLAYERNODE_DAMAGE_DEALT);
            this.#realtimeview.drawPlayerNode(ev.detail.team.id, ev.detail.player.id, RealtimeView.PLAYERNODE_DAMAGE_TAKEN);
        });
        this.#webapi.addEventListener('statealive', (ev) => {
            this.#realtimeview.drawPlayerNode(ev.detail.team.id, ev.detail.player.id, RealtimeView.PLAYERNODE_STATE);
        });
        this.#webapi.addEventListener('statedown', (ev) => {
            this.#realtimeview.drawPlayerNode(ev.detail.team.id, ev.detail.player.id, RealtimeView.PLAYERNODE_STATE);
        });
        this.#webapi.addEventListener('statekilled', (ev) => {
            this.#realtimeview.drawPlayerNode(ev.detail.team.id, ev.detail.player.id, RealtimeView.PLAYERNODE_STATE);
        });
        this.#webapi.addEventListener('statecollected', (ev) => {
            this.#realtimeview.drawPlayerNode(ev.detail.team.id, ev.detail.player.id, RealtimeView.PLAYERNODE_STATE);
        });
        this.#webapi.addEventListener('observerswitch', (ev) => {
            if (ev.detail.own) {
                this.#realtimeview.drawPlayerNode(ev.detail.team.id, ev.detail.player.id, RealtimeView.PLAYERNODE_SELECTED);
            }
        });
        this.#webapi.addEventListener('playeritem', (ev) => {
        })

        /* result用 */
        this.#webapi.addEventListener('gettournamentresults', (ev) => {
            this.#resultview.setResults(ev.detail.results);
        });
        this.#webapi.addEventListener('saveresult', (ev) => {
            this.#webapi.getTournamentResults();
            this.#setCurrentResultsCount(ev.detail.gameid + 1);
        });
        this.#webapi.addEventListener('getplayerparams', (ev) => {
            this.#resultview.savePlayerParams(ev.detail.hash, ev.detail.params);
            this.#realtimeview.redrawPlayerName(ev.detail.hash, ev.detail.params); // RealtimeViewの再描画
        });

        /* Overlay用 */
        this.#webapi.addEventListener('broadcastobject', (ev) => {
            const data = ev.detail.data;
            console.log(data);
            if ('type' in data && data.type == 'getalloverlaystate') {
                this.#sendAllOverlayState();
            }
        });
    }

    #setupButton() {

        document.getElementById('connectbtn').addEventListener('click', (ev) => {
            this.#webapi.forceReconnect();
        });

        document.getElementById('tournament-set-button').addEventListener('click', (ev) => {
            const text = document.getElementById('tournament-set-text').value;
            if (text != '') {
                this.#webapi.setTournamentName(text);
            }
        });

        document.getElementById('tournament-rename-button').addEventListener('click', (ev) => {
            const text = document.getElementById('tournament-rename-text').value;
            if (text != '' || this.#tournament_id != '') {
                this.#webapi.renameTournamentName(this.#tournament_id, text);
            }
        });

        document.getElementById('observer-set-getfromlobby').addEventListener('click', (ev) => {
            this.#webapi.sendGetLobbyPlayers().then((ev) => {}, () => {});
        });

        document.getElementById('player-name-getfromresults').addEventListener('click', (ev) => {
            this.#webapi.getTournamentResults().then((ev) => {
                this.#getPlayerFromResults(ev.detail.results);
            }, () => {});
        });

        document.getElementById('player-name-getfromlivedata').addEventListener('click', (ev) => {

        });

        document.getElementById('player-name-getfromlobby').addEventListener('click', (ev) => {
            this.#webapi.sendGetLobbyPlayers().then((ev) => {}, () => {});
        });

        document.getElementById('team-name-button').addEventListener('click', (ev) => {
            this.#procSetTeamName().then((arr) => {
                this.#paramsArrayToTextarea(arr);
            });
        });

        document.getElementById('announce-button').addEventListener('click', (ev) => {
            const text = document.getElementById('announce-text').value;
            if (text != "") {
            this.#webapi.sendChat(text).then(() => {}, () => {});
            }
        });

        // checkbox
        for (const id of ["leaderboard", "teambanner", "playerbanner", "teamkills", "owneditems", "gameinfo", "championbanner"]) {
            document.getElementById('overlay-hide-' + id).addEventListener('change', (ev) => {
                this.#sendOverlayHideStatusByID(id);
            });
        }
        document.getElementById('overlay-hide-teamplayerinfo').addEventListener('change', (ev) => {
            const teamplayeroverlays = ["teambanner", "playerbanner", "teamkills", "owneditems"];
            for (const id of teamplayeroverlays) {
                document.getElementById('overlay-hide-' + id).checked = ev.target.checked;
                this.#sendOverlayHideStatusByID(id);
            }
        });
    }

    #setupCallback() {
        this.#observerconfig.setClickCallback((id) => {
            this.#webapi.setObserver(id).then((ev) => {
                this.#observerconfig.setCurrentObserver(ev.detail.hash).then(() => {}, () => {});
            }, () => {});
        });

        this.#realtimeview.setPlayerClickCallback((teamid, playerid) => {
            if (teamid >= this.#_game.teams.length) return;
            const team = this.#_game.teams[teamid];
            if (playerid >= team.players.length) return;
            const player = team.players[playerid];
            if (!('name' in player)) return;
            if (!('state' in player)) return;
            if (!(player.name == '')) return;
            if (player.state != ApexWebAPI.ApexWebAPI.WEBAPI_PLAYER_STATE_ALIVE) return;
            this.#webapi.changeCamera(player.name).then(() => {}, () => {});
        });

        this.#resultview.setGameClickCallback((gameid) => {
            location.assign('#result-' + gameid);
        });
        
        this.#resultview.setUnknownIDCallback((playerhash) => {
            this.#webapi.getPlayerParams(playerhash);
        });
    }

    #setupTextarea() {
        document.getElementById('team-name-text').addEventListener('change', (ev) => {
            this.#procTeamNameTextareaUpdate(ev.target.value);
        });
    }

    #setupMenuSelect() {
        this.#procCurrentHash(location.hash);
        window.addEventListener("hashchange", (ev) => {
            this.#procCurrentHash(location.hash);
        });
    }

    #setupLineNumber() {
        const targets = [
            document.getElementById('team-name-num')
        ];
        let dst = '';
        for(let i = 0; i < 30; ++i) {
            if (dst != '') dst += '\r\n';
            dst += (i + 1);
        }
        for (const t of targets) {
            t.innerText = dst;
        }
    }

    #getFragment(s) {
        const first = s.indexOf('#');
        return first >= 0 ? s.substring(first + 1) : '';
    }
    #getMainMenu(s) {
        const first = s.indexOf('-');
        return first >= 0 ? s.substring(0, first) : s;
    }
    #getSubMenu(s) {
        const first = s.indexOf('-');
        return first >= 0 ? s.substring(first + 1) : '';
    }

    #procCurrentHash(hash) {
        const fragment = this.#getFragment(hash);
        const mainmenu = this.#getMainMenu(fragment);
        const submenu = this.#getSubMenu(fragment);
        if (mainmenu == 'result') {
            for (const c of document.getElementById('main').children) {
                if (c.id == 'result') {
                    c.classList.remove('hide');
                } else {
                    c.classList.add('hide');
                }
            }
            this.#showResult(submenu);
        } else {
            for (const c of document.getElementById('main').children) {
                if (c.id == fragment) {
                    c.classList.remove('hide');
                } else {
                    c.classList.add('hide');
                }
            }
        }

        /* 選択表示 */
        for (const node of document.querySelectorAll('.sidebar-selected')) {
            node.classList.remove('sidebar-selected');
        }
        for (const node of document.querySelectorAll('a[href="#' + fragment + '"]')) {
            node.classList.add('sidebar-selected');
        }

        /* ページ遷移起因でのデータ取得 */
        console.log(fragment);
        if (fragment == 'observer-set') {
            this.#webapi.getObserver();
            this.#webapi.getObservers();
        }
    }

    #procTournamentIDs(ids) {
        const tbody = document.getElementById('tournamentids');
        for (const [id, name] of Object.entries(ids)) {
            if (id in this.#tournament_ids) {
                const c = this.#tournament_ids[id];
                c.name = name;
                c.node.children[0].innerText = name;
            } else {
                this.#tournament_ids[id] = {
                    id: id,
                    name: name,
                    node: document.createElement('tr')
                };
                const c = this.#tournament_ids[id];
                c.node.appendChild(document.createElement('td'));
                c.node.appendChild(document.createElement('td'));
                c.node.children[0].innerText = name;
                c.node.children[1].innerText = id;
                tbody.appendChild(c.node);
                c.node.addEventListener('click', (ev) => {
                    this.#webapi.setTournamentName(c.node.children[0].innerText);
                });
                if (id == this.#tournament_id) {
                    c.node.classList.add('tournament-set-selected');
                }
            }
        }
    }

    #procTeamNameTextareaUpdate(src) {
        const t = document.getElementById('team-name-output');
        let dst = '';
        const lines = src.split(/\r\n|\n/);
        for (let i = 0; i < 30 && i < lines.length; ++i) {
            const line = lines[i].trim();
            if (dst != '') dst += '\r\n';
            dst += (line == '' ? '' : 'Team' + (i + 1) + ': ' + line);
        }
        t.innerText = dst;
    }

    #procSetTeamName() {
        return new Promise((resolve, reject) => {
            const text = document.getElementById('team-name-text').value;
            const jobs = [];
            const lines = text.split(/\r\n|\n/);
            for (let i = 0; i < 30; ++i) {
                if (i < lines.length) {
                    const line = lines[i].trim();
                    if (line != '') {
                        jobs.push(this.#getAndSetTeamName(i, line));
                    } else {
                        jobs.push(this.#getAndRemoveTeamName(i));
                    }
                } else {
                    jobs.push(this.#getAndRemoveTeamName(i));
                }
            }
            Promise.all(jobs).then(resolve, reject);
        });
    }

    #buildPlayerNameTR(hash, params) {
        const tr = document.createElement('tr');
        tr.appendChild(document.createElement('td'));
        tr.appendChild(document.createElement('td'));
        tr.appendChild(document.createElement('td'));
        tr.appendChild(document.createElement('td'));
        tr.children[0].innerText = hash;
        const input = document.createElement('input');
        const button = document.createElement('button')
        tr.children[3].appendChild(input);
        tr.children[3].appendChild(button);
        button.innerText = 'set';
        button.addEventListener('click', () => {
            let changed = false;
            const txt = input.value.trim();
            if (txt == '') {
                // 削除
                if ('name' in params) {
                    delete params.name;
                    changed = true;
                }
            } else {
                if (params.name != txt) {
                    params.name = txt;
                    changed = true;
                }
            }
            if (changed) {
                // 更新を送信
                this.#webapi.setPlayerParams(hash, params).then((ev) => {
                    if (ev.detail.result) {
                        this.#setTextPlayerNameTR(tr, params);
                    }
                }, () => {});
            }
        });
        return tr;
    }

    #setTextPlayerNameTR(node, params) {
        if ('name' in params) node.children[1].innerText = params.name;
        if ('ingamenames' in params) {
            let txt = '';
            for (const name of params.ingamenames) {
                if (txt != '') txt += ',';
                txt += name;
            }
            node.children[2].innerText = txt;
        }
    };

    #procPlayers() {
        const tbody = document.getElementById('player-name-list');
        for (const [hash, data] of Object.entries(this.#players)) {
            if (!('node' in data)) {
                data.node = this.#buildPlayerNameTR(hash, data.params);
                tbody.appendChild(data.node);
            }
            this.#setTextPlayerNameTR(data.node, data.params);
        }
    }

    #procPlayerInGameName(hash, ingamename) {
        let updated = false;
        if (!(hash in this.#players)) {
            this.#players[hash] = {};
        }
        const player = this.#players[hash];
        if (!('params' in player)) {
            player.params = {};
        }
        if (!('ingamenames' in player.params)) {
            player.params.ingamenames = [];
        }
        if (player.params.ingamenames.indexOf(ingamename) == -1) {
            player.params.ingamenames.push(ingamename);
            updated = true;
        }
        if (!('node' in player)) {
            player.node = this.#buildPlayerNameTR(hash, player.params);
            document.getElementById('player-name-list').appendChild(player.node);
        }
        this.#setTextPlayerNameTR(player.node, player.params);
        
        this.#webapi.setPlayerParams(hash, player.params).then(() => {}, () => {});
    }

    #getPlayerFromResults(results) {
        for (const result of results) {
            for (const [_, team] of Object.entries(result.teams)) {
                for (const player of team.players) {
                    this.#procPlayerInGameName(player.id, player.name);
                }
            }
        }
    }

    #sendOverlayHideStatusByID(id) {
        const checked = document.getElementById('overlay-hide-' + id).checked;
        this.#webapi.broadcastObject({
            type: "forcehide" + id,
            value: checked
        }).then(() => {}, () => {});
    }

    #sendAllOverlayState() {
        this.#sendOverlayHideStatusByID('leaderboard');
        this.#sendOverlayHideStatusByID('teambanner');
        this.#sendOverlayHideStatusByID('teamkills');
        this.#sendOverlayHideStatusByID('playerbanner');
        this.#sendOverlayHideStatusByID('owneditems');
    }

    #getAndSetTeamName(teamid, name) {
        return new Promise((resolve, reject) => {
            this.#webapi.getTeamParams(teamid).then((getev) => {
                const params = getev.detail.params;
                params.name = name;
                this.#webapi.setTeamParams(teamid, params).then((setev) => {
                    if (setev.detail.result) {
                        resolve(params);
                    } else {
                        reject();
                    }
                }, reject);
            }, reject);
        });
    }

    #getAndRemoveTeamName(teamid) {
        return new Promise((resolve, reject) => {
            this.#webapi.getTeamParams(teamid).then((getev) => {
                const params = getev.detail.params;
                if ('name' in params) delete params.name;
                this.#webapi.setTeamParams(teamid, params).then((setev) => {
                    if (setev.detail.result) {
                        resolve(params);
                    } else {
                        reject();
                    }
                }, reject);
            }, reject);
        });
    }

    #getAllTeamParams() {
        return new Promise((resolve, reject) => {
            const jobs = [];
            for (let i = 0; i < 30; ++i) {
                jobs.push(new Promise((nresolve, nreject) => {
                    return this.#webapi.getTeamParams(i).then((ev) => {
                        nresolve(ev.detail.params);
                    }, nreject);
                }));
            }
            Promise.all(jobs).then(resolve, reject);
        });
    }

    #getTeamNames() {
        this.#getAllTeamParams().then((arr) => { this.#paramsArrayToTextarea(arr); }, () => {});
    }

    #paramsArrayToTextarea(arr) {
        const textarea = document.getElementById('team-name-text');
        let text = '';
        for (const params of arr) {
            if (text != '') text += '\r\n';
            if ('name' in params) {
                text += params.name;
            }
        }
        textarea.value = text;
        this.#procTeamNameTextareaUpdate(textarea.value);
    };

    #showResult(submenu) {
        if (submenu == 'all') {
            this.#resultview.showAllResults();
        } else {
            const gameid = parseInt(submenu, 10);
            if (submenu == gameid.toString()) {
                this.#resultview.showSingleGameResult(gameid);
            }
        }
    }

    #setConnectionStatus(status) {
        document.getElementById('connectstatus').innerText = status;
    }

    #setCurrentTournament(id, name) {
        document.getElementById('current_tournament_id').innerText = id;
        document.getElementById('current_tournament_name').innerText = name;
        document.getElementById('tournament-rename-text').value = name;
        for (const tr of document.querySelectorAll('tr.tournament-set-selected')) {
            tr.classList.remove('tournament-set-selected');
        }
        if (id != '' && id in this.#tournament_ids) {
            this.#tournament_ids[id].node.classList.add('tournament-set-selected');
        }
    }

    #setCurrentResultsCount(count) {
        const ul = document.getElementById('ulresult');
        if (count + 1 > ul.children.length) {
            // append
            for (let i = ul.children.length - 1; i < count; ++i) {
                const li = document.createElement('li');
                const a = document.createElement('a');
                a.href = '#result-' + i;
                a.innerText = "Game " + (i + 1);
                li.appendChild(a);
                ul.appendChild(li);

                // クラス設定
                if (this.#getFragment(location.hash) == ('result-' + i)) {
                    a.classList.add('sidebar-selected');
                }
            }
        } else if (count + 1 < ul.children.length) {
            // remove
            while (count + 1 < ul.children.length) {
                ul.removeChild(ul.lastChild);
            }
        }
    }
}

window.onload = (event) => {
    const config = new WebAPIConfig("ws://127.0.0.1:20081/");
}
</script>
</body>
</html>